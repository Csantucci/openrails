diff --git a/Source/ORTS.Common/Coordinates.cs b/Source/ORTS.Common/Coordinates.cs
index 4a97b3bbd..a846f1392 100644
--- a/Source/ORTS.Common/Coordinates.cs
+++ b/Source/ORTS.Common/Coordinates.cs
@@ -85,6 +85,20 @@ public WorldPosition(WorldLocation copy)
             Location = copy.Location;
         }
 
+
+        /// <summary>
+        /// MSTS WFiles represent some location with a position, quaternion and tile coordinates
+        /// This converts it to the ORTS WorldPosition representation
+        /// </summary>
+        public WorldPosition (int tileX, int tileZ, Vector3 xnaPosition, Quaternion xnaQuaternion)
+        {
+            XNAMatrix = Matrix.CreateFromQuaternion(xnaQuaternion);
+            XNAMatrix *= Matrix.CreateTranslation(xnaPosition);
+
+            TileX = tileX;
+            TileZ = tileZ;
+        }
+
         /// <summary>
         /// The world-location in MSTS coordinates of the current position
         /// </summary>
@@ -169,6 +183,7 @@ public override string ToString()
         }
     }
 
+
     /// <summary>
     /// Represents the position of an object within a tile in MSTS coordinates.
     /// </summary>
@@ -308,6 +323,15 @@ public static Vector2 GetDistance2D(WorldLocation locationFrom, WorldLocation lo
                 (float)(locationTo.Location.Z - locationFrom.Location.Z + (locationTo.TileZ - locationFrom.TileZ) * TileSize));
         }
 
+        public static float ApproximateDistance(WorldLocation a, WorldLocation b)
+        {
+            var dx = a.Location.X - b.Location.X;
+            var dz = a.Location.Z - b.Location.Z;
+            dx += (a.TileX - b.TileX) * 2048;
+            dz += (a.TileZ - b.TileZ) * 2048;
+            return Math.Abs(dx) + Math.Abs(dz);
+        }
+
         /// <summary>
         /// Create a nice string-representation of the world location
         /// </summary>
diff --git a/Source/ORTS.Common/Input/UserCommand.cs b/Source/ORTS.Common/Input/UserCommand.cs
index 69bbc954e..d923f7fc9 100644
--- a/Source/ORTS.Common/Input/UserCommand.cs
+++ b/Source/ORTS.Common/Input/UserCommand.cs
@@ -209,6 +209,7 @@ public enum UserCommand
         [GetString("Control Cylinder Compound")] ControlCylinderCompound,
         [GetString("Control Firing")] ControlFiring,
         [GetString("Control Refill")] ControlRefill,
+        [GetString("Control Discrete Unload")] ControlDiscreteUnload,
         [GetString("Control Water Scoop")] ControlWaterScoop,
         [GetString("Control ImmediateRefill")] ControlImmediateRefill,
         [GetString("Control Turntable Clockwise")] ControlTurntableClockwise,
diff --git a/Source/ORTS.Common/enums.cs b/Source/ORTS.Common/enums.cs
index 605d2800d..5d198cfc7 100644
--- a/Source/ORTS.Common/enums.cs
+++ b/Source/ORTS.Common/enums.cs
@@ -72,4 +72,17 @@ public enum SwitchOrientation
         Trailing
     }
 
+    /// <summary>
+    /// Defines the position of a load (e.g. a container) on a wagon
+    /// </summary>
+    public enum LoadPosition
+    {
+        Rear,
+        CenterRear,
+        Center,
+        CenterFront,
+        Front,
+        Above
+    }
+
 }
diff --git a/Source/ORTS.Settings/InputSettings.cs b/Source/ORTS.Settings/InputSettings.cs
index b14311d3f..c4a166b4c 100644
--- a/Source/ORTS.Settings/InputSettings.cs
+++ b/Source/ORTS.Settings/InputSettings.cs
@@ -403,7 +403,7 @@ static void InitializeCommands(UserCommandInput[] Commands)
             Commands[(int)UserCommand.ControlHeadlightDecrease] = new UserCommandKeyInput(0x23, KeyModifiers.Shift);
             Commands[(int)UserCommand.ControlHeadlightIncrease] = new UserCommandKeyInput(0x23);
             Commands[(int)UserCommand.ControlHorn] = new UserCommandKeyInput(0x39);
-            Commands[(int)UserCommand.ControlImmediateRefill] = new UserCommandKeyInput(0x14, KeyModifiers.Shift);
+            Commands[(int)UserCommand.ControlImmediateRefill] = new UserCommandKeyInput(0x14, KeyModifiers.Control);
             Commands[(int)UserCommand.ControlInitializeBrakes] = new UserCommandKeyInput(0x35, KeyModifiers.Shift);
             Commands[(int)UserCommand.ControlInjector1] = new UserCommandKeyInput(0x17);
             Commands[(int)UserCommand.ControlInjector1Decrease] = new UserCommandKeyInput(0x25, KeyModifiers.Shift);
@@ -424,6 +424,7 @@ static void InitializeCommands(UserCommandInput[] Commands)
             Commands[(int)UserCommand.ControlOdoMeterReset] = new UserCommandKeyInput(0x2C, KeyModifiers.Control);
             Commands[(int)UserCommand.ControlOdoMeterDirection] = new UserCommandKeyInput(0x2C, KeyModifiers.Control | KeyModifiers.Shift);
             Commands[(int)UserCommand.ControlRefill] = new UserCommandKeyInput(0x14);
+            Commands[(int)UserCommand.ControlDiscreteUnload] = new UserCommandKeyInput(0x14, KeyModifiers.Shift);
             Commands[(int)UserCommand.ControlRetainersOff] = new UserCommandKeyInput(0x1A, KeyModifiers.Shift);
             Commands[(int)UserCommand.ControlRetainersOn] = new UserCommandKeyInput(0x1B, KeyModifiers.Shift);
             Commands[(int)UserCommand.ControlSander] = new UserCommandKeyInput(0x2D);
@@ -539,7 +540,7 @@ static void InitializeCommands(UserCommandInput[] Commands)
             Commands[(int)UserCommand.GameExternalCabController] = new UserCommandKeyInput(0x29);
             Commands[(int)UserCommand.GameFullscreen] = new UserCommandKeyInput(0x1C, KeyModifiers.Alt);
             Commands[(int)UserCommand.GameMultiPlayerDispatcher] = new UserCommandKeyInput(0x0A, KeyModifiers.Control);
-            Commands[(int)UserCommand.GameMultiPlayerTexting] = new UserCommandKeyInput(0x14, KeyModifiers.Control);
+            Commands[(int)UserCommand.GameMultiPlayerTexting] = new UserCommandKeyInput(0x14, KeyModifiers.Alt);
             Commands[(int)UserCommand.GamePause] = new UserCommandKeyInput(Keys.Pause);
             Commands[(int)UserCommand.GamePauseMenu] = new UserCommandKeyInput(0x01);
             Commands[(int)UserCommand.GameQuit] = new UserCommandKeyInput(0x3E, KeyModifiers.Alt);
diff --git a/Source/Orts.Formats.Msts/ActivityFile.cs b/Source/Orts.Formats.Msts/ActivityFile.cs
index 948118155..48863c24b 100644
--- a/Source/Orts.Formats.Msts/ActivityFile.cs
+++ b/Source/Orts.Formats.Msts/ActivityFile.cs
@@ -292,6 +292,13 @@ public enum ActivityMode
         Tutorial = 3,
     }
 
+    public struct LoadData
+    {
+        public string Name;
+        public string Folder;
+        public LoadPosition LoadPosition;
+    }
+
     /// <summary>
     /// Parse and *.act file.
     /// Naming for classes matches the terms in the *.act file.
@@ -393,6 +400,7 @@ public class Tr_Activity_Header {
         public int FuelWater = 100;		// percent
         public int FuelCoal = 100;		// percent
         public int FuelDiesel = 100;	// percent
+        public string LoadStationsOccupancyFile;
 
         public Tr_Activity_Header(STFReader stf) {
             stf.MustMatch("(");
@@ -416,6 +424,7 @@ public class Tr_Activity_Header {
                 new STFReader.TokenProcessor("fuelwater", ()=>{ FuelWater = stf.ReadIntBlock(FuelWater); }),
                 new STFReader.TokenProcessor("fuelcoal", ()=>{ FuelCoal = stf.ReadIntBlock(FuelCoal); }),
                 new STFReader.TokenProcessor("fueldiesel", ()=>{ FuelDiesel = stf.ReadIntBlock(FuelDiesel); }),
+                new STFReader.TokenProcessor("ortsloadstationsoccupancy", ()=>{ LoadStationsOccupancyFile = stf.ReadStringBlock(null); }),
             });
         }
 
@@ -1657,6 +1666,7 @@ public class Wagon {
         public bool IsEngine;
         public bool IsEOT;
         public bool Flip;
+        public List<LoadData> LoadDataList;
 
         public Wagon(STFReader stf) {
             stf.MustMatch("(");
@@ -1666,6 +1676,18 @@ public class Wagon {
                 new STFReader.TokenProcessor("enginedata", ()=>{ stf.MustMatch("("); Name = stf.ReadString(); Folder = stf.ReadString(); stf.MustMatch(")"); IsEngine = true; }),
                 new STFReader.TokenProcessor("wagondata", ()=>{ stf.MustMatch("("); Name = stf.ReadString(); Folder = stf.ReadString(); stf.MustMatch(")"); }),
                 new STFReader.TokenProcessor("eotdata", ()=>{ stf.MustMatch("("); Name = stf.ReadString(); Folder = stf.ReadString(); stf.MustMatch(")"); IsEOT = true;  }),
+                new STFReader.TokenProcessor("loaddata", ()=>
+                {
+                    stf.MustMatch("(");
+                    if (LoadDataList == null) LoadDataList = new List<LoadData>();
+                    LoadData loadData = new LoadData();
+                    loadData.Name = stf.ReadString();
+                    loadData.Folder = stf.ReadString();
+                    var positionString = stf.ReadString();
+                    Enum.TryParse(positionString, out loadData.LoadPosition);
+                    LoadDataList.Add(loadData);
+                    stf.MustMatch(")");
+                }),
             });
         }
 
diff --git a/Source/Orts.Formats.Msts/WorldFile.cs b/Source/Orts.Formats.Msts/WorldFile.cs
index ebf672e7d..bac62afac 100644
--- a/Source/Orts.Formats.Msts/WorldFile.cs
+++ b/Source/Orts.Formats.Msts/WorldFile.cs
@@ -15,14 +15,13 @@
 // You should have received a copy of the GNU General Public License
 // along with Open Rails.  If not, see <http://www.gnu.org/licenses/>.
 
+using Microsoft.Xna.Framework;
+using Orts.Parsers.Msts;
+using ORTS.Common;
 using System;
-using System.Collections;
 using System.Collections.Generic;
 using System.Diagnostics;
 using System.IO;
-using Microsoft.Xna.Framework;
-using Orts.Parsers.Msts;
-using ORTS.Common;
 
 namespace Orts.Formats.Msts
 {
@@ -62,13 +61,13 @@ public WorldFile(string filename, List<TokenID> allowedTokens)
             }
         }
 
-        public void InsertORSpecificData (string filename)
+        public void InsertORSpecificData (string filename, List<TokenID> allowedTokens)
         {
             using (var sbr = SBR.Open(filename))
             {
                 using (var block = sbr.ReadSubBlock())
                 {
-                    Tr_Worldfile.InsertORSpecificData(block, filename);
+                    Tr_Worldfile.InsertORSpecificData(block, filename, allowedTokens);
                 }
                 // some w files have additional comments at the end 
                 //       eg _Skip ( "TS DB-Utility - Version: 3.4.05(13.10.2009), Filetype='World', Copyright (C) 2003-2009 by ...CarlosHR..." )
@@ -178,7 +177,7 @@ void LoadObject(SBR subBlock, ref int currentWatermark, string filename)
             }
         }
 
-        public void InsertORSpecificData (SBR block, string filename)
+        public void InsertORSpecificData (SBR block, string filename, List<TokenID> allowedTokens)
         {
             block.VerifyID(TokenID.Tr_Worldfile);
             while (!block.EndOfBlock())
@@ -187,11 +186,13 @@ public void InsertORSpecificData (SBR block, string filename)
                 {
                     try
                     {
-                        WorldObject origObject;
-                        bool wrongBlock = false;
-                        if (!subBlock.EndOfBlock())
+                        if (allowedTokens == null || allowedTokens.Contains(subBlock.ID))
                         {
-                            var subSubBlockUID = subBlock.ReadSubBlock();
+                            WorldObject origObject;
+                            bool wrongBlock = false;
+                            if (!subBlock.EndOfBlock())
+                            {
+                                var subSubBlockUID = subBlock.ReadSubBlock();
                                 // check if a block with this UiD already present
                                 if (subSubBlockUID.ID == TokenID.UiD)
                                 {
@@ -228,8 +229,11 @@ public void InsertORSpecificData (SBR block, string filename)
                                     }
                                 }
  
+                            }
+                            subBlock.EndOfBlock();
                         }
-                        subBlock.EndOfBlock();
+                        else
+                            subBlock.Skip();
                     }
 
                     catch (Exception error)
@@ -309,6 +313,13 @@ public class PickupObj : BaseObj
         public PickupCapacityItem PickupCapacity;
         public List<TrItemId> TrItemIDList = new List<TrItemId>();
         public uint CollideFlags;
+        public int MaxStackedContainers;
+        public float StackLocationsLength = 12.19f;
+        public StackLocationItems StackLocations;
+        public float PickingSurfaceYOffset;
+        public Vector3 PickingSurfaceRelativeTopStartPosition;
+        public float MaxGrabberSpan;
+        public string CraneSound;
 
         public WorldLocation Location;
 
@@ -332,6 +343,13 @@ public override void AddOrModifyObj(SBR subBlock)
                 case TokenID.PickupType: PickupType = subBlock.ReadUInt();
                     subBlock.Skip(); // Discard the 2nd value (0 or 1 but significance is not known)
                     break;
+                case TokenID.ORTSMaxStackedContainers: MaxStackedContainers = subBlock.ReadInt(); break;
+                case TokenID.ORTSStackLocationsLength: StackLocationsLength = subBlock.ReadFloat(); break;
+                case TokenID.ORTSStackLocations: StackLocations = new StackLocationItems(subBlock, this); break;
+                case TokenID.ORTSPickingSurfaceYOffset: PickingSurfaceYOffset = subBlock.ReadFloat(); break;
+                case TokenID.ORTSPickingSurfaceRelativeTopStartPosition: PickingSurfaceRelativeTopStartPosition = subBlock.ReadVector3(); break;
+                case TokenID.ORTSMaxGrabberSpan: MaxGrabberSpan = subBlock.ReadFloat(); break;
+                case TokenID.ORTSCraneSound: CraneSound = subBlock.ReadString(); break;
                 case TokenID.PickupAnimData: PickupAnimData = new PickupAnimDataItem(subBlock); break;
                 case TokenID.PickupCapacity: PickupCapacity = new PickupCapacityItem(subBlock); break;
                 case TokenID.TrItemId: TrItemIDList.Add(new TrItemId(subBlock)); break;
@@ -401,6 +419,58 @@ internal PickupCapacityItem(SBR block)
                 block.VerifyEndOfBlock();
             }
         }
+
+        public class StackLocationItems
+        {
+            public readonly StackLocation[] Locations;
+
+            public StackLocationItems(SBR block, PickupObj pickupObj)
+            {
+                var locations = new List<StackLocation>();
+                var count = block.ReadUInt();
+                for (var i = 0; i < count; i++)
+                {
+                    using (var subBlock = block.ReadSubBlock())
+                    {
+                        if (subBlock.ID == TokenID.StackLocation)
+                        {
+                            locations.Add(new StackLocation(subBlock));
+                        }
+                    }
+                    if (locations[i].Length == 0) locations[i].Length = pickupObj.StackLocationsLength;
+                    if (locations[i].MaxStackedContainers == 0) locations[i].MaxStackedContainers = pickupObj.MaxStackedContainers;
+                }
+                block.VerifyEndOfBlock();
+                Locations = locations.ToArray();
+                locations.Clear();
+            }
+        }
+
+        public class StackLocation
+        {
+            public Vector3 Position;
+            public int MaxStackedContainers;
+            public float Length;
+            public bool Flipped;
+
+            public StackLocation(SBR block)
+            {
+                while (!block.EndOfBlock())
+                {
+                    using (var subBlock = block.ReadSubBlock())
+                    {
+                        switch (subBlock.ID)
+                        {
+                            case TokenID.Position: Position = subBlock.ReadVector3(); break;
+                            case TokenID.MaxStackedContainers: MaxStackedContainers = subBlock.ReadInt(); break;
+                            case TokenID.Length: Length = subBlock.ReadFloat(); break;
+                            case TokenID.Flipped: subBlock.ReadInt();  Flipped = true; break;
+                            default: subBlock.Skip(); break;
+                        }
+                    }
+                }
+            }
+        }
     }
 
     public class TransferObj : WorldObject
diff --git a/Source/Orts.Formats.OR/ContainerFile.cs b/Source/Orts.Formats.OR/ContainerFile.cs
new file mode 100644
index 000000000..b8257edf6
--- /dev/null
+++ b/Source/Orts.Formats.OR/ContainerFile.cs
@@ -0,0 +1,119 @@
+﻿// COPYRIGHT 2017, 2018 by the Open Rails project.
+//
+// This file is part of Open Rails.
+//
+// Open Rails is free software: you can redistribute it and/or modify
+// it under the terms of the GNU General Public License as published by
+// the Free Software Foundation, either version 3 of the License, or
+// (at your option) any later version.
+//
+// Open Rails is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+//
+// You should have received a copy of the GNU General Public License
+// along with Open Rails.  If not, see <http://www.gnu.org/licenses/>.
+
+using System;
+using System.Collections;
+using System.Collections.Generic;
+using System.Diagnostics;
+using System.Text;
+using System.IO;
+using Microsoft.Xna.Framework;
+using Orts.Parsers.OR;
+
+namespace Orts.Formats.OR
+{
+    /// <summary>
+    ///
+    /// class ORWeatherFile
+    /// </summary>
+
+    public class ContainerFile
+    {
+        public ContainerParameters ContainerParameters;
+
+
+        public ContainerFile(string fileName)
+        {
+            JsonReader.ReadFile(fileName, TryParse);
+        }
+
+        protected virtual bool TryParse(JsonReader item)
+        {
+            switch (item.Path)
+            {
+                case "":
+                case "Container":
+                case "Container.":
+                    ContainerParameters = new ContainerParameters(item);
+                    break;
+                default: return false;
+            }
+            return true;
+        }
+    }
+
+
+    public class ContainerParameters
+    {
+        public string Name;
+        public string ShapeFileName;  
+        public string ContainerType;  
+        public Vector3 IntrinsicShapeOffset = new Vector3(0f, 1.17f, 0f);
+        private int Index;
+
+
+        public ContainerParameters(JsonReader json)
+        {
+            json.ReadBlock(TryParse);
+        }
+
+        protected bool TryParse(JsonReader item)
+        {
+
+            // get values
+            switch (item.Path)
+            {
+                case "Container.": break;
+                case "Container.Name": Name = item.AsString(""); break;
+                case "Container.Shape": ShapeFileName = item.AsString(ShapeFileName); break;
+                case "Container.ContainerType": ContainerType = item.AsString("40ftHC"); break;
+                case "Container.IntrinsicShapeOffset[]": 
+                    switch (Index)
+                    {
+                        case 0:
+                            IntrinsicShapeOffset.X = item.AsFloat(0.0f);
+                            break;
+                        case 1:
+                            IntrinsicShapeOffset.Y = item.AsFloat(0.0f);
+                            break;
+                        case 2:
+                            IntrinsicShapeOffset.Z = item.AsFloat(0.0f);
+                            break;
+                        default:
+                            return false;
+                    }
+                    Index++;
+                    break;
+                default: return false;
+            }
+
+            return true;
+        }
+
+        // restore
+        public ContainerParameters(BinaryReader inf)
+        {
+ //           Overcast = inf.ReadSingle();
+        }
+
+        // save
+        public void Save(BinaryWriter outf)
+        {
+//            outf.Write(Overcast);
+        }
+    }
+}
diff --git a/Source/Orts.Formats.OR/LoadStationsOccupancyFile.cs b/Source/Orts.Formats.OR/LoadStationsOccupancyFile.cs
new file mode 100644
index 000000000..271d3d936
--- /dev/null
+++ b/Source/Orts.Formats.OR/LoadStationsOccupancyFile.cs
@@ -0,0 +1,143 @@
+﻿// COPYRIGHT 2017, 2018 by the Open Rails project.
+//
+// This file is part of Open Rails.
+//
+// Open Rails is free software: you can redistribute it and/or modify
+// it under the terms of the GNU General Public License as published by
+// the Free Software Foundation, either version 3 of the License, or
+// (at your option) any later version.
+//
+// Open Rails is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+//
+// You should have received a copy of the GNU General Public License
+// along with Open Rails.  If not, see <http://www.gnu.org/licenses/>.
+
+using System;
+using System.Collections;
+using System.Collections.Generic;
+using System.Diagnostics;
+using System.Text;
+using System.IO;
+using Microsoft.Xna.Framework;
+using Orts.Parsers.OR;
+
+namespace Orts.Formats.OR
+{
+    /// <summary>
+    ///
+    /// class ORWeatherFile
+    /// </summary>
+
+    public class LoadStationsOccupancyFile
+    {
+        public List<LoadStationOccupancy> LoadStationsOccupancy = new List<LoadStationOccupancy>();
+
+        public LoadStationsOccupancyFile(string fileName)
+        {
+            JsonReader.ReadFile(fileName, TryParse);
+        }
+
+        protected virtual bool TryParse(JsonReader item)
+        {
+            switch (item.Path)
+            {
+                case "":
+                    break;
+                case "ContainerStationsOccupancy[].":
+                    break;
+                case "ContainerStationsOccupancy[].LoadStationID.":
+                    LoadStationsOccupancy.Add(new ContainerStationOccupancy(item));
+                    break;
+                case "ContainerStationsOccupancy[].LoadData[].":
+                    break;
+                case "ContainerStationsOccupancy[].LoadData[].File":
+                    var contStationOccupancy = LoadStationsOccupancy[LoadStationsOccupancy.Count - 1] as ContainerStationOccupancy;
+                    contStationOccupancy.LoadData.Add(new LoadDataEntry(item));
+                    contStationOccupancy.LoadData[contStationOccupancy.LoadData.Count - 1].ReadBlock(item);
+                    break;
+                default: return false;
+            }
+            return true;
+        }
+    }
+
+    public class LoadStationOccupancy
+    {
+        public LoadStationID LoadStatID = new LoadStationID();
+
+        public virtual bool TryParse(JsonReader item)
+        {
+            switch (item.Path)
+            {
+                case "wfile": LoadStatID.wfile = item.AsString(""); break;
+                case "UiD": LoadStatID.UiD = item.AsInteger(0); break;
+                default: return false;
+            }
+            return true;
+        }
+    }
+
+    public struct LoadStationID
+    {
+        public string wfile;
+        public int UiD;
+
+        public LoadStationID(JsonReader json)
+        {
+            wfile = "";
+            UiD = 0;
+        }
+    }
+
+    public class ContainerStationOccupancy : LoadStationOccupancy
+    {
+        public List<LoadDataEntry> LoadData = new List<LoadDataEntry>();
+
+        public ContainerStationOccupancy(JsonReader json)
+        {
+
+            json.ReadBlock(TryParse);
+        }
+
+        public override bool TryParse(JsonReader item)
+        {
+            // get values
+            if (base.TryParse(item)) return true;
+            return false;
+        }
+    }
+
+    public class LoadDataEntry
+    {
+        public string FileName;
+        public string FolderName;
+        public int StackLocation;
+
+        public LoadDataEntry(JsonReader json)
+        {
+            FileName = FolderName = "";
+            StackLocation = 0;
+        }
+
+        public void ReadBlock(JsonReader json)
+        {
+            FileName = json.AsString("");
+            json.ReadBlock(TryParse);
+        }
+
+        public bool TryParse(JsonReader item)
+        {
+            switch (item.Path)
+            {
+                case "File": FileName = item.AsString(""); break;
+                case "Folder": FolderName = item.AsString(""); break;
+                case "StackLocation": StackLocation = item.AsInteger(0); break;
+                default: return false;
+            }
+            return true;
+        }
+    }
+}
diff --git a/Source/Orts.Formats.OR/Orts.Formats.OR.csproj b/Source/Orts.Formats.OR/Orts.Formats.OR.csproj
index 168c905ff..a8c92172e 100644
--- a/Source/Orts.Formats.OR/Orts.Formats.OR.csproj
+++ b/Source/Orts.Formats.OR/Orts.Formats.OR.csproj
@@ -67,9 +67,11 @@
     <Compile Include="AEStationPath.cs" />
     <Compile Include="AETraveller.cs" />
     <Compile Include="AuxActionRef.cs" />
+    <Compile Include="ContainerFile.cs" />
     <Compile Include="DrawUtility.cs" />
     <Compile Include="ExtCarSpawnerFile.cs" />
     <Compile Include="GlobalItem.cs" />
+    <Compile Include="LoadStationsOccupancyFile.cs" />
     <Compile Include="MSTSCoord.cs" />
     <Compile Include="MSTSData.cs" />
     <Compile Include="WeatherFile.cs" />
diff --git a/Source/Orts.Parsers.Msts/TokenID.cs b/Source/Orts.Parsers.Msts/TokenID.cs
index 1822b8e7f..1e04c35c8 100644
--- a/Source/Orts.Parsers.Msts/TokenID.cs
+++ b/Source/Orts.Parsers.Msts/TokenID.cs
@@ -1704,8 +1704,19 @@ public enum TokenID : uint
         // ORTS specific
         ORTSListName, // ORTS specific for multi-carspawnerlists
         ORTSSoundFileName, // ORTS specific for individual level crossing sounds
-        ORTSPantographToggle3,
+        ORTSPantographToggle3, 
         ORTSPantographToggle4,
+        ORTSCraneSound,  // ORTS Specific for container stations
+        ORTSMaxStackedContainers,
+        ORTSStackLocations,
+        ORTSStackLocationsLength,
+        ORTSPickingSurfaceYOffset,
+        ORTSPickingSurfaceRelativeTopStartPosition,
+        ORTSMaxGrabberSpan,
+        StackLocation,
+        MaxStackedContainers,
+        Length,
+        Flipped,
 
         // TSRE specific
         Ruler
diff --git a/Source/Orts.Simulation/Common/Events.cs b/Source/Orts.Simulation/Common/Events.cs
index 1c4852683..5f38e3091 100644
--- a/Source/Orts.Simulation/Common/Events.cs
+++ b/Source/Orts.Simulation/Common/Events.cs
@@ -55,6 +55,14 @@ public enum Event
         Couple,
         CoupleB, // NOTE: Currently not used in Open Rails.
         CoupleC, // NOTE: Currently not used in Open Rails.
+        CraneXAxisMove,
+        CraneXAxisSlowDown,
+        CraneYAxisMove,
+        CraneYAxisSlowDown,
+        CraneZAxisMove,
+        CraneZAxisSlowDown,
+        CraneYAxisBumpsOnTarget,
+        CraneYAxisDown,
         CrossingClosing,
         CrossingOpening,
         CylinderCocksToggle,
@@ -276,7 +284,8 @@ public enum Source
             MSTSFuelTower,
             MSTSInGame,
             MSTSSignal,
-            ORTSTurntable
+            ORTSTurntable,
+            ORTSContainerCrane
         }
 
         // PLEASE DO NOT EDIT THESE FUNCTIONS without references and testing!
@@ -587,6 +596,19 @@ public static Event From(Source source, int eventID)
                         case 3: return Event.MovingTableStopped;
                         default: return 0;
                     }
+                case Source.ORTSContainerCrane:
+                    switch (eventID)
+                    {
+                        // Can be different from crane to crane
+                        case 1: return Event.CraneXAxisMove;
+                        case 2: return Event.CraneXAxisSlowDown;
+                        case 3: return Event.CraneYAxisMove;
+                        case 4: return Event.CraneYAxisSlowDown;
+                        case 5: return Event.CraneZAxisMove;
+                        case 6: return Event.CraneZAxisSlowDown;
+                        case 7: return Event.CraneYAxisDown;
+                        default: return 0;
+                    }
                 default: return 0;
             }
         }
diff --git a/Source/Orts.Simulation/Common/Math.cs b/Source/Orts.Simulation/Common/Math.cs
index 86b411f55..835b831ec 100644
--- a/Source/Orts.Simulation/Common/Math.cs
+++ b/Source/Orts.Simulation/Common/Math.cs
@@ -17,6 +17,7 @@
 
 using Microsoft.Xna.Framework;
 using System;
+using System.IO;
 
 namespace Orts.Common
 {
@@ -104,5 +105,47 @@ public static float LineSegmentDistanceSq(Vector3 pt, Vector3 end1, Vector3 end2
          }
          return dx * dx + dy * dy + dz * dz;
       }
-   }
+
+        public static void SaveMatrix(BinaryWriter outf, Matrix matrix)
+        {
+            outf.Write(matrix.M11);
+            outf.Write(matrix.M12);
+            outf.Write(matrix.M13);
+            outf.Write(matrix.M14);
+            outf.Write(matrix.M21);
+            outf.Write(matrix.M22);
+            outf.Write(matrix.M23);
+            outf.Write(matrix.M24);
+            outf.Write(matrix.M31);
+            outf.Write(matrix.M32);
+            outf.Write(matrix.M33);
+            outf.Write(matrix.M34);
+            outf.Write(matrix.M41);
+            outf.Write(matrix.M42);
+            outf.Write(matrix.M43);
+            outf.Write(matrix.M44);
+        }
+
+        public static Matrix RestoreMatrix(BinaryReader inf)
+        {
+            var matrix = Matrix.Identity;
+            matrix.M11 = inf.ReadSingle();
+            matrix.M12 = inf.ReadSingle();
+            matrix.M13 = inf.ReadSingle();
+            matrix.M14 = inf.ReadSingle();
+            matrix.M21 = inf.ReadSingle();
+            matrix.M22 = inf.ReadSingle();
+            matrix.M23 = inf.ReadSingle();
+            matrix.M24 = inf.ReadSingle();
+            matrix.M31 = inf.ReadSingle();
+            matrix.M32 = inf.ReadSingle();
+            matrix.M33 = inf.ReadSingle();
+            matrix.M34 = inf.ReadSingle();
+            matrix.M41 = inf.ReadSingle();
+            matrix.M42 = inf.ReadSingle();
+            matrix.M43 = inf.ReadSingle();
+            matrix.M44 = inf.ReadSingle();
+            return matrix;
+        }
+    }
 }
diff --git a/Source/Orts.Simulation/Common/Scripting/Common.cs b/Source/Orts.Simulation/Common/Scripting/Common.cs
index a351a00d2..b633a0a8e 100644
--- a/Source/Orts.Simulation/Common/Scripting/Common.cs
+++ b/Source/Orts.Simulation/Common/Scripting/Common.cs
@@ -106,6 +106,11 @@ public Timer(EOT eot)
         {
             CurrentValue = () => (float)eot.Train.Simulator.GameTime;
         }
+
+        public Timer(ContainerHandlingItem containerStation)
+        {
+            CurrentValue = () => (float)containerStation.Simulator.GameTime;
+        }
     }
 
     public class OdoMeter : Counter
diff --git a/Source/Orts.Simulation/Orts.Simulation.csproj b/Source/Orts.Simulation/Orts.Simulation.csproj
index 0e64474f7..dfe9acb16 100644
--- a/Source/Orts.Simulation/Orts.Simulation.csproj
+++ b/Source/Orts.Simulation/Orts.Simulation.csproj
@@ -134,6 +134,7 @@
     <Compile Include="Simulation\AIs\AIPath.cs" />
     <Compile Include="Simulation\AIs\AITrain.cs" />
     <Compile Include="Simulation\Confirmer.cs" />
+    <Compile Include="Simulation\Container.cs" />
     <Compile Include="Simulation\FuelPickup.cs" />
     <Compile Include="Simulation\Hazzard.cs" />
     <Compile Include="Simulation\LevelCrossing.cs" />
diff --git a/Source/Orts.Simulation/Simulation/AIs/AI.cs b/Source/Orts.Simulation/Simulation/AIs/AI.cs
index 39a21aa2e..3c6ca7770 100644
--- a/Source/Orts.Simulation/Simulation/AIs/AI.cs
+++ b/Source/Orts.Simulation/Simulation/AIs/AI.cs
@@ -920,8 +920,9 @@ public AITrain CreateAITrainDetail(Service_Definition sd, Traffic_Service_Defini
                 {
                     TrainCar car = RollingStock.Load(Simulator, train, wagonFilePath);
                     car.Flipped = wagon.Flip;
-                    train.Length += car.CarLengthM;
                     car.UiD = wagon.UiD;
+                    car.FreightAnimations?.Load(car as MSTSWagon, wagon.LoadDataList);
+                    train.Length += car.CarLengthM;
                     if (car is EOT)
                     {
                         train.EOT = car as EOT;
diff --git a/Source/Orts.Simulation/Simulation/Container.cs b/Source/Orts.Simulation/Simulation/Container.cs
new file mode 100644
index 000000000..cf103f026
--- /dev/null
+++ b/Source/Orts.Simulation/Simulation/Container.cs
@@ -0,0 +1,1188 @@
+﻿// COPYRIGHT 2012, 2013 by the Open Rails project.
+// 
+// This file is part of Open Rails.
+// 
+// Open Rails is free software: you can redistribute it and/or modify
+// it under the terms of the GNU General Public License as published by
+// the Free Software Foundation, either version 3 of the License, or
+// (at your option) any later version.
+// 
+// Open Rails is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+// 
+// You should have received a copy of the GNU General Public License
+// along with Open Rails.  If not, see <http://www.gnu.org/licenses/>.
+
+// This file is the responsibility of the 3D & Environment Team.
+
+using Microsoft.Xna.Framework;
+using Orts.Formats.Msts;
+using Orts.Formats.OR;
+using Orts.Parsers.Msts;
+using Orts.Simulation.RollingStocks;
+using Orts.Simulation.RollingStocks.SubSystems;
+using Orts.Common;
+using ORTS.Common;
+using ORTS.Scripting.Api;
+using System;
+using System.Collections.Generic;
+using System.Diagnostics;
+using System.IO;
+using System.Linq;
+
+namespace Orts.Simulation
+{
+
+    public enum ContainerType
+    {
+        None,
+        C20ft,
+        C40ft,
+        C40ftHC,
+        C45ft,
+        C48ft,
+        C53ft
+    }
+
+    public class ContainerList
+    {
+        public List<Container> Containers = new List<Container>();
+    }
+    public class Container
+    {
+        public enum Status
+        {
+            OnEarth,
+            Loading,
+            Unloading,
+            WaitingForLoading,
+            WaitingForUnloading
+        }
+
+        public string Name;
+        public string ShapeFileName;
+        public string BaseShapeFileFolderSlash;
+        public float MassKG = 2000;
+        public float WidthM = 2.44f;
+        public float LengthM = 12.19f;       
+        public float HeightM = 2.59f;
+        public ContainerType ContainerType = ContainerType.C40ft;
+        public bool Flipped = false;
+        public static float Length20ftM = 6.095f;
+        public static float Length40ftM = 12.19f;
+
+        public WorldPosition WorldPosition = new WorldPosition();  // current position of the container
+        public float RealRelativeYOffset = 0;
+        public float RealRelativeZOffset = 0;
+        public Vector3 IntrinsicShapeOffset;
+        public ContainerHandlingItem ContainerStation;
+        public Matrix RelativeContainerMatrix = Matrix.Identity;
+        public MSTSWagon Wagon;
+        public string LoadFilePath;
+
+
+        // generates container from FreightAnim
+ /*       public Container(Simulator simulator, string baseShapeFileFolderSlash, FreightAnimationDiscrete freightAnimDiscrete, ContainerHandlingItem containerStation )
+        {
+            Simulator = simulator;
+            ShapeFileName = freightAnimDiscrete.ShapeFileName;
+            BaseShapeFileFolderSlash = baseShapeFileFolderSlash;
+            MassKG = freightAnimDiscrete.LoadWeightKG;
+            ContainerType = freightAnimDiscrete.ContainerType;
+            switch (ContainerType)
+            {
+                case ContainerType.C20ft:
+                    LengthM = 6.1f;
+                    break;
+                case ContainerType.C40ft:
+                    LengthM = 12.19f;
+                    break;
+                case ContainerType.C40ftHC:
+                    LengthM = 12.19f;
+                    HeightM = 2.9f;
+                    break;
+                case ContainerType.C45ft:
+                    LengthM = 13.7f;
+                    break;
+                case ContainerType.C48ft:
+                    LengthM = 14.6f;
+                    break;
+                case ContainerType.C53ft:
+                    LengthM = 16.15f;
+                    break;
+                default:
+                    break;
+            }
+            WorldPosition.XNAMatrix = freightAnimDiscrete.Wagon.WorldPosition.XNAMatrix;
+            WorldPosition.TileX = freightAnimDiscrete.Wagon.WorldPosition.TileX;
+            WorldPosition.TileZ = freightAnimDiscrete.Wagon.WorldPosition.TileZ;
+            var translation = Matrix.CreateTranslation(freightAnimDiscrete.XOffset, freightAnimDiscrete.YOffset, freightAnimDiscrete.ZOffset);
+            WorldPosition.XNAMatrix = translation * WorldPosition.XNAMatrix;
+            IntrinsicShapeOffset = freightAnimDiscrete.IntrinsicShapeOffset;
+
+            ContainerStation = containerStation;
+        }*/
+
+        public Container(STFReader stf, FreightAnimationDiscrete freightAnimDiscrete)
+        {
+            Wagon = freightAnimDiscrete.Wagon;
+            BaseShapeFileFolderSlash = Path.GetDirectoryName(freightAnimDiscrete.Wagon.WagFilePath) + @"\";
+            stf.MustMatch("(");
+            stf.ParseBlock(new STFReader.TokenProcessor[]
+            {
+                new STFReader.TokenProcessor("shape", ()=>{ ShapeFileName = stf.ReadStringBlock(null); }),
+                new STFReader.TokenProcessor("intrinsicshapeoffset", ()=>
+                {
+                    IntrinsicShapeOffset = stf.ReadVector3Block(STFReader.UNITS.Distance,  new Vector3(0, 0, 0));
+                    IntrinsicShapeOffset.Z *= -1;
+                }),
+                new STFReader.TokenProcessor("containertype", ()=>
+                {
+                    var containerTypeString = stf.ReadStringBlock(null);
+                    Enum.TryParse<ContainerType>(containerTypeString, out var containerType);
+                    ContainerType = containerType;
+                    ComputeDimensions();
+                 }),
+                new STFReader.TokenProcessor("flip", ()=>{ Flipped = stf.ReadBoolBlock(true);}),
+                new STFReader.TokenProcessor("loadweight", ()=>{ MassKG = stf.ReadFloatBlock(STFReader.UNITS.Mass, 0);
+                }),
+            });
+            ComputeWorldPosition(freightAnimDiscrete);
+        }
+
+        public Container(FreightAnimationDiscrete freightAnimDiscreteCopy, FreightAnimationDiscrete freightAnimDiscrete, bool stacked = false)
+        {
+            Wagon = freightAnimDiscrete.Wagon;
+            Copy(freightAnimDiscreteCopy.Container);
+
+            WorldPosition.XNAMatrix = Wagon.WorldPosition.XNAMatrix;
+            WorldPosition.TileX = Wagon.WorldPosition.TileX;
+            WorldPosition.TileZ = Wagon.WorldPosition.TileZ;
+            var totalOffset = freightAnimDiscrete.Offset - IntrinsicShapeOffset;
+            if (stacked)
+                totalOffset.Y += freightAnimDiscreteCopy.Container.HeightM;
+            var translation = Matrix.CreateTranslation(totalOffset);
+            WorldPosition.XNAMatrix = translation * WorldPosition.XNAMatrix;
+            var invWagonMatrix = Matrix.Invert(freightAnimDiscrete.Wagon.WorldPosition.XNAMatrix);
+            RelativeContainerMatrix = Matrix.Multiply(WorldPosition.XNAMatrix, invWagonMatrix);
+        }
+
+        public Container (MSTSWagon wagon, string  loadFilePath, ContainerHandlingItem containerStation = null)
+        {
+            Wagon = wagon;
+            ContainerStation = containerStation;
+            LoadFilePath = loadFilePath;
+            if (wagon != null)
+                BaseShapeFileFolderSlash = Path.GetDirectoryName(wagon.WagFilePath) + @"\";
+            else 
+                BaseShapeFileFolderSlash = Path.GetDirectoryName(LoadFilePath) + @"\";
+
+        }
+
+        public virtual void Copy(Container containerCopy)
+        {
+            Name = containerCopy.Name;
+            BaseShapeFileFolderSlash = containerCopy.BaseShapeFileFolderSlash;
+            ShapeFileName = containerCopy.ShapeFileName;
+            IntrinsicShapeOffset = containerCopy.IntrinsicShapeOffset;
+            ContainerType = containerCopy.ContainerType;
+            ComputeDimensions();
+            Flipped = containerCopy.Flipped;
+            MassKG = containerCopy.MassKG;
+        }
+
+        public Container(BinaryReader inf, FreightAnimationDiscrete freightAnimDiscrete, ContainerHandlingItem containerStation, bool fromContainerStation, int stackLocationIndex = 0)
+        {
+            if (fromContainerStation) ContainerStation = containerStation;
+            else Wagon = freightAnimDiscrete.Wagon;
+            Name = inf.ReadString();
+            BaseShapeFileFolderSlash = inf.ReadString();
+            ShapeFileName = inf.ReadString();
+            IntrinsicShapeOffset.X = inf.ReadSingle();
+            IntrinsicShapeOffset.Y = inf.ReadSingle();
+            IntrinsicShapeOffset.Z = inf.ReadSingle();
+            ContainerType = (ContainerType)inf.ReadInt32();
+            ComputeDimensions();
+            Flipped = inf.ReadBoolean();
+            MassKG = inf.ReadSingle();
+            if (fromContainerStation)
+            {
+                // compute WorldPosition starting from offsets and position of container station
+                var containersCount = containerStation.StackLocations[stackLocationIndex].Containers.Count;
+                var mstsOffset = IntrinsicShapeOffset;
+                mstsOffset.Z *= -1;
+                var totalOffset = containerStation.StackLocations[stackLocationIndex].Position - mstsOffset;
+                totalOffset.Z += LengthM * (containerStation.StackLocations[stackLocationIndex].Flipped ? -1 : 1) / 2;
+                if (containersCount != 0)
+                for (var iPos = containersCount - 1; iPos >= 0; iPos--)
+                    totalOffset.Y += containerStation.StackLocations[stackLocationIndex].Containers[iPos].HeightM;
+                totalOffset.Z *= -1;
+                Vector3.Transform(ref totalOffset, ref containerStation.ShapePosition.XNAMatrix, out totalOffset);
+                //               WorldPosition = new WorldLocation(car.WorldPosition.TileX, car.WorldPosition.TileZ,
+                //                   totalOffset.X, totalOffset.Y, -totalOffset.Z);
+                WorldPosition.XNAMatrix = containerStation.ShapePosition.XNAMatrix;
+                WorldPosition.XNAMatrix.Translation = totalOffset;
+                WorldPosition.TileX = containerStation.ShapePosition.TileX;
+                WorldPosition.TileZ = containerStation.ShapePosition.TileZ;
+            }
+            else
+            {
+                RelativeContainerMatrix = ORTSMath.RestoreMatrix(inf);
+                WorldPosition.XNAMatrix = Matrix.Multiply(RelativeContainerMatrix, Wagon.WorldPosition.XNAMatrix);
+                WorldPosition.TileX = Wagon.WorldPosition.TileX;
+                WorldPosition.TileZ = Wagon.WorldPosition.TileZ;
+            }
+        }
+
+        private void ComputeDimensions()
+        {
+            switch (ContainerType)
+            {
+                case ContainerType.C20ft:
+                    LengthM = 6.095f;
+                    break;
+                case ContainerType.C40ft:
+                    LengthM = 12.19f;
+                    break;
+                case ContainerType.C40ftHC:
+                    LengthM = 12.19f;
+                    HeightM = 2.9f;
+                    break;
+                case ContainerType.C45ft:
+                    LengthM = 13.7f;
+                    break;
+                case ContainerType.C48ft:
+                    LengthM = 14.6f;
+                    break;
+                case ContainerType.C53ft:
+                    LengthM = 16.15f;
+                    break;
+                default:
+                    break;
+            }
+        }
+
+        public void ComputeContainerStationContainerPosition (int stackLocationIndex, int loadPositionVertical)
+        {
+            // compute WorldPosition starting from offsets and position of container station
+            var mstsOffset = IntrinsicShapeOffset;
+            mstsOffset.Z *= -1;
+            var stackLocation = ContainerStation.StackLocations[stackLocationIndex];
+            var totalOffset = stackLocation.Position - mstsOffset;
+            totalOffset.Z += LengthM * (stackLocation.Flipped ? -1 : 1) / 2;
+            if (stackLocation.Containers != null && stackLocation.Containers.Count != 0)
+                for (var iPos = (stackLocation.Containers.Count - 1); iPos >= 0; iPos--)
+                    totalOffset.Y += stackLocation.Containers[iPos].HeightM;
+            totalOffset.Z *= -1;
+            Vector3.Transform(ref totalOffset, ref  ContainerStation.ShapePosition.XNAMatrix, out totalOffset);
+            //               WorldPosition = new WorldLocation(car.WorldPosition.TileX, car.WorldPosition.TileZ,
+            //                   totalOffset.X, totalOffset.Y, -totalOffset.Z);
+            WorldPosition.XNAMatrix = ContainerStation.ShapePosition.XNAMatrix;
+            WorldPosition.XNAMatrix.Translation = totalOffset;
+            WorldPosition.TileX = ContainerStation.ShapePosition.TileX;
+            WorldPosition.TileZ = ContainerStation.ShapePosition.TileZ;
+        }
+
+        public void Update()
+        {
+
+        }
+
+        public void Save(BinaryWriter outf, bool fromContainerStation = false)
+        {
+            outf.Write(Name);
+            outf.Write(BaseShapeFileFolderSlash);
+            outf.Write(ShapeFileName);
+            outf.Write(IntrinsicShapeOffset.X);
+            outf.Write(IntrinsicShapeOffset.Y);
+            outf.Write(IntrinsicShapeOffset.Z);
+            outf.Write((int)ContainerType);
+            outf.Write(Flipped);
+            outf.Write(MassKG);
+            if (fromContainerStation)
+            {
+
+            }
+            else
+                ORTSMath.SaveMatrix(outf, RelativeContainerMatrix);
+        }
+
+        public void LoadFromContainerFile(string loadFilePath)
+        {
+            var containerFile = new ContainerFile(loadFilePath);
+            var containerParameters = containerFile.ContainerParameters;
+            Name = containerParameters.Name;
+            ShapeFileName = containerParameters.ShapeFileName;
+            Enum.TryParse(containerParameters.ContainerType, out ContainerType containerType);
+            ContainerType = containerType;
+            ComputeDimensions();
+            IntrinsicShapeOffset = containerParameters.IntrinsicShapeOffset;
+            IntrinsicShapeOffset.Z *= -1;
+        }
+
+        public void ComputeWorldPosition (FreightAnimationDiscrete freightAnimDiscrete)
+         {
+            WorldPosition.XNAMatrix = freightAnimDiscrete.Wagon.WorldPosition.XNAMatrix;
+            WorldPosition.TileX = freightAnimDiscrete.Wagon.WorldPosition.TileX;
+            WorldPosition.TileZ = freightAnimDiscrete.Wagon.WorldPosition.TileZ;
+            var offset = freightAnimDiscrete.Offset;
+//            if (freightAnimDiscrete.Container != null) offset.Y += freightAnimDiscrete.Container.HeightM;
+            var translation = Matrix.CreateTranslation(offset - IntrinsicShapeOffset);
+            WorldPosition.XNAMatrix = translation * WorldPosition.XNAMatrix;
+            var invWagonMatrix = Matrix.Invert(freightAnimDiscrete.Wagon.WorldPosition.XNAMatrix);
+            RelativeContainerMatrix = Matrix.Multiply(WorldPosition.XNAMatrix, invWagonMatrix);
+        }
+    }
+
+    public class ContainerManager
+    {
+        readonly Simulator Simulator;
+        public Dictionary<int, ContainerHandlingItem> ContainerHandlingItems;
+        public List<Container> Containers;
+        public static Dictionary<string, Container> LoadedContainers = new Dictionary<string, Container>();
+
+        public ContainerManager(Simulator simulator)
+        {
+            Simulator = simulator;
+            ContainerHandlingItems = new Dictionary<int, ContainerHandlingItem>();
+            Containers = new List<Container>();
+        }
+
+/*        static Dictionary<int, FuelPickupItem> GetContainerHandlingItemsFromDB(TrackNode[] trackNodes, TrItem[] trItemTable)
+        {
+            return (from trackNode in trackNodes
+                    where trackNode != null && trackNode.TrVectorNode != null && trackNode.TrVectorNode.NoItemRefs > 0
+                    from itemRef in trackNode.TrVectorNode.TrItemRefs.Distinct()
+                    where trItemTable[itemRef] != null && trItemTable[itemRef].ItemType == TrItem.trItemType.trPICKUP
+                    select new KeyValuePair<int, ContainerHandlingItem>(itemRef, new ContainerHandlingItem(trackNode, trItemTable[itemRef])))
+                    .ToDictionary(_ => _.Key, _ => _.Value);
+        }*/
+
+        public ContainerHandlingItem CreateContainerStation(WorldPosition shapePosition, IEnumerable<int> trackIDs, PickupObj thisWorldObj)
+        {
+            var trackItem = trackIDs.Select(id => Simulator.FuelManager.FuelPickupItems[id]).First();
+            return new ContainerHandlingItem(Simulator, shapePosition, trackItem, thisWorldObj);
+        }
+
+        public void Save(BinaryWriter outf)
+        {
+            foreach (var containerStation in ContainerHandlingItems.Values)
+                containerStation.Save(outf);
+        }
+
+        public void Restore(BinaryReader inf)
+        {
+            foreach (var containerStation in ContainerHandlingItems.Values)
+                containerStation.Restore(inf);
+        }
+
+        public void Update()
+        {
+            foreach (var containerStation in ContainerHandlingItems.Values)
+                containerStation.Update();
+        }
+
+
+    } 
+
+    public class ContainerHandlingItem : FuelPickupItem
+    {
+        public Simulator Simulator;
+
+
+        public List<Container> Containers = new List<Container>();
+        public WorldPosition ShapePosition;
+        public int MaxStackedContainers;
+        public StackLocation[] StackLocations;
+        public float StackLocationsLength = 12.19f;
+        public int StackLocationsCount;
+ //       public int[] AllocatedContainerIndices;
+        public float PickingSurfaceYOffset;
+        public Vector3 PickingSurfaceRelativeTopStartPosition;
+        public float TargetX;
+        public float TargetY;
+        public float TargetZ;
+        public float TargetGrabber01;
+        public float TargetGrabber02;
+        public float ActualX;
+        public float ActualY;
+        public float ActualZ;
+        public float ActualGrabber01;
+        public float ActualGrabber02;
+        public bool MoveX;
+        public bool MoveY;
+        public bool MoveZ;
+        public bool MoveGrabber;
+        public float Grabber01Offset;
+        private int freePositionVertical;
+        private int positionHorizontal;
+        public Container HandledContainer;
+        public Matrix RelativeContainerPosition;
+        public Matrix InitialInvAnimationXNAMatrix = Matrix.Identity;
+        public Matrix AnimationXNAMatrix = Matrix.Identity;
+        private float GeneralVerticalOffset;
+        public float MinZSpan;
+        public float Grabber01Max;
+        public float Grabber02Max;
+        public float MaxGrabberSpan;
+        private FreightAnimationDiscrete LinkedFreightAnimation;
+        public float LoadingEndDelayS { get; protected set; } = 3f;
+        public float UnloadingStartDelayS { get; protected set; } = 2f;
+        protected Timer DelayTimer;
+
+        private bool messageWritten = false;
+        private bool ContainerFlipped = false;
+        private bool WagonFlipped = false;
+        private int SelectedStackLocationIndex = -1;
+
+        public enum ContainerStationStatus
+        {
+            Idle,
+            LoadRaiseToPick,
+            LoadHorizontallyMoveToPick,
+            LoadLowerToPick,
+            LoadWaitingForPick,
+            LoadRaiseToLayOnWagon,
+            LoadHorizontallyMoveToLayOnWagon,
+            LoadLowerToLayOnWagon,
+            LoadWaitingForLayingOnWagon,
+            UnloadRaiseToPick,
+            UnloadHorizontallyMoveToPick,
+            UnloadLowerToPick,
+            UnloadWaitingForPick,
+            UnloadRaiseToLayOnEarth,
+            UnloadHorizontallyMoveToLayOnEarth,
+            UnloadLowerToLayOnEarth,
+            UnloadWaitingForLayingOnEarth,
+            RaiseToIdle,
+        }
+
+        public ContainerStationStatus Status = ContainerStationStatus.Idle;
+        public bool ContainerAttached;
+        public double TimerStartTime { get; set; }
+
+        public ContainerHandlingItem(Simulator simulator, TrackNode trackNode, TrItem trItem)
+            : base(trackNode, trItem)
+        {
+
+        }
+
+        public ContainerHandlingItem(Simulator simulator, WorldPosition shapePosition, FuelPickupItem item, PickupObj thisWorldObj)
+        {
+            Simulator = simulator;
+            ShapePosition = shapePosition;
+            Location = item.Location;
+            TrackNode = item.TrackNode;
+            MaxStackedContainers = thisWorldObj.MaxStackedContainers;
+            StackLocationsLength = thisWorldObj.StackLocationsLength;
+            StackLocationsCount = thisWorldObj.StackLocations.Locations.Length;
+            var stackLocationsCount = StackLocationsCount;
+            if (StackLocationsLength + 0.01f > Container.Length40ftM)  // locations can be double if loaded with 20ft containers
+            {
+                StackLocationsCount *= 2;
+            }
+            StackLocations = new StackLocation[StackLocationsCount];
+            int i = 0;
+            foreach (var worldStackLocation in thisWorldObj.StackLocations.Locations)
+            {
+                var stackLocation = new StackLocation(worldStackLocation);
+                StackLocations[i] = stackLocation;
+                if (StackLocationsLength + 0.01f > Container.Length40ftM)
+                {
+                    StackLocations[i + stackLocationsCount] = new StackLocation(stackLocation);
+                    StackLocations[i + stackLocationsCount].Usable = false;
+                }
+                i++;
+            }
+            PickingSurfaceYOffset = thisWorldObj.PickingSurfaceYOffset;
+            PickingSurfaceRelativeTopStartPosition = thisWorldObj.PickingSurfaceRelativeTopStartPosition;
+            MaxGrabberSpan = thisWorldObj.MaxGrabberSpan;
+            DelayTimer = new Timer(this);
+            // preload containers if not at restore time
+            if (Simulator.LoadStationsOccupancyFile != null)
+                PreloadContainerStation(thisWorldObj);
+        }
+
+        public void Save(BinaryWriter outf)
+        {
+            outf.Write((int)Status);
+            outf.Write(GeneralVerticalOffset);
+            ORTSMath.SaveMatrix(outf, RelativeContainerPosition);
+            int zero = 0;
+            foreach (var stackLocation in StackLocations)
+            {
+                outf.Write(stackLocation.Usable);
+                if (stackLocation.Containers == null || stackLocation.Containers.Count == 0)
+                    outf.Write(zero);
+                else
+                {
+                    outf.Write(stackLocation.Containers.Count);
+                    foreach (var container in stackLocation.Containers)
+                        container.Save(outf, fromContainerStation: true);
+                }
+            }
+        }
+
+        public void Restore(BinaryReader inf)
+        {
+            var status = (ContainerStationStatus)inf.ReadInt32();
+            // in general start with preceding state
+            switch (status)
+            {
+                case ContainerStationStatus.Idle:
+                    Status = status;
+                    break;
+                 default:
+                    Status = ContainerStationStatus.Idle;
+                    break;
+            }
+            GeneralVerticalOffset = inf.ReadSingle();
+            RelativeContainerPosition = ORTSMath.RestoreMatrix(inf);
+            for (int stackLocationIndex = 0; stackLocationIndex < StackLocationsCount; stackLocationIndex++)
+            {
+                StackLocations[stackLocationIndex].Usable = inf.ReadBoolean();
+                var nContainer = inf.ReadInt32();
+                if (nContainer > 0)
+                {
+                    StackLocations[stackLocationIndex].Containers = new List<Container>();
+                    for (int i = 0; i < nContainer; i++)
+                    {
+                        var container = new Container(inf, null, this, true, stackLocationIndex);
+                        StackLocations[stackLocationIndex].Containers.Add(container);
+                        Containers.Add(container);
+                        Simulator.ContainerManager.Containers.Add(container);
+                    }
+                }
+            }
+        }
+
+        public bool Refill()
+        {
+            while (MSTSWagon.RefillProcess.OkToRefill)
+            {
+                return true;
+            }
+            if (!MSTSWagon.RefillProcess.OkToRefill)
+                return false;
+            return false;
+        }
+
+        public void PreloadContainerStation(PickupObj thisWorldObj)
+        {
+            // Search if ContainerStation present in file
+            foreach (var loadStationOccupancy in Simulator.LoadStationsOccupancyFile.LoadStationsOccupancy)
+            {
+                var tileX = int.Parse(loadStationOccupancy.LoadStatID.wfile.Substring(1, 7));
+                var tileZ = int.Parse(loadStationOccupancy.LoadStatID.wfile.Substring(8, 7));
+                if (tileX == Location.TileX && tileZ == Location.TileZ  && loadStationOccupancy.LoadStatID.UiD == thisWorldObj.UID)
+                {
+                    foreach (var loadDataEntry in (loadStationOccupancy as ContainerStationOccupancy).LoadData)
+                    {
+                        string loadDataFolder = Simulator.BasePath + @"\trains\trainset\" + loadDataEntry.FolderName;
+                        string loadFilePath = loadDataFolder + @"\" + loadDataEntry.FileName + ".loa";
+                        if (!File.Exists(loadFilePath))
+                        {
+                            Trace.TraceWarning($"Ignored missing load {loadFilePath}");
+                            continue;
+                        }
+                        Preload(loadFilePath, loadDataEntry.StackLocation);
+                    }
+                    break;
+                }
+            }
+         }
+
+        public void Preload(string loadFilePath, int stackLocationIndex)
+        {
+            Container container;
+            container = new Container(null, loadFilePath, this);
+            if (ContainerManager.LoadedContainers.ContainsKey(loadFilePath))
+            {
+                container.Copy(ContainerManager.LoadedContainers[loadFilePath]);
+            }
+            else
+            {
+                container.LoadFromContainerFile(loadFilePath);
+                ContainerManager.LoadedContainers.Add(loadFilePath, container);
+            }
+            var stackLocation = StackLocations[stackLocationIndex];
+            if (stackLocation.Containers != null && stackLocation.Containers.Count >= stackLocation.MaxStackedContainers)
+                Trace.TraceWarning("Stack Location {0} is full, can't lay down container", stackLocationIndex);
+            else if (stackLocation.Containers != null && stackLocation.Containers[0].LengthM != container.LengthM)
+                Trace.TraceWarning("Stack Location {0} is occupied with containers of different length", stackLocationIndex);
+            else if (stackLocation.Containers != null && stackLocation.Length + 0.01f < container.LengthM)
+                Trace.TraceWarning("Stack Location {0} is too short for container {1}", stackLocationIndex, container.Name);
+            if (stackLocation.Containers == null) stackLocation.Containers = new List<Container>();
+            container.ComputeContainerStationContainerPosition(stackLocationIndex, stackLocation.Containers.Count);
+            stackLocation.Containers.Add(container);
+            Containers.Add(container);
+            Simulator.ContainerManager.Containers.Add(container);
+            if (container.ContainerType != ContainerType.C20ft)
+                StackLocations[stackLocationIndex + StackLocations.Length / 2].Usable = false;
+        }
+
+        public void Update()
+        {
+            var subMissionTerminated = false;
+            if (!MoveX && !MoveY && !MoveZ)
+                subMissionTerminated = true;
+
+            switch (Status)
+            {
+                case ContainerStationStatus.Idle:
+                    break;
+                case ContainerStationStatus.LoadRaiseToPick:
+                    if (subMissionTerminated)
+                    {
+                        MoveY = false;
+                        Status = ContainerStationStatus.LoadHorizontallyMoveToPick;
+                        TargetX = StackLocations[SelectedStackLocationIndex].Position.X;
+                        TargetZ = StackLocations[SelectedStackLocationIndex].Position.Z + StackLocations[SelectedStackLocationIndex].Containers[StackLocations[SelectedStackLocationIndex].Containers.Count - 1].LengthM * (StackLocations[SelectedStackLocationIndex].Flipped ? -1 : 1) / 2;
+ //                       TargetX = PickingSurfaceRelativeTopStartPosition.X;
+ //                       TargetZ = PickingSurfaceRelativeTopStartPosition.Z - RelativeContainerPosition.Translation.Z + HandledContainer.IntrinsicShapeZOffset;
+ //                       RelativeContainerPosition.M43 = HandledContainer.IntrinsicShapeZOffset;
+                        MoveX = true;
+                        MoveZ = true;
+                    }
+                    break;
+                case ContainerStationStatus.LoadHorizontallyMoveToPick:
+                    if (subMissionTerminated && !MoveGrabber)
+                    {
+                        MoveX = false;
+                        MoveZ = false;
+                        MoveGrabber = false;
+                        Status = ContainerStationStatus.LoadLowerToPick;
+                        //                       TargetY = HandledContainer.HeightM + HandledContainer.IntrinsicShapeYOffset - PickingSurfaceYOffset;
+                        TargetY = ComputeTargetYBase(StackLocations[SelectedStackLocationIndex].Containers.Count - 1, SelectedStackLocationIndex) - PickingSurfaceYOffset;
+                        RelativeContainerPosition.M42 = - TargetY + StackLocations[SelectedStackLocationIndex].Containers[StackLocations[SelectedStackLocationIndex].Containers.Count -1].WorldPosition.XNAMatrix.M42 + InitialInvAnimationXNAMatrix.M42;
+                        MoveY = true;
+                    }
+                    break;
+                case ContainerStationStatus.LoadLowerToPick:
+                    if (subMissionTerminated)
+                    {
+                        MoveY = false;
+                        if (DelayTimer == null)
+                            DelayTimer = new Timer(this);
+                        DelayTimer.Setup(UnloadingStartDelayS);
+                        DelayTimer.Start();
+                        Status = ContainerStationStatus.LoadWaitingForPick;
+                    }
+                    break;
+                case ContainerStationStatus.LoadWaitingForPick:
+                    if (DelayTimer.Triggered)
+                    {
+                        DelayTimer.Stop();
+                        ContainerAttached = true;
+                        TargetY = PickingSurfaceRelativeTopStartPosition.Y;
+                        MoveY = true;
+                        Status = ContainerStationStatus.LoadRaiseToLayOnWagon;
+                        messageWritten = false;
+                    }
+                    break;
+                case ContainerStationStatus.LoadRaiseToLayOnWagon:
+                    if (subMissionTerminated || messageWritten)
+                    {
+                        if (Math.Abs(LinkedFreightAnimation.Wagon.SpeedMpS) < 0.01f)
+                        {
+                            MoveY = false;
+                            TargetX = PickingSurfaceRelativeTopStartPosition.X;
+                            WorldPosition animWorldPosition = new WorldPosition(LinkedFreightAnimation.Wagon.WorldPosition);
+            //                var translation = Matrix.CreateTranslation(LinkedFreightAnimation.Offset);
+            //                animWorldPosition.XNAMatrix = translation * animWorldPosition.XNAMatrix;
+                            var relativeAnimationPosition = Matrix.Multiply(animWorldPosition.XNAMatrix, InitialInvAnimationXNAMatrix);
+                            // compute where within the free space to lay down the container
+                            var freightAnims = LinkedFreightAnimation.FreightAnimations;
+                            var offsetZ = LinkedFreightAnimation.Offset.Z;
+                            if (Math.Abs(LinkedFreightAnimation.LoadingAreaLength - HandledContainer.LengthM) > 0.01)
+                            {
+                                var loadedFreightAnim = new FreightAnimationDiscrete(LinkedFreightAnimation, LinkedFreightAnimation.FreightAnimations);
+                                var loadedIntakePoint = loadedFreightAnim.LinkedIntakePoint;
+                                if (!(HandledContainer.ContainerType == ContainerType.C20ft && LinkedFreightAnimation.LoadPosition == LoadPosition.Center &&
+                                    LinkedFreightAnimation.LoadingAreaLength + 0.01f >= 12.19))
+                                {
+                                    if (LinkedFreightAnimation.LoadingAreaLength == freightAnims.LoadingAreaLength && !freightAnims.DoubleStacker)
+                                    {
+                                        loadedFreightAnim.LoadPosition = LoadPosition.Rear;
+                                        loadedFreightAnim.Offset.Z = freightAnims.Offset.Z + (freightAnims.LoadingAreaLength - HandledContainer.LengthM) / 2;
+                                    }
+                                    else if (loadedFreightAnim.LoadPosition != LoadPosition.Center && loadedFreightAnim.LoadPosition != LoadPosition.Above)
+                                    {
+                                        switch (loadedFreightAnim.LoadPosition)
+                                        {
+                                            case LoadPosition.Front:
+                                                loadedFreightAnim.Offset.Z = freightAnims.Offset.Z -(freightAnims.LoadingAreaLength - HandledContainer.LengthM) / 2;
+                                                break;
+                                            case LoadPosition.Rear:
+                                                loadedFreightAnim.Offset.Z = freightAnims.Offset.Z + (freightAnims.LoadingAreaLength - HandledContainer.LengthM) / 2;
+                                                break;
+                                            case LoadPosition.CenterFront:
+                                                loadedFreightAnim.Offset.Z = freightAnims.Offset.Z - HandledContainer.LengthM / 2;
+                                                break;
+                                            case LoadPosition.CenterRear:
+                                                loadedFreightAnim.Offset.Z = freightAnims.Offset.Z + HandledContainer.LengthM / 2;
+                                                break;
+                                            default:
+                                                break;
+                                        }
+                                    }         
+                                }
+                                else
+                                // don't lay down a short container in the middle of the wagon
+                                {
+                                    if (LinkedFreightAnimation.LoadingAreaLength == freightAnims.LoadingAreaLength && !freightAnims.DoubleStacker)
+                                    {
+                                        loadedFreightAnim.LoadPosition = LoadPosition.Rear;
+                                        loadedFreightAnim.Offset.Z = freightAnims.Offset.Z + (freightAnims.LoadingAreaLength - HandledContainer.LengthM) / 2;
+                                    }
+                                    else
+                                    {
+                                        loadedFreightAnim.LoadPosition = LoadPosition.CenterFront;
+                                        loadedFreightAnim.Offset.Z = freightAnims.Offset.Z - HandledContainer.LengthM / 2;
+                                    }
+                                }
+                                loadedFreightAnim.LoadingAreaLength = HandledContainer.LengthM;
+                                loadedIntakePoint.OffsetM = -loadedFreightAnim.Offset.Z;
+                                freightAnims.Animations.Add(loadedFreightAnim);
+                                loadedFreightAnim.Container = HandledContainer;
+                                freightAnims.UpdateEmptyFreightAnims(HandledContainer.LengthM);
+                                // Too early to have container on wagon
+                                loadedFreightAnim.Container = null;
+                                LinkedFreightAnimation = loadedFreightAnim;
+                            }
+                            else
+                            {
+                                freightAnims.EmptyAnimations.Remove(LinkedFreightAnimation);
+                                freightAnims.Animations.Add(LinkedFreightAnimation);
+                                (freightAnims.Animations.Last() as FreightAnimationDiscrete).Container = HandledContainer;
+                                freightAnims.EmptyAbove();
+                                (freightAnims.Animations.Last() as FreightAnimationDiscrete).Container = null;
+
+
+                            }
+                            TargetZ = PickingSurfaceRelativeTopStartPosition.Z - relativeAnimationPosition.Translation.Z - LinkedFreightAnimation.Offset.Z * 
+                                (WagonFlipped ? -1 : 1);
+ /*                           if (TargetZ < PickingSurfaceRelativeTopStartPosition.Z)
+                            {
+                                if (!messageWritten)
+                                {
+                                    Simulator.Confirmer.Message(ConfirmLevel.Information, Simulator.Catalog.GetStringFmt("Wagon out of range: move wagon towards crane by {0} metres",
+                                        PickingSurfaceRelativeTopStartPosition.Z - TargetZ));
+                                    messageWritten = true;
+                                }
+                            }
+                            else*/
+                            {
+                                MoveX = MoveZ = true;
+                                Status = ContainerStationStatus.LoadHorizontallyMoveToLayOnWagon;
+                            }
+                        }
+                    }
+                    break;
+                case ContainerStationStatus.LoadHorizontallyMoveToLayOnWagon:
+                    if (subMissionTerminated)
+                    {
+                        MoveX = MoveZ = false;
+                        TargetY = HandledContainer.HeightM + LinkedFreightAnimation.Wagon.WorldPosition.XNAMatrix.M42
+                            + LinkedFreightAnimation.Offset.Y - ShapePosition.XNAMatrix.M42 - PickingSurfaceYOffset;
+                        if (LinkedFreightAnimation.LoadPosition == LoadPosition.Above)
+                        {
+                            var addHeight = 0.0f;
+                            foreach (var freightAnim in LinkedFreightAnimation.FreightAnimations.Animations)
+                            {
+                                if (freightAnim  is FreightAnimationDiscrete discreteFreightAnim && discreteFreightAnim.LoadPosition != LoadPosition.Above)
+                                {
+                                    addHeight = discreteFreightAnim.Container.HeightM;
+                                    break;
+                                }
+                            }
+                            TargetY += addHeight;
+                        }
+                        MoveY = true;
+                        Status = ContainerStationStatus.LoadLowerToLayOnWagon;
+                    }
+                    break;
+                case ContainerStationStatus.LoadLowerToLayOnWagon:
+                    if (subMissionTerminated)
+                    {
+                        MoveY = false;
+                        DelayTimer = new Timer(this);
+                        DelayTimer.Setup(LoadingEndDelayS);
+                        DelayTimer.Start();
+                        Status = ContainerStationStatus.LoadWaitingForLayingOnWagon;
+                        var invertedWagonMatrix = Matrix.Invert(LinkedFreightAnimation.Wagon.WorldPosition.XNAMatrix);
+                        var freightAnim = LinkedFreightAnimation.Wagon.FreightAnimations.Animations.Last() as FreightAnimationDiscrete;
+                        freightAnim.Container = HandledContainer;
+                        freightAnim.Container.Wagon = LinkedFreightAnimation.Wagon;
+                        freightAnim.Container.RelativeContainerMatrix = Matrix.Multiply(LinkedFreightAnimation.Container.WorldPosition.XNAMatrix, invertedWagonMatrix);
+                        Containers.Remove(HandledContainer);
+                        StackLocations[SelectedStackLocationIndex].Containers.Remove(HandledContainer);
+                        if (HandledContainer.ContainerType == ContainerType.C20ft && StackLocations[SelectedStackLocationIndex].Containers.Count == 0 &&
+                            StackLocations.Length + 0.01f > Container.Length40ftM)
+                        {
+                            if (SelectedStackLocationIndex < StackLocationsCount / 2 &&
+                            (StackLocations[SelectedStackLocationIndex + StackLocationsCount / 2].Containers == null || StackLocations[SelectedStackLocationIndex + StackLocationsCount / 2].Containers.Count == 0))
+                                StackLocations[SelectedStackLocationIndex + StackLocationsCount / 2].Usable = false;
+                            else if (SelectedStackLocationIndex >= StackLocationsCount / 2 &&
+                                (StackLocations[SelectedStackLocationIndex - StackLocationsCount / 2].Containers == null || StackLocations[SelectedStackLocationIndex - StackLocationsCount / 2].Containers.Count == 0))
+                                StackLocations[SelectedStackLocationIndex].Usable = false;
+                        }
+                        HandledContainer.Wagon.UpdateLoadPhysics();
+                        HandledContainer = null;
+                        ContainerAttached = false;
+                        freightAnim.Loaded = true;
+                    }
+                    break;
+                case ContainerStationStatus.LoadWaitingForLayingOnWagon:
+                    if (DelayTimer.Triggered)
+                    {
+                        DelayTimer.Stop();
+                        TargetY = PickingSurfaceRelativeTopStartPosition.Y;
+                        MoveY = true;
+                        Status = ContainerStationStatus.RaiseToIdle;
+                        messageWritten = false;
+                    }
+                    break;
+                case ContainerStationStatus.UnloadRaiseToPick:
+                    if (subMissionTerminated || messageWritten)
+                    {
+                        if (Math.Abs(LinkedFreightAnimation.Wagon.SpeedMpS) < 0.01f)
+                        {
+                            MoveY = false;
+                            HandledContainer = LinkedFreightAnimation.Container;
+                            TargetX = PickingSurfaceRelativeTopStartPosition.X;
+                            TargetZ = PickingSurfaceRelativeTopStartPosition.Z - RelativeContainerPosition.Translation.Z - HandledContainer.IntrinsicShapeOffset.Z * 
+                            (ContainerFlipped ? -1 : 1);                              
+                            Status = ContainerStationStatus.UnloadHorizontallyMoveToPick;
+                            RelativeContainerPosition.M43 = HandledContainer.IntrinsicShapeOffset.Z * (ContainerFlipped ? 1 : -1);
+                            MoveX = true;
+                            MoveZ = true;
+                            HandledContainer.ContainerStation = this;
+                            Containers.Add(HandledContainer);
+                        }
+                    }
+                    break;
+                case ContainerStationStatus.UnloadHorizontallyMoveToPick:
+                    if (subMissionTerminated && !MoveGrabber)
+                    {
+                        MoveX = false;
+                        MoveZ = false;
+                        MoveGrabber = false;
+                        Status = ContainerStationStatus.UnloadLowerToPick;
+                        TargetY = - PickingSurfaceYOffset + HandledContainer.HeightM + HandledContainer.IntrinsicShapeOffset.Y + GeneralVerticalOffset - PickingSurfaceYOffset;
+                        RelativeContainerPosition.M42 = PickingSurfaceYOffset - (HandledContainer.HeightM + HandledContainer.IntrinsicShapeOffset.Y);
+                        MoveY = true;
+                    }
+                    break;
+                case ContainerStationStatus.UnloadLowerToPick:
+                    if (subMissionTerminated)
+                    {
+                        MoveY = false;
+                        if (DelayTimer == null)
+                            DelayTimer = new Timer(this);
+                        DelayTimer.Setup(UnloadingStartDelayS);
+                        DelayTimer.Start();
+                        Status = ContainerStationStatus.UnloadWaitingForPick;
+                    }
+                    break;
+                case ContainerStationStatus.UnloadWaitingForPick:
+                    if (DelayTimer.Triggered)
+                    {
+                        LinkedFreightAnimation.Loaded = false;
+                        LinkedFreightAnimation.Container = null;
+                        var freightAnims = HandledContainer.Wagon.FreightAnimations;
+                        if (LinkedFreightAnimation.LoadPosition == LoadPosition.Above)
+                        {
+                            LinkedFreightAnimation.Offset.Y = freightAnims.Offset.Y;
+                            LinkedFreightAnimation.AboveLoadingAreaLength = freightAnims.AboveLoadingAreaLength;
+                            freightAnims.EmptyAnimations.Add(LinkedFreightAnimation);
+                        }
+                        else
+                        {
+                            var discreteAnimCount = 0;
+                            if (freightAnims.EmptyAnimations.Count > 0 && freightAnims.EmptyAnimations.Last().LoadPosition == LoadPosition.Above)
+                            {
+                                HandledContainer.Wagon.IntakePointList.Remove(freightAnims.EmptyAnimations.Last().LinkedIntakePoint);
+                                freightAnims.EmptyAnimations.Remove(freightAnims.EmptyAnimations.Last());
+                            }
+                            foreach (var freightAnim in HandledContainer.Wagon.FreightAnimations.Animations)
+                            {
+                                if (freightAnim is FreightAnimationDiscrete discreteFreightAnim)
+                                {
+                                    if (discreteFreightAnim.LoadPosition != LoadPosition.Above)
+                                        discreteAnimCount++;
+                                }
+                            }
+                            if (discreteAnimCount == 1)
+                            {
+                                foreach (var emptyAnim in freightAnims.EmptyAnimations)
+                                {
+                                    HandledContainer.Wagon.IntakePointList.Remove(emptyAnim.LinkedIntakePoint);
+                                }
+                                freightAnims.EmptyAnimations.Clear();
+                                freightAnims.EmptyAnimations.Add(new FreightAnimationDiscrete(freightAnims, LoadPosition.Center));
+                                HandledContainer.Wagon.IntakePointList.Remove(LinkedFreightAnimation.LinkedIntakePoint);
+                            }
+                            else
+                            {
+                                freightAnims.EmptyAnimations.Add(LinkedFreightAnimation);
+                                LinkedFreightAnimation.Container = null;
+                                LinkedFreightAnimation.Loaded = false;
+                                freightAnims.MergeEmptyAnims();
+                            }
+
+                        }
+                        freightAnims.Animations.Remove(LinkedFreightAnimation);
+                        HandledContainer.Wagon.UpdateLoadPhysics();
+                        LinkedFreightAnimation = null;
+                        DelayTimer.Stop();
+                        ContainerAttached = true;
+                        TargetY = PickingSurfaceRelativeTopStartPosition.Y;
+                        MoveY = true;
+                        Status = ContainerStationStatus.UnloadRaiseToLayOnEarth;
+                    }
+                    break;
+                case ContainerStationStatus.UnloadRaiseToLayOnEarth:
+                    if (subMissionTerminated)
+                    {
+                        MoveY = false;
+                        // Search first free position
+                        SelectUnloadPosition();
+                        MoveX = MoveZ = true;
+                        Status = ContainerStationStatus.UnloadHorizontallyMoveToLayOnEarth;
+                    }
+                    break;
+                case ContainerStationStatus.UnloadHorizontallyMoveToLayOnEarth:
+                    if (subMissionTerminated)
+                    {
+                        MoveX = MoveZ = false;
+                        StackLocations[positionHorizontal].Containers.Add(HandledContainer);
+                        TargetY = ComputeTargetYBase(freePositionVertical, positionHorizontal) - PickingSurfaceYOffset;
+                        MoveY = true;
+                        Status = ContainerStationStatus.UnloadLowerToLayOnEarth;
+                    }
+                    break;
+                case ContainerStationStatus.UnloadLowerToLayOnEarth:
+                    if (subMissionTerminated)
+                    {
+                        MoveY = false;
+                        DelayTimer.Setup(LoadingEndDelayS);
+                        DelayTimer.Start();
+                        Status = ContainerStationStatus.UnloadWaitingForLayingOnEarth;
+                    }
+                    break;
+                case ContainerStationStatus.UnloadWaitingForLayingOnEarth:
+                    if (DelayTimer.Triggered)
+                    {
+                        DelayTimer.Stop();
+                        RelativeContainerPosition.M43 = 0;
+                        ContainerAttached = false;
+                        TargetY = PickingSurfaceRelativeTopStartPosition.Y;
+                        MoveY = true;
+                        Status = ContainerStationStatus.RaiseToIdle;
+                    }
+                    break;
+                case ContainerStationStatus.RaiseToIdle:
+                    if (subMissionTerminated)
+                    {
+                        MoveY = false;
+                        Status = ContainerStationStatus.Idle;
+                        MSTSWagon.RefillProcess.OkToRefill = false;
+                    }
+                    break;
+                default:
+                    break;
+            }
+        }
+
+        public void PrepareForUnload(FreightAnimationDiscrete linkedFreightAnimation)
+        {
+            LinkedFreightAnimation = linkedFreightAnimation;
+            RelativeContainerPosition = new Matrix();
+            LinkedFreightAnimation.Wagon.WorldPosition.NormalizeTo(ShapePosition.TileX, ShapePosition.TileZ);
+            var container = LinkedFreightAnimation.Container;
+            RelativeContainerPosition = Matrix.Multiply(container.WorldPosition.XNAMatrix, InitialInvAnimationXNAMatrix);
+            RelativeContainerPosition.M42 += PickingSurfaceYOffset;
+            RelativeContainerPosition.M41 -= PickingSurfaceRelativeTopStartPosition.X;
+            GeneralVerticalOffset = RelativeContainerPosition.M42;
+//            RelativeContainerPosition.Translation += LinkedFreightAnimation.Offset;
+            ContainerFlipped = (Math.Abs(InitialInvAnimationXNAMatrix.M11 - container.WorldPosition.XNAMatrix.M11) < 0.1f ? false : true);
+            Status = ContainerStationStatus.UnloadRaiseToPick;
+            TargetY = PickingSurfaceRelativeTopStartPosition.Y;
+            MoveY = true;
+            SetGrabbers(container);
+        }
+
+        public void PrepareForLoad(FreightAnimationDiscrete linkedFreightAnimation)
+        {
+            //           var invAnimationXNAMatrix = Matrix.Invert(InitialAnimationXNAMatrix);
+            //           RelativeContainerPosition = new Matrix();
+            //           RelativeContainerPosition = Matrix.Multiply(Containers.Last().WorldPosition.XNAMatrix, invAnimationXNAMatrix);
+            LinkedFreightAnimation = linkedFreightAnimation;
+            SelectedStackLocationIndex = SelectLoadPosition();
+            if (SelectedStackLocationIndex == -1) return;
+            HandledContainer = StackLocations[SelectedStackLocationIndex].Containers[StackLocations[SelectedStackLocationIndex].Containers.Count - 1];
+            RelativeContainerPosition = Matrix.Multiply(HandledContainer.WorldPosition.XNAMatrix, InitialInvAnimationXNAMatrix);
+            ContainerFlipped = (Math.Abs(InitialInvAnimationXNAMatrix.M11 - HandledContainer.WorldPosition.XNAMatrix.M11) < 0.1f ? false : true);
+            WagonFlipped = (Math.Abs(InitialInvAnimationXNAMatrix.M11 - LinkedFreightAnimation.Wagon.WorldPosition.XNAMatrix.M11) < 0.1f ? false : true);
+            RelativeContainerPosition.M41 = HandledContainer.IntrinsicShapeOffset.X * (ContainerFlipped ? 1 : -1);
+            RelativeContainerPosition.M42 = HandledContainer.IntrinsicShapeOffset.Y * (ContainerFlipped ? 1 : -1);
+            RelativeContainerPosition.M43 = HandledContainer.IntrinsicShapeOffset.Z * (ContainerFlipped ? 1 : -1);
+            Status = ContainerStationStatus.LoadRaiseToPick;
+            TargetY = PickingSurfaceRelativeTopStartPosition.Y;
+            MoveY = true; 
+            SetGrabbers(HandledContainer);
+        }
+
+        public float ComputeTargetYBase(int positionVertical, int positionHorizontal = 0)
+        {
+            float retVal = StackLocations[positionHorizontal].Position.Y;
+            for (var iPos = 0; iPos <= positionVertical; iPos++)
+                retVal += StackLocations[positionHorizontal].Containers[iPos].HeightM;
+            return retVal;
+        }
+
+        /// <summary>
+        /// Move container together with container station
+        /// </summary>
+        /// 
+        public void TransferContainer(Matrix animationXNAMatrix)
+        {
+            AnimationXNAMatrix = animationXNAMatrix;
+            if (ContainerAttached)
+            {
+                // Move together also containers
+                HandledContainer.WorldPosition.XNAMatrix = Matrix.Multiply(RelativeContainerPosition, AnimationXNAMatrix);
+            }
+        }
+
+        public void ReInitPositionOffset (Matrix animationXNAMatrix)
+        {
+            InitialInvAnimationXNAMatrix = Matrix.Invert(animationXNAMatrix);
+        }
+
+        public void PassSpanParameters(float z1Span, float z2Span, float grabber01Max, float grabber02Max)
+        {
+            MinZSpan = Math.Min(Math.Abs(z1Span), Math.Abs(z2Span));
+            Grabber01Max = grabber01Max;
+            Grabber02Max = grabber02Max;
+
+        }
+
+        private void SetGrabbers(Container container)
+        {
+            TargetGrabber01 = Math.Min(Grabber01Max, (container.LengthM - MaxGrabberSpan) / 2 + Grabber01Max);
+            TargetGrabber02 = Math.Max(Grabber02Max, (-container.LengthM + MaxGrabberSpan) / 2 + Grabber02Max);
+            MoveGrabber = true;
+        }
+        private void SelectUnloadPosition()
+        {
+            var checkLength = (HandledContainer.LengthM > Container.Length20ftM + 0.01f && StackLocationsLength + 0.01f >= Container.Length40ftM) ? StackLocationsCount / 2 : StackLocationsCount;
+            var squaredDistanceToWagon = float.MaxValue;
+            int eligibleLocationIndex = -1;
+            for (int i = 0; i < checkLength; i++)
+            {
+                if (!StackLocations[i].Usable) continue;
+                if (StackLocations[i].Containers?.Count >= StackLocations[i].MaxStackedContainers) continue;
+                if (StackLocations[i].Containers?.Count > 0 && StackLocations[i].Containers[0]?.LengthM != HandledContainer.LengthM) continue;
+                var thisDistanceToWagon = (ActualX - StackLocations[i].Position.X) * (ActualX - StackLocations[i].Position.X) +
+                    (ActualZ - StackLocations[i].Position.Z) * (ActualZ - StackLocations[i].Position.Z);
+                if (thisDistanceToWagon > squaredDistanceToWagon) continue;
+                eligibleLocationIndex = i;
+                squaredDistanceToWagon = thisDistanceToWagon;
+            }
+            if (eligibleLocationIndex == -1)
+            {
+                Simulator.Confirmer.Message(ConfirmLevel.None, Simulator.Catalog.GetString("No suitable position to unload"));
+                // add return on wagon
+                return;
+            }
+            positionHorizontal = eligibleLocationIndex;
+            if (StackLocations[eligibleLocationIndex].Containers == null) StackLocations[eligibleLocationIndex].Containers = new List<Container>();
+            freePositionVertical = StackLocations[eligibleLocationIndex].Containers.Count;
+            if (HandledContainer.ContainerType == ContainerType.C20ft && StackLocationsLength + 0.01f >= Container.Length40ftM && eligibleLocationIndex < StackLocationsCount / 2)
+                StackLocations[eligibleLocationIndex + StackLocationsCount / 2].Usable = true;
+            TargetX = StackLocations[eligibleLocationIndex].Position.X;
+            TargetZ = StackLocations[eligibleLocationIndex].Position.Z + HandledContainer.LengthM * (StackLocations[eligibleLocationIndex].Flipped ? -1 : 1) / 2;
+        }
+
+        public bool CheckForEligibleStackPosition(Container container)
+        {
+            var checkLength = (container.LengthM > Container.Length20ftM + 0.01f && StackLocationsLength + 0.01f >= Container.Length40ftM) ? StackLocationsCount / 2 : StackLocationsCount;
+            for (int i = 0; i < checkLength; i++)
+            {
+                if (!StackLocations[i].Usable) continue;
+                if (StackLocations[i].Containers?.Count >= StackLocations[i].MaxStackedContainers) continue;
+                if (StackLocations[i].Containers?.Count > 0 && StackLocations[i].Containers[0]?.LengthM != container.LengthM) continue;
+                return true;
+            }
+            return false;
+        }
+
+        private int SelectLoadPosition()
+        {
+            var squaredDistanceToWagon = float.MaxValue;
+            int eligibleLocationIndex = -1;
+            var relativeAnimationPosition = Matrix.Multiply(LinkedFreightAnimation.Wagon.WorldPosition.XNAMatrix, InitialInvAnimationXNAMatrix);
+            var animationZ = PickingSurfaceRelativeTopStartPosition.Z - relativeAnimationPosition.Translation.Z - LinkedFreightAnimation.Offset.Z *
+                (WagonFlipped ? -1 : 1);
+
+            for (int i = 0; i < StackLocationsCount; i++)
+            {
+                if (StackLocations[i].Containers?.Count > 0)
+                {
+                    if (!LinkedFreightAnimation.FreightAnimations.Validity(LinkedFreightAnimation.Wagon, StackLocations[i].Containers[StackLocations[i].Containers.Count - 1],
+                        LinkedFreightAnimation.LoadPosition, LinkedFreightAnimation.Offset, LinkedFreightAnimation.LoadingAreaLength, out Vector3 offset))
+                        continue;
+                    // FixThis
+                    var thisDistanceToWagon = (PickingSurfaceRelativeTopStartPosition.X - StackLocations[i].Position.X) * (PickingSurfaceRelativeTopStartPosition.X - StackLocations[i].Position.X) +
+                        (animationZ - StackLocations[i].Position.Z) * (animationZ - StackLocations[i].Position.Z);
+                    if (thisDistanceToWagon > squaredDistanceToWagon) continue;
+                    eligibleLocationIndex = i;
+                    squaredDistanceToWagon = thisDistanceToWagon;
+                }
+            }
+            if (eligibleLocationIndex == -1)
+            {
+                Simulator.Confirmer.Message(ConfirmLevel.None, Simulator.Catalog.GetString("No suitable container to load"));
+                // add return on wagon
+                return eligibleLocationIndex;
+            }
+            return eligibleLocationIndex;
+        }
+
+    } // end Class ContainerHandlingItem
+
+    public class StackLocation
+    {
+        // Fixed data
+        public Vector3 Position;
+        public int MaxStackedContainers;
+        public float Length;
+        public bool Flipped;
+
+        // Variable data
+        public List<Container> Containers;
+        public bool Usable = true;
+
+        public StackLocation(PickupObj.StackLocation worldStackLocation)
+        {
+            Position = worldStackLocation.Position;
+            MaxStackedContainers = worldStackLocation.MaxStackedContainers;
+            Length = worldStackLocation.Length;
+            Flipped = worldStackLocation.Flipped;
+        }
+
+        public StackLocation(StackLocation stackLocation)
+        {
+            MaxStackedContainers = stackLocation.MaxStackedContainers;
+            Length = 6.095f;
+            Flipped = stackLocation.Flipped;
+            Position = stackLocation.Position;
+            Position.Z += 6.095f * (Flipped ? -1 : 1);
+        }
+    }
+}
+
diff --git a/Source/Orts.Simulation/Simulation/FuelPickup.cs b/Source/Orts.Simulation/Simulation/FuelPickup.cs
index 69d321bd3..64e7cf584 100644
--- a/Source/Orts.Simulation/Simulation/FuelPickup.cs
+++ b/Source/Orts.Simulation/Simulation/FuelPickup.cs
@@ -58,7 +58,7 @@ public FuelPickupItem CreateFuelStation(WorldPosition position, IEnumerable<int>
     public class FuelPickupItem
     {
         internal WorldLocation Location;
-        readonly TrackNode TrackNode;
+        public TrackNode TrackNode;
 
         public FuelPickupItem(TrackNode trackNode, TrItem trItem)
         {
@@ -79,6 +79,8 @@ public bool ReFill()
             return false;
         }
 
+        public FuelPickupItem() { }
+
     } // end Class FuelPickupItem
 
 } // end Class FuelManager
diff --git a/Source/Orts.Simulation/Simulation/Physics/Train.cs b/Source/Orts.Simulation/Simulation/Physics/Train.cs
index a828cbe9b..c425580a0 100644
--- a/Source/Orts.Simulation/Simulation/Physics/Train.cs
+++ b/Source/Orts.Simulation/Simulation/Physics/Train.cs
@@ -4488,6 +4488,8 @@ public void CalculatePositionOfCars(float elapsedTime, float distance)
                     car.UpdatedTraveler(traveller, elapsedTime, distance, SpeedMpS);
                 }
                 length += car.CarLengthM;
+                // update position of container in discrete freight animations
+                car.UpdateFreightAnimationDiscretePositions();
             }
 
             FrontTDBTraveller = traveller;
diff --git a/Source/Orts.Simulation/Simulation/RollingStocks/MSTSWagon.cs b/Source/Orts.Simulation/Simulation/RollingStocks/MSTSWagon.cs
index 2925101ad..400b8f7aa 100644
--- a/Source/Orts.Simulation/Simulation/RollingStocks/MSTSWagon.cs
+++ b/Source/Orts.Simulation/Simulation/RollingStocks/MSTSWagon.cs
@@ -318,7 +318,8 @@ public enum PickupType
             FreightLivestock = 11,  // New to OR
             FreightFuel = 12,  // New to OR
             FreightMilk = 13,   // New to OR
-            SpecialMail = 14  // New to OR
+            SpecialMail = 14,  // New to OR
+            Container = 15  // New to OR
         }
 
         public class RefillProcess
@@ -969,6 +970,8 @@ public override void Initialize()
                         break;
                 }
             }
+            FreightAnimations?.Load(this, FreightAnimations.LoadDataList, true);
+            InitializeLoadPhysics();
         }
 
         public override void InitializeMoving()
@@ -1839,7 +1842,7 @@ public override void Update(float elapsedClockSeconds)
                 if (TendersSteamLocomotive != null)
                 {
                     if (TendersSteamLocomotive.IsTenderRequired == 1)
-                    {                        
+                    {
                         // Combined total water found by taking the current combined water (which may have extra water added via the auxiliary tender), and subtracting the 
                         // amount of water defined in the ENG file, and adding the water defined in the WAG file.
                         float TempMaxCombinedWater = TendersSteamLocomotive.MaxTotalCombinedWaterVolumeUKG;
@@ -1940,7 +1943,7 @@ public override void Update(float elapsedClockSeconds)
             }
 
             Pantographs.Update(elapsedClockSeconds);
-            
+
             MSTSBrakeSystem.Update(elapsedClockSeconds);
 
             // Updates freight load animations when defined in WAG file - Locomotive and Tender load animation are done independently in UpdateTenderLoad() & UpdateLocomotiveLoadPhysics()
@@ -1956,13 +1959,13 @@ public override void Update(float elapsedClockSeconds)
                         if (WeightLoadController.UpdateValue != 0.0)
                             Simulator.Confirmer.UpdateWithPerCent(CabControl.FreightLoad,
                                 CabSetting.Increase, WeightLoadController.CurrentValue * 100);
-                    // Update wagon parameters sensitive to wagon mass change
-                    // Calculate the difference ratio, ie how full the wagon is. This value allows the relevant value to be scaled from the empty mass to the full mass of the wagon
+                        // Update wagon parameters sensitive to wagon mass change
+                        // Calculate the difference ratio, ie how full the wagon is. This value allows the relevant value to be scaled from the empty mass to the full mass of the wagon
                         TempMassDiffRatio = WeightLoadController.CurrentValue;
-                   // Update brake parameters
+                        // Update brake parameters
                         MaxBrakeForceN = ((LoadFullMaxBrakeForceN - LoadEmptyMaxBrakeForceN) * TempMassDiffRatio) + LoadEmptyMaxBrakeForceN;
                         MaxHandbrakeForceN = ((LoadFullMaxHandbrakeForceN - LoadEmptyMaxHandbrakeForceN) * TempMassDiffRatio) + LoadEmptyMaxHandbrakeForceN;
-                  // Update friction related parameters
+                        // Update friction related parameters
                         DavisAN = ((LoadFullORTSDavis_A - LoadEmptyORTSDavis_A) * TempMassDiffRatio) + LoadEmptyORTSDavis_A;
                         DavisBNSpM = ((LoadFullORTSDavis_B - LoadEmptyORTSDavis_B) * TempMassDiffRatio) + LoadEmptyORTSDavis_B;
                         DavisCNSSpMM = ((LoadFullORTSDavis_C - LoadEmptyORTSDavis_C) * TempMassDiffRatio) + LoadEmptyORTSDavis_C;
@@ -1993,7 +1996,8 @@ public override void Update(float elapsedClockSeconds)
                 {
                     WaitForAnimationReady = false;
                     Simulator.Confirmer.Message(ConfirmLevel.Information, Simulator.Catalog.GetString("Starting unload"));
-                    WeightLoadController.StartDecrease(WeightLoadController.MinimumValue);
+                    if (FreightAnimations.LoadedOne is FreightAnimationContinuous)
+                        WeightLoadController.StartDecrease(WeightLoadController.MinimumValue);
                 }
             }
         }
@@ -4058,7 +4062,8 @@ public void StartRefillingOrUnloading(PickupObj matchPickup, IntakePoint intakeP
             if (FreightAnimations.LoadedOne == null)
             {
                 FreightAnimations.FreightType = (MSTSWagon.PickupType)type;
-                FreightAnimations.LoadedOne = intakePoint.LinkedFreightAnim;
+                if (intakePoint.LinkedFreightAnim is FreightAnimationContinuous)
+                    FreightAnimations.LoadedOne = (FreightAnimationContinuous)intakePoint.LinkedFreightAnim;
             }
             if (!unload)
             {
@@ -4077,6 +4082,62 @@ public void StartRefillingOrUnloading(PickupObj matchPickup, IntakePoint intakeP
 
         }
 
+
+        /// <summary>
+        /// Starts loading or unloading of a discrete load.
+        /// </summary>
+        /// <param name="type">Pickup point</param>
+        public void StartLoadingOrUnloading(PickupObj matchPickup, IntakePoint intakePoint, bool unload)
+        {
+            var type = matchPickup.PickupType;
+ /*           var controller = WeightLoadController;
+            if (controller == null)
+            {
+                Simulator.Confirmer.Message(ConfirmLevel.Error, Simulator.Catalog.GetString("Incompatible data"));
+                return;
+            }
+            controller.CommandStartTime = Simulator.ClockTime;  // for Replay to use */
+
+            FreightAnimations.FreightType = (MSTSWagon.PickupType)type;
+
+            var containerStation = Simulator.ContainerManager.ContainerHandlingItems.Where(item => item.Key == matchPickup.TrItemIDList[0].dbID).Select(item => item.Value).First();
+            if (containerStation.Status != ContainerHandlingItem.ContainerStationStatus.Idle)
+            {
+                Simulator.Confirmer.Message(ConfirmLevel.Information, Simulator.Catalog.GetString("Container station busy with preceding mission"));
+                return;
+            }
+            if (!unload)
+            {
+                if (containerStation.Containers.Count == 0)
+                {
+                    Simulator.Confirmer.Message(ConfirmLevel.Information, Simulator.Catalog.GetString("No containers to load"));
+                    return;
+                }  
+ //               var container = containerStation.Containers.Last();
+                Simulator.Confirmer.Message(ConfirmLevel.Information, Simulator.Catalog.GetString("Starting load"));
+                // immediate load at the moment
+//                FreightAnimations.DiscreteLoadedOne.Container = container;
+                 containerStation.PrepareForLoad((FreightAnimationDiscrete)intakePoint.LinkedFreightAnim);
+ //               FreightAnimations.DiscreteLoadedOne.Loaded = true;
+            }
+            else
+            {
+                if (containerStation.Containers.Count >= containerStation.MaxStackedContainers * containerStation.StackLocationsCount)
+                {
+                    Simulator.Confirmer.Message(ConfirmLevel.Information, Simulator.Catalog.GetString("Container station full, can't unload"));
+                    return;
+                }
+                WaitForAnimationReady = true;
+                UnloadingPartsOpen = true;
+                if (FreightAnimations.UnloadingStartDelay > 0)
+                    Simulator.Confirmer.Message(ConfirmLevel.Information, Simulator.Catalog.GetString("Preparing for unload"));
+                // immediate unload at the moment
+                // switch from freightanimation to container
+                containerStation.PrepareForUnload((FreightAnimationDiscrete)intakePoint.LinkedFreightAnim);
+            }
+
+        }
+
     }
 
 
@@ -4090,9 +4151,9 @@ public class IntakePoint
     {
         public float OffsetM = 0f;   // distance forward? from the centre of the vehicle as defined by LengthM/2.
         public float WidthM = 10f;   // of the filling point. Is the maximum positioning error allowed equal to this or half this value? 
-        public MSTSWagon.PickupType Type;          // 'freightgrain', 'freightcoal', 'freightgravel', 'freightsand', 'fuelcoal', 'fuelwater', 'fueldiesel', 'fuelwood', freightgeneral, freightlivestock, specialmail
+        public MSTSWagon.PickupType Type;          // 'freightgrain', 'freightcoal', 'freightgravel', 'freightsand', 'fuelcoal', 'fuelwater', 'fueldiesel', 'fuelwood', freightgeneral, freightlivestock, specialmail, container
         public float? DistanceFromFrontOfTrainM;
-        public FreightAnimationContinuous LinkedFreightAnim = null;
+        public FreightAnimation LinkedFreightAnim = null;
 
         public IntakePoint()
         {
@@ -4116,6 +4177,58 @@ public IntakePoint(IntakePoint copy)
 
         }
 
+        public bool Validity(bool onlyUnload, PickupObj pickup, ContainerManager containerManager, FreightAnimations freightAnimations, out ContainerHandlingItem containerStation)
+        {
+            var validity = false;
+            containerStation = null;
+            var load = LinkedFreightAnim as FreightAnimationDiscrete;
+            // discrete freight wagon animation
+            if (load == null)
+                return validity;
+            else
+            {
+                containerStation = containerManager.ContainerHandlingItems.Where(item => item.Key == pickup.TrItemIDList[0].dbID).Select(item => item.Value).First();
+                if (containerStation.Containers.Count == 0 && !onlyUnload)
+                    return validity;
+            }
+            if (load.Container != null && !onlyUnload)
+                return validity;
+            else if (load.Container == null && onlyUnload)
+                return validity;
+            if (freightAnimations.DoubleStacker)
+            {
+                if (onlyUnload)
+                    for (var i = freightAnimations.Animations.Count - 1; i >= 0; i--)
+                    {
+                        if (freightAnimations.Animations[i] is FreightAnimationDiscrete discreteAnimation)
+                            if (discreteAnimation.LoadPosition == LoadPosition.Above && load != discreteAnimation)
+                                return validity;
+                            else break;
+                    }
+            }
+            if (!onlyUnload)
+            {
+                if (containerStation.Containers.Count == 0)
+                    return validity;
+                foreach (var stackLocation in containerStation.StackLocations)
+                {
+                    if (stackLocation.Containers?.Count > 0)
+                    {
+                        if (freightAnimations.Validity(load.Wagon, stackLocation.Containers[stackLocation.Containers.Count - 1],
+                            load.LoadPosition, load.Offset, load.LoadingAreaLength, out Vector3 offset))
+                            return true;
+                    }
+                }
+                return validity;
+            }
+            if (onlyUnload)
+            {
+                validity = containerStation.CheckForEligibleStackPosition(load.Container);
+            }
+            else validity = true;
+            return validity;
+        }
+
     }
 
     public class MSTSCoupling
diff --git a/Source/Orts.Simulation/Simulation/RollingStocks/SubSystems/FreightAnimations.cs b/Source/Orts.Simulation/Simulation/RollingStocks/SubSystems/FreightAnimations.cs
index 092fc5a3b..755ec1b19 100644
--- a/Source/Orts.Simulation/Simulation/RollingStocks/SubSystems/FreightAnimations.cs
+++ b/Source/Orts.Simulation/Simulation/RollingStocks/SubSystems/FreightAnimations.cs
@@ -15,8 +15,12 @@
 // You should have received a copy of the GNU General Public License
 // along with Open Rails.  If not, see <http://www.gnu.org/licenses/>.
 
+using Orts.Formats.Msts;
 using Orts.Parsers.Msts;
 using Orts.Simulation.RollingStocks.SubSystems.Controllers;
+using ORTS.Common;
+using Microsoft.Xna.Framework;
+using System;
 using System.Collections.Generic;
 using System.Diagnostics;
 using System.IO;
@@ -33,6 +37,7 @@ namespace Orts.Simulation.RollingStocks.SubSystems
     public class FreightAnimations
     {
         public List<FreightAnimation> Animations = new List<FreightAnimation>();
+        public List<FreightAnimationDiscrete> EmptyAnimations = new List<FreightAnimationDiscrete>();
         public float FreightWeight = 0;
         public float StaticFreightWeight = 0;
         public MSTSWagon.PickupType FreightType = MSTSWagon.PickupType.None;
@@ -41,11 +46,18 @@ public class FreightAnimations
         public FreightAnimationContinuous LoadedOne = null;
         public FreightAnimationContinuous FullPhysicsContinuousOne; // Allow reading of full physics parameters for continuous freight animation
         public FreightAnimationStatic FullPhysicsStaticOne; // Allow reading of full physics for static freight animation
-        public FreightAnimationDiscrete DiscreteLoadedOne = null;
         public float LoadingStartDelay = 0;
+        public float LoadingEndDelay = 0;
         public float UnloadingStartDelay = 0;
         public bool IsGondola = false;
- 
+        public float LoadingAreaLength = 12.19f;
+        public float AboveLoadingAreaLength = 12.19f;
+        public Vector3 Offset;
+        public IntakePoint GeneralIntakePoint;
+        public bool DoubleStacker;
+        public MSTSWagon Wagon;
+        public List<LoadData> LoadDataList;
+
         // additions to manage consequences of variable weight on friction and brake forces
         public float EmptyORTSDavis_A = -9999;
         public float EmptyORTSDavis_B = -9999;
@@ -56,18 +68,33 @@ public class FreightAnimations
         public float EmptyMaxHandbrakeForceN = -9999;
         public float EmptyCentreOfGravityM_Y = -9999; // get centre of gravity after adjusted for freight animation
         public bool ContinuousFreightAnimationsPresent = false; // Flag to indicate that a continuous freight animation is present
-        public bool StaticFreightAnimationsPresent = false; // Flag to indicate that a continuous freight animation is present
+        public bool StaticFreightAnimationsPresent = false; // Flag to indicate that a static freight animation is present
+        public bool DiscreteFreightAnimationsPresent = false; // Flag to indicate that a discrete freight animation is present
 
         public FreightAnimations(STFReader stf, MSTSWagon wagon)
         {
+            Wagon = wagon;
             stf.MustMatch("(");
             bool empty = true;
-              stf.ParseBlock(new[] {
+            stf.ParseBlock(new[] {
                 new STFReader.TokenProcessor("mstsfreightanimenabled", ()=>{ MSTSFreightAnimEnabled = stf.ReadBoolBlock(true);}),
                 new STFReader.TokenProcessor("wagonemptyweight", ()=>{ WagonEmptyWeight = stf.ReadFloatBlock(STFReader.UNITS.Mass, -1); }),
                 new STFReader.TokenProcessor("loadingstartdelay", ()=>{ UnloadingStartDelay = stf.ReadFloatBlock(STFReader.UNITS.None, 0); }),
+                new STFReader.TokenProcessor("loadingenddelay", ()=>{ LoadingEndDelay = stf.ReadFloatBlock(STFReader.UNITS.None, 0); }),
                 new STFReader.TokenProcessor("unloadingstartdelay", ()=>{ UnloadingStartDelay = stf.ReadFloatBlock(STFReader.UNITS.None, 0); }),
                 new STFReader.TokenProcessor("isgondola", ()=>{ IsGondola = stf.ReadBoolBlock(false);}),
+                new STFReader.TokenProcessor("loadingarealength", ()=>{ LoadingAreaLength = stf.ReadFloatBlock(STFReader.UNITS.Distance, 12.19f); }),
+                new STFReader.TokenProcessor("aboveloadingarealength", ()=>{ AboveLoadingAreaLength = stf.ReadFloatBlock(STFReader.UNITS.Distance, 12.19f); }),
+                new STFReader.TokenProcessor("intakepoint", ()=> 
+                {
+                    GeneralIntakePoint = new IntakePoint(stf);
+                }),
+                new STFReader.TokenProcessor("offset", ()=>
+                {
+                    Offset = stf.ReadVector3Block(STFReader.UNITS.Distance,  new Vector3(0, 0, 0));
+                    Offset.Z *= -1; // MSTS --> XNA
+                }),
+                new STFReader.TokenProcessor("doublestacker", ()=>{ DoubleStacker = stf.ReadBoolBlock(true);}),
                 // additions to manage consequences of variable weight on friction and brake forces
                 new STFReader.TokenProcessor("emptyortsdavis_a", ()=>{ EmptyORTSDavis_A = stf.ReadFloatBlock(STFReader.UNITS.Force, -1); }),
                 new STFReader.TokenProcessor("emptyortsdavis_b", ()=>{ EmptyORTSDavis_B = stf.ReadFloatBlock(STFReader.UNITS.Resistance, -1); }),
@@ -107,25 +134,20 @@ public FreightAnimations(STFReader stf, MSTSWagon wagon)
                     StaticFreightAnimationsPresent = true;
                     FullPhysicsStaticOne = Animations.Last() as FreightAnimationStatic;
                 }),
-/*                new STFReader.TokenProcessor("freightanimdiscrete", ()=>
+                new STFReader.TokenProcessor("loaddata", ()=>
                 {
-                    ORTSFreightAnims.Add(new FreightAnimDiscrete(stf));
-                    if ((ORTSFreightAnims.Last() as FreightAnimDiscrete).LoadedAtStart)
-                    {
-                        if (empty)
-                        {
-                            empty = false;
-                            DiscreteLoadedOne = ORTSFreightAnims.Last() as FreightAnimDiscrete;
-                            FreightWeight += DiscreteLoadedOne.LoadWeight;
-                        }
-                        else
-                        {
-                            (ORTSFreightAnims.Last() as FreightAnimContinuous).FullAtStart = false;
-                            Trace.TraceWarning("The wagon can't be full with two different materials, only first is retained");
-                        }
-                    }
-                }),*/
+                    stf.MustMatch("(");
+                    if (LoadDataList == null) LoadDataList = new List<LoadData>();
+                    LoadData loadData = new LoadData();
+                    loadData.Name = stf.ReadString();
+                    loadData.Folder = stf.ReadString();
+                    var positionString = stf.ReadString();
+                    Enum.TryParse(positionString, out loadData.LoadPosition);
+                    LoadDataList.Add(loadData);
+                    stf.MustMatch(")");
+                }),
             });
+//            Load(Wagon, LoadDataList);
         }
 
         /// <summary>
@@ -137,6 +159,23 @@ public void Save(BinaryWriter outf)
             outf.Write(FreightWeight);
             outf.Write((int)FreightType);
             outf.Write(StaticFreightWeight);
+            var discreteAnimCount = 0;
+            foreach (var freightAnim in Animations)
+            {
+                if (freightAnim is FreightAnimationDiscrete)
+                    discreteAnimCount++;
+            }
+            outf.Write(discreteAnimCount);
+            foreach (var freightAnim in Animations)
+            {
+                if (freightAnim is FreightAnimationDiscrete)
+                {
+                    (freightAnim as FreightAnimationDiscrete).Save(outf);
+                }
+            }
+            outf.Write(EmptyAnimations.Count);
+            foreach (var emptyAnim in EmptyAnimations)
+                emptyAnim.Save(outf);
         }
 
         /// <summary>
@@ -147,13 +186,14 @@ public void Restore(BinaryReader inf)
         {
             FreightWeight = inf.ReadSingle();
             var fType = inf.ReadInt32();
+            StaticFreightWeight = inf.ReadSingle();
             FreightType = (MSTSWagon.PickupType)fType;
             LoadedOne = null;
             foreach (var freightAnim in Animations)
             {
                 if (freightAnim is FreightAnimationContinuous)
                 {
-                    if ((freightAnim as FreightAnimationContinuous).LinkedIntakePoint !=  null )
+                    if ((freightAnim as FreightAnimationContinuous).LinkedIntakePoint != null)
                     {
                         if ((freightAnim as FreightAnimationContinuous).LinkedIntakePoint.Type == FreightType)
                         {
@@ -167,28 +207,61 @@ public void Restore(BinaryReader inf)
                     }
                 }
             }
-            StaticFreightWeight = inf.ReadSingle();
+            int discreteAnimCount = inf.ReadInt32();
+            if (discreteAnimCount > 0)
+            {
+                for (int i = 0; i < discreteAnimCount; i++)
+                {
+                    var discreteFreightAnim = new FreightAnimationDiscrete(inf, this);
+                    Animations.Add(discreteFreightAnim);
+                }
+            }
+            int emptyAnimCount = inf.ReadInt32();
+            if (emptyAnimCount > 0)
+            {
+                for (int i = 0; i < emptyAnimCount; i++)
+                {
+                    var emptyFreightAnim = new FreightAnimationDiscrete(inf, this);
+                    EmptyAnimations.Add(emptyFreightAnim);
+                }
+            }
         }
 
         public FreightAnimations(FreightAnimations copyFACollection, MSTSWagon wagon)
         {
-
+            Wagon = wagon;
             foreach (FreightAnimation freightAnim in copyFACollection.Animations)
             {
                 if (freightAnim is FreightAnimationContinuous)
                 {
                     Animations.Add(new FreightAnimationContinuous(freightAnim as FreightAnimationContinuous, wagon));
                     if ((Animations.Last() as FreightAnimationContinuous).FullAtStart) LoadedOne = Animations.Last() as FreightAnimationContinuous;
-                    
+
                 }
                 else if (freightAnim is FreightAnimationStatic)
                 {
                     Animations.Add(new FreightAnimationStatic(freightAnim as FreightAnimationStatic));
                 }
-                else if (freightAnim is FreightAnimationDiscrete)
+/*                else if (freightAnim is FreightAnimationDiscrete)
                 {
-                    Animations.Add(new FreightAnimationDiscrete(freightAnim as FreightAnimationDiscrete));
-                }
+                    Animations.Add(new FreightAnimationDiscrete(freightAnim as FreightAnimationDiscrete, this));
+                    if ((Animations.Last() as FreightAnimationDiscrete).LoadedAtStart && wagon.Simulator.Initialize && (Animations.Last() as FreightAnimationDiscrete).Container != null)
+                    {
+                        if (empty)
+                        {
+                            empty = false;
+                            FreightType = wagon.IntakePointList.Last().Type;
+                            var last = Animations.Last() as FreightAnimationDiscrete;
+                            FreightWeight += last.Container.MassKG;
+                            last.Loaded = true;
+                        }
+                        else
+                        {
+                            (Animations.Last() as FreightAnimationDiscrete).LoadedAtStart = false;
+                            Trace.TraceWarning("The wagon can't be full with two different materials, only first is retained");
+                        }
+                    }
+                }*/
             }
             FreightWeight = copyFACollection.FreightWeight;
             FreightType = copyFACollection.FreightType;
@@ -197,6 +270,24 @@ public FreightAnimations(FreightAnimations copyFACollection, MSTSWagon wagon)
             LoadingStartDelay = copyFACollection.LoadingStartDelay;
             UnloadingStartDelay = copyFACollection.UnloadingStartDelay;
             IsGondola = copyFACollection.IsGondola;
+            LoadingAreaLength = copyFACollection.LoadingAreaLength;
+            AboveLoadingAreaLength = copyFACollection.AboveLoadingAreaLength;
+            Offset = copyFACollection.Offset;
+            GeneralIntakePoint = new IntakePoint(copyFACollection.GeneralIntakePoint);
+            DoubleStacker = copyFACollection.DoubleStacker;
+            if (copyFACollection.LoadDataList?.Count >= 0)
+            {
+                foreach (var copyLoad in copyFACollection.LoadDataList)
+                {
+                    if (LoadDataList == null) LoadDataList = new List<LoadData>();
+                    LoadData loadData = new LoadData();
+                    loadData.Name = copyLoad.Name;
+                    loadData.Folder = copyLoad.Folder;
+                    loadData.LoadPosition = copyLoad.LoadPosition;
+                    LoadDataList.Add(loadData);
+                }
+            }
+
 
             // additions to manage consequences of variable weight on friction and brake forces
             EmptyORTSDavis_A = copyFACollection.EmptyORTSDavis_A;
@@ -209,9 +300,587 @@ public FreightAnimations(FreightAnimations copyFACollection, MSTSWagon wagon)
             EmptyCentreOfGravityM_Y = copyFACollection.EmptyCentreOfGravityM_Y;
             ContinuousFreightAnimationsPresent = copyFACollection.ContinuousFreightAnimationsPresent;
             StaticFreightAnimationsPresent = copyFACollection.StaticFreightAnimationsPresent;
+            DiscreteFreightAnimationsPresent = copyFACollection.DiscreteFreightAnimationsPresent;
+
+//            Load(Wagon, LoadDataList);
+        }
+
+        public void Load(MSTSWagon wagon, string loadFilePath, LoadPosition loadPosition)
+        {
+            if (GeneralIntakePoint.Type == MSTSWagon.PickupType.Container)
+            {
+                Container container;
+                container = new Container(wagon, loadFilePath);
+                if (ContainerManager.LoadedContainers.ContainsKey(loadFilePath))
+                {
+                    container.Copy(ContainerManager.LoadedContainers[loadFilePath]);
+                }
+                else
+                {
+                    container.LoadFromContainerFile(loadFilePath);
+                    ContainerManager.LoadedContainers.Add(loadFilePath, container);
+                }
+                Vector3 offset = new Vector3(0, 0, 0);
+                var validity = Validity(wagon, container, loadPosition, Offset, LoadingAreaLength, out offset);
+                if (validity)
+                {
+                    var freightAnimDiscrete = new FreightAnimationDiscrete(this, container, loadPosition, offset);
+                    Animations.Add(freightAnimDiscrete);
+                    container.ComputeWorldPosition(freightAnimDiscrete);
+                    wagon.Simulator.ContainerManager.Containers.Add(container);
+                    UpdateEmptyFreightAnims(container.LengthM);
+                }
+                else
+                    Trace.TraceWarning($"Container {container.ShapeFileName} could not be allocated on wagon {wagon.WagFilePath}");
+            }
+            else
+                Trace.TraceWarning("No match between wagon and load");
+        }
+
+        public void Load(MSTSWagon wagon, List<LoadData> loadDataList, bool listInWagFile = false)
+        {
+            if (loadDataList != null && loadDataList.Count != 0)
+            {
+                foreach (var loadData in loadDataList)
+                {
+                    string loadDataFolder = wagon.Simulator.BasePath + @"\trains\trainset\" + loadData.Folder;
+                    string loadFilePath = loadDataFolder + @"\" + loadData.Name + ".loa";
+                    if (!File.Exists(loadFilePath))
+                    {
+                        Trace.TraceWarning($"Ignored missing load {loadFilePath}");
+                        continue;
+                    }
+                   Load(wagon, loadFilePath, loadData.LoadPosition);
+                }
+            }
+            if (listInWagFile) return;
+            var discrete = false;
+            foreach (var animation in Animations)
+            {
+                if (animation is FreightAnimationDiscrete)
+                {
+                    discrete = true;
+                    break;
+                }
+            }
+            if (!discrete)
+                // generate an empty freightAnim
+                EmptyAnimations.Add(new FreightAnimationDiscrete(this, LoadPosition.Center));
+            EmptyAbove();
+            if (!listInWagFile)
+                wagon.UpdateLoadPhysics();
+        }
+
+        public void EmptyAbove()
+        {
+            if (!DoubleStacker) return;
+            var aboveAllowed = AboveAllowed();
+            if (aboveAllowed)
+            {
+                foreach (var animation in Animations)
+                {
+                    if (animation is FreightAnimationDiscrete discreteAnimation)
+                    {
+                        if (discreteAnimation.LoadPosition == LoadPosition.Above)
+                        {
+                            aboveAllowed = false;
+                            break;
+                        }
+                    }
+                }
+            }
+            if (aboveAllowed)
+                // generate an empty freightAnim
+                EmptyAnimations.Add(new FreightAnimationDiscrete(this, LoadPosition.Above));
+        }
+
+        public bool Validity(MSTSWagon wagon, Container container, LoadPosition loadPosition, Vector3 inOffset, float loadingAreaLength, out Vector3 offset)
+        {
+            offset = new Vector3();
+            offset = inOffset;
+            var validity = false;
+            var zOffset = 0f;
+            var freightAnimDiscreteCount = 0;
+            switch (loadPosition)
+            {
+                case LoadPosition.Center:
+                    break;
+                case LoadPosition.CenterRear:
+                    zOffset += container.LengthM / 2;
+                    break;
+                case LoadPosition.CenterFront:
+                    zOffset -= container.LengthM / 2;
+                    break;
+                case LoadPosition.Rear:
+                    zOffset += (LoadingAreaLength - container.LengthM) / 2;
+                    break;
+                case LoadPosition.Front:
+                    zOffset -= (LoadingAreaLength - container.LengthM) / 2;
+                    break;
+                case LoadPosition.Above:
+                    if (container.ContainerType == ContainerType.C20ft || !DoubleStacker) return false;
+                    var heightBelow = 0.0f;
+                    var contType = ContainerType.C20ft;
+                    foreach (var animation in Animations)
+                    {
+                        if (animation is FreightAnimationDiscrete)
+                        {
+                            if ((animation as FreightAnimationDiscrete).LoadPosition == LoadPosition.Above) return false;
+                            if (heightBelow != 0 && (animation as FreightAnimationDiscrete).Container.HeightM != heightBelow)
+                                return false;
+                            heightBelow = (animation as FreightAnimationDiscrete).Container.HeightM;
+                            freightAnimDiscreteCount++;
+                            contType = (animation as FreightAnimationDiscrete).Container.ContainerType;
+                        }
+                    }
+                    if (freightAnimDiscreteCount == 0 || freightAnimDiscreteCount == 1 && contType == ContainerType.C20ft)
+                        return false;
+                    if (heightBelow != 0)
+                        offset.Y += heightBelow;
+                    else
+                        return false;
+                    break;
+            }
+            offset.Z = Offset.Z + zOffset;
+            if (container.LengthM > loadingAreaLength + 0.01f && loadPosition != LoadPosition.Above) return false;
+            if (container.LengthM > AboveLoadingAreaLength && loadPosition == LoadPosition.Above) return false;
+            if (container.LengthM > LoadingAreaLength / 2 + 0.01f && (loadPosition == LoadPosition.CenterFront ||
+                loadPosition == LoadPosition.CenterRear)) return false;
+            if (Animations.Count == 0 && loadPosition != LoadPosition.Above) return true;
+            freightAnimDiscreteCount = 0;
+            foreach (var animation in Animations)
+                if (animation is FreightAnimationDiscrete)               
+                    freightAnimDiscreteCount++;
+            if (freightAnimDiscreteCount == 0 && loadPosition != LoadPosition.Above) return true;
+            // there are already other containers present; check that there aren't superpositions
+            if (loadPosition == LoadPosition.Above)
+                return true;
+            foreach (var animation in Animations)
+            {
+                if (animation is FreightAnimationDiscrete animationDiscrete)
+                    if ((animationDiscrete).LoadPosition != LoadPosition.Above && Math.Abs(offset.Z - (animationDiscrete).Offset.Z) + 0.01f <
+                        (container.LengthM + (animationDiscrete).Container.LengthM) / 2)
+                        return false;
+                    else return true;
+            }
+            return validity;
+        }
+
+        public void UpdateEmptyFreightAnims(float containerLengthM)
+        {
+            var anim = Animations.Last() as FreightAnimationDiscrete;
+            if (anim.LoadPosition == LoadPosition.Above)
+            {
+                if (EmptyAnimations.Count > 0 && EmptyAnimations.Last().LoadPosition == LoadPosition.Above)
+                {
+                    anim.Wagon.IntakePointList.Remove(EmptyAnimations.Last().LinkedIntakePoint);
+                    EmptyAnimations.RemoveAt(EmptyAnimations.Count - 1);
+                }
+                return;
+            }
+            if (EmptyAnimations.Count == 1 && EmptyAnimations[0].LoadPosition == LoadPosition.Center &&
+                EmptyAnimations[0].LoadingAreaLength == LoadingAreaLength)
+            {
+                anim.Wagon.IntakePointList.Remove(EmptyAnimations[0].LinkedIntakePoint);
+                EmptyAnimations.RemoveAt(0);
+            }
+            if (EmptyAnimations.Count == 0)
+            {
+                if (anim.LoadPosition == LoadPosition.Above) return;
+                if (containerLengthM >= LoadingAreaLength - 0.02) return;
+                Vector3 offset = anim.Offset;
+                switch (anim.LoadPosition)
+                {
+                    case LoadPosition.Center:
+                        if ((LoadingAreaLength + 0.02f - anim.Container.LengthM) / 2 > 6.10f)
+                        {
+                            // one empty area behind, one in front
+                            var emptyLength = (LoadingAreaLength - anim.Container.LengthM) / 2;
+                            offset.Z = Offset.Z + LoadingAreaLength /2 - (LoadingAreaLength - anim.Container.LengthM) / 4;
+                            EmptyAnimations.Add(new FreightAnimationDiscrete(this, null, LoadPosition.Rear, offset, emptyLength));
+                            offset.Z = Offset.Z - LoadingAreaLength / 2 + (LoadingAreaLength - anim.Container.LengthM) / 4;
+                            EmptyAnimations.Add(new FreightAnimationDiscrete(this, null, LoadPosition.Front, offset, emptyLength));
+                        }
+                        break;
+                    case LoadPosition.CenterRear:
+                        // one empty area in front, check if enough place for the rear one
+                        offset = Offset;
+                        offset.Z -= LoadingAreaLength / 4;
+                        EmptyAnimations.Add(new FreightAnimationDiscrete(this, null, DoubleStacker ? LoadPosition.CenterFront : LoadPosition.Front,
+                            offset, LoadingAreaLength / 2));
+                        if (LoadingAreaLength / 2 + 0.01f - containerLengthM > 6.10)
+                        {
+                            offset.Z = Offset.Z + anim.Container.LengthM / 2 + LoadingAreaLength / 4;
+                            EmptyAnimations.Add(new FreightAnimationDiscrete(this, null, LoadPosition.Rear, offset,
+                                LoadingAreaLength / 2 - containerLengthM));
+                        }
+                        break;
+                    case LoadPosition.CenterFront:
+                        offset = Offset;
+                        offset.Z += LoadingAreaLength / 4;
+                        EmptyAnimations.Add(new FreightAnimationDiscrete(this, null, DoubleStacker ? LoadPosition.CenterRear : LoadPosition.Rear,
+                            offset, LoadingAreaLength / 2));
+                        if (LoadingAreaLength / 2 + 0.01f - containerLengthM > 6.10)
+                        {
+                            offset.Z = Offset.Z - containerLengthM / 2 - LoadingAreaLength / 4;
+                            EmptyAnimations.Add(new FreightAnimationDiscrete(this, null, LoadPosition.Front, offset,
+                                LoadingAreaLength / 2 - containerLengthM));
+                        }
+                        break;
+                    case LoadPosition.Rear:
+                        if (LoadingAreaLength + 0.02f - containerLengthM > 6.10f)
+                        {
+                            offset = Offset;
+                            offset.Z -= anim.Container.LengthM / 2;
+                            EmptyAnimations.Add(new FreightAnimationDiscrete(this, null, LoadPosition.Front, offset,
+                            LoadingAreaLength - containerLengthM));
+                        }
+                        break;
+                    case LoadPosition.Front:
+                        if (LoadingAreaLength + 0.02f - containerLengthM > 6.10f)
+                        {
+                            offset = Offset;
+                            offset.Z += containerLengthM / 2;
+                            EmptyAnimations.Add(new FreightAnimationDiscrete(this, null, LoadPosition.Rear, offset,
+                            LoadingAreaLength - containerLengthM));
+                        }
+                        break;
+                    default:
+                        break;
+                }
+            }
+            else
+            {
+                List<FreightAnimationDiscrete> deletableEmptyAnims = new List<FreightAnimationDiscrete>();
+
+                // more complex case, there is more than one container present at the floor level
+                foreach (var emptyAnim in EmptyAnimations)
+                {
+                    if (emptyAnim.LoadPosition == anim.LoadPosition && emptyAnim.LoadingAreaLength <= anim.LoadingAreaLength + 5)
+                    {
+                        anim.Wagon.IntakePointList.Remove(emptyAnim.LinkedIntakePoint);
+                        deletableEmptyAnims.Add(emptyAnim);
+                        continue;
+                    }
+                    if (emptyAnim.LoadPosition == LoadPosition.CenterRear && anim.LoadPosition == LoadPosition.CenterFront ||
+                        emptyAnim.LoadPosition == LoadPosition.CenterFront && anim.LoadPosition == LoadPosition.CenterRear)
+                        continue;
+                    if (emptyAnim.LoadPosition == LoadPosition.CenterRear && anim.LoadPosition == LoadPosition.Rear ||
+                        emptyAnim.LoadPosition == LoadPosition.Rear && anim.LoadPosition == LoadPosition.CenterRear ||
+                        emptyAnim.LoadPosition == LoadPosition.CenterFront && anim.LoadPosition == LoadPosition.Front ||
+                        emptyAnim.LoadPosition == LoadPosition.Front && anim.LoadPosition == LoadPosition.CenterFront
+                        )
+                    {
+                        if (emptyAnim.LoadingAreaLength + anim.LoadingAreaLength <= LoadingAreaLength / 2 + 0.02)
+                            continue;
+                        else if (LoadingAreaLength / 2 - anim.LoadingAreaLength < 6.09)
+                        {
+                            anim.Wagon.IntakePointList.Remove(emptyAnim.LinkedIntakePoint);
+                            deletableEmptyAnims.Add(emptyAnim);
+                            continue;
+                        }
+                        // emptyAnim might be 40ft ; if complex, delete Empty animation
+                        if (emptyAnim.LoadPosition == LoadPosition.Front || emptyAnim.LoadPosition == LoadPosition.Rear)
+                        {
+                            /*                           anim.Wagon.IntakePointList.Remove(emptyAnim.LinkedIntakePoint);
+                                                       deletableEmptyAnims.Add(emptyAnim);
+                                                       continue;*/
+                            var multiplier = 1;
+                            if (anim.LoadPosition == LoadPosition.CenterFront) multiplier = -1;
+                            emptyAnim.Offset.Z = Offset.Z + multiplier * (LoadingAreaLength / 2 - (LoadingAreaLength / 2 - anim.LoadingAreaLength) / 2);
+                            emptyAnim.LinkedIntakePoint.OffsetM = -emptyAnim.Offset.Z;
+                            emptyAnim.LoadingAreaLength = LoadingAreaLength / 2 - anim.LoadingAreaLength;
+                            continue;
+                        }
+                        else
+                        { 
+                            var multiplier = 1;
+                            if (anim.LoadPosition == LoadPosition.Front) multiplier = -1;
+                            emptyAnim.Offset.Z = Offset.Z + multiplier * (LoadingAreaLength / 2 - anim.LoadingAreaLength) / 2;
+                            emptyAnim.LinkedIntakePoint.OffsetM = -emptyAnim.Offset.Z;
+                            emptyAnim.LoadingAreaLength = LoadingAreaLength / 2 - anim.LoadingAreaLength;
+                            continue;
+                        }
+                    }
+                    if (emptyAnim.LoadPosition == LoadPosition.Center && (anim.LoadPosition == LoadPosition.Rear ||
+                        anim.LoadPosition == LoadPosition.Front))
+                    {
+                        if (emptyAnim.LoadingAreaLength / 2 + anim.LoadingAreaLength <= LoadingAreaLength / 2 + 0.02)
+                            continue;
+                        else if (LoadingAreaLength / 2 - anim.LoadingAreaLength < 3.045)
+                        {
+                            anim.Wagon.IntakePointList.Remove(emptyAnim.LinkedIntakePoint);
+                            deletableEmptyAnims.Add(emptyAnim);
+                            continue;
+                        }
+                        // add superposition case
+                        anim.Wagon.IntakePointList.Remove(emptyAnim.LinkedIntakePoint);
+                        deletableEmptyAnims.Add(emptyAnim);
+                        continue;
+                    }
+                    if (anim.LoadPosition == LoadPosition.Center && (emptyAnim.LoadPosition == LoadPosition.Rear ||
+                        emptyAnim.LoadPosition == LoadPosition.Front))
+                    {
+                        if (anim.LoadingAreaLength / 2 + emptyAnim.LoadingAreaLength <= LoadingAreaLength / 2 + 0.02)
+                            continue;
+                        else if (LoadingAreaLength / 2 - anim.LoadingAreaLength / 2 < 3.045)
+                        {
+                            anim.Wagon.IntakePointList.Remove(emptyAnim.LinkedIntakePoint);
+                            deletableEmptyAnims.Add(emptyAnim);
+                            continue;
+                        }
+                        // add superposition case
+                        anim.Wagon.IntakePointList.Remove(emptyAnim.LinkedIntakePoint);
+                        deletableEmptyAnims.Add(emptyAnim);
+                        continue;
+                    }
+
+                    if (anim.LoadPosition == LoadPosition.Rear && emptyAnim.LoadPosition == LoadPosition.Front ||
+                        anim.LoadPosition == LoadPosition.Front && emptyAnim.LoadPosition == LoadPosition.Rear)
+                    {
+                        if (anim.LoadingAreaLength + emptyAnim.LoadingAreaLength <= LoadingAreaLength + 0.02)
+                            continue;
+                        else if (LoadingAreaLength - anim.LoadingAreaLength < 5.0)
+                        {
+                            anim.Wagon.IntakePointList.Remove(emptyAnim.LinkedIntakePoint);
+                            deletableEmptyAnims.Add(emptyAnim);
+                            continue;
+                        }
+                        // superposition case
+                        var multiplier = 1;
+                        if (anim.LoadPosition == LoadPosition.Rear) multiplier = -1;
+                        emptyAnim.Offset.Z += multiplier * (LoadingAreaLength - anim.LoadingAreaLength) / 2;
+                        emptyAnim.LinkedIntakePoint.OffsetM = -emptyAnim.Offset.Z;
+                        emptyAnim.LoadingAreaLength = LoadingAreaLength - anim.LoadingAreaLength;
+                        continue;
+                    }
+
+                    if (anim.LoadPosition == LoadPosition.CenterRear && emptyAnim.LoadPosition == LoadPosition.Front ||
+                        anim.LoadPosition == LoadPosition.CenterFront && emptyAnim.LoadPosition == LoadPosition.Rear)
+                    {
+                        if (emptyAnim.LoadingAreaLength <= LoadingAreaLength / 2 + 0.02)
+                            continue;
+                        else
+                        {
+                            // superposition case
+                            var multiplier = 1;
+                            if (anim.LoadPosition == LoadPosition.CenterRear) multiplier = -1;
+                            emptyAnim.Offset.Z = Offset.Z + multiplier * LoadingAreaLength / 4;
+                            emptyAnim.LinkedIntakePoint.OffsetM = -emptyAnim.Offset.Z;
+                            emptyAnim.LoadingAreaLength = LoadingAreaLength / 2;
+                            continue;
+                        }
+                    }
+                    if (anim.LoadPosition == LoadPosition.Front && emptyAnim.LoadPosition == LoadPosition.Front ||
+                        anim.LoadPosition == LoadPosition.Rear && emptyAnim.LoadPosition == LoadPosition.Rear)
+                    {
+                        if (emptyAnim.LoadingAreaLength <= anim.LoadingAreaLength + 0.02)
+                        {
+                            anim.Wagon.IntakePointList.Remove(emptyAnim.LinkedIntakePoint);
+                            deletableEmptyAnims.Add(emptyAnim);
+                            continue;
+                        }
+                        else
+                        {
+                            // superposition case
+                            var multiplier = 1;
+                            if (anim.LoadPosition == LoadPosition.Rear) multiplier = -1;
+                            emptyAnim.Offset.Z += multiplier * anim.LoadingAreaLength / 2;
+                            emptyAnim.LinkedIntakePoint.OffsetM = -emptyAnim.Offset.Z;
+                            emptyAnim.LoadingAreaLength -= anim.LoadingAreaLength;
+                            if (Math.Abs(emptyAnim.Offset.Z - Offset.Z) < 0.02f) emptyAnim.LoadPosition = LoadPosition.Center;
+                            else if (Math.Abs(emptyAnim.LoadingAreaLength + anim.LoadingAreaLength - LoadingAreaLength / 2)< 0.02f)
+                                emptyAnim.LoadPosition = anim.LoadPosition == LoadPosition.Front ? LoadPosition.CenterFront : LoadPosition.CenterRear;
+                            continue;
+                        }
+                    }
+                    if (emptyAnim.LoadPosition == LoadPosition.Center && (anim.LoadPosition == LoadPosition.CenterRear || anim.LoadPosition == LoadPosition.CenterFront))
+                    {
+                        // superposition case
+                        var multiplier = 1;
+                        if (anim.LoadPosition == LoadPosition.CenterRear) multiplier = -1;
+                        emptyAnim.LoadingAreaLength /= 2;
+                        emptyAnim.Offset.Z += multiplier * emptyAnim.LoadingAreaLength / 2;
+                        emptyAnim.LinkedIntakePoint.OffsetM = -emptyAnim.Offset.Z;
+                        emptyAnim.LoadPosition = anim.LoadPosition == LoadPosition.CenterRear ? LoadPosition.CenterFront : LoadPosition.CenterRear;
+                        continue;
+                    }
+                    Trace.TraceWarning("Uncovered case by updating empty freight animations, deleting it");
+                    anim.Wagon.IntakePointList.Remove(emptyAnim.LinkedIntakePoint);
+                    deletableEmptyAnims.Add(emptyAnim);
+                }
+                foreach (var deletableAnim in deletableEmptyAnims)
+                    EmptyAnimations.Remove(deletableAnim);
+            }
+            EmptyAbove();
+        }
+
+        public bool AboveAllowed()
+        {
+            var freightAnimDiscreteCount = 0;
+            var heightBelow = 0.0f;
+            var contType = ContainerType.C20ft;
+            foreach (var animation in Animations)
+            {
+                if (animation is FreightAnimationDiscrete)
+                {
+                    if ((animation as FreightAnimationDiscrete).LoadPosition == LoadPosition.Above) return false;
+                    if (heightBelow != 0 && (animation as FreightAnimationDiscrete).Container.HeightM != heightBelow)
+                        return false;
+                    heightBelow = (animation as FreightAnimationDiscrete).Container.HeightM;
+                    freightAnimDiscreteCount++;
+                    contType = (animation as FreightAnimationDiscrete).Container.ContainerType;
+                }
+            }
+            if (freightAnimDiscreteCount == 0 || freightAnimDiscreteCount == 1 && contType == ContainerType.C20ft)
+                return false;
+            if (heightBelow != 0)
+                return true;
+            else
+                return false;
+        }
+
+        public void MergeEmptyAnims()
+        {
+            if (EmptyAnimations.Count < 2) return;
+            var i = 0;
+            var other = (i + 1) % 2;
+            if (CheckForMerge(i))
+            {
+                Wagon.IntakePointList.Remove(EmptyAnimations[other].LinkedIntakePoint);
+                EmptyAnimations.RemoveAt(other);
+                return;
+            }
+            else
+            {
+                i++;
+                if (CheckForMerge(i))
+                {
+                    other = (i + 1) % 2;
+                    Wagon.IntakePointList.Remove(EmptyAnimations[other].LinkedIntakePoint);
+                    EmptyAnimations.RemoveAt(other);
+                }
+            }
+            return;
+        }
+
+        public bool CheckForMerge(int i)
+        {
+            var other = (i + 1) % 2;
+            switch (EmptyAnimations[i].LoadPosition)
+            {
+                case LoadPosition.Front:
+                    switch (EmptyAnimations[other].LoadPosition)
+                    {
+                        case LoadPosition.CenterFront:
+                            if (Math.Abs(EmptyAnimations[i].LoadingAreaLength + EmptyAnimations[other].LoadingAreaLength - LoadingAreaLength / 2) < 0.02)
+                            {
+                                EmptyAnimations[i].LoadingAreaLength = LoadingAreaLength / 2;
+                                EmptyAnimations[i].Offset.Z = Offset.Z - LoadingAreaLength / 4;
+                                EmptyAnimations[i].LinkedIntakePoint.OffsetM = -EmptyAnimations[i].Offset.Z;
+                                return true;
+                            }
+                            break;
+                        case LoadPosition.CenterRear:
+                            if (Math.Abs(EmptyAnimations[i].LoadingAreaLength - LoadingAreaLength / 2) < 0.02)
+                            {
+                                EmptyAnimations[i].LoadingAreaLength += EmptyAnimations[other].LoadingAreaLength;
+                                EmptyAnimations[i].Offset.Z = Offset.Z - LoadingAreaLength / 4 + EmptyAnimations[other].LoadingAreaLength / 2;
+                                EmptyAnimations[i].LinkedIntakePoint.OffsetM = -EmptyAnimations[i].Offset.Z;
+                                return true;
+                            }
+                            break;
+                        case LoadPosition.Rear:
+                            if (Math.Abs(EmptyAnimations[i].LoadingAreaLength + EmptyAnimations[other].LoadingAreaLength - LoadingAreaLength) < 0.02)
+                            {
+                                EmptyAnimations[i].LoadingAreaLength = LoadingAreaLength;
+                                EmptyAnimations[i].Offset.Z = Offset.Z;
+                                EmptyAnimations[i].LinkedIntakePoint.OffsetM = -EmptyAnimations[i].Offset.Z;
+                                return true;
+                            }
+                            break;
+                        case LoadPosition.Center:
+                            if (Math.Abs(EmptyAnimations[i].LoadingAreaLength + EmptyAnimations[other].LoadingAreaLength / 2 - LoadingAreaLength / 2) < 0.02)
+                            {
+                                EmptyAnimations[i].LoadingAreaLength += EmptyAnimations[other].LoadingAreaLength;
+                                EmptyAnimations[i].Offset.Z = Offset.Z - LoadingAreaLength / 2 + EmptyAnimations[i].LoadingAreaLength / 2;
+                                EmptyAnimations[i].LinkedIntakePoint.OffsetM = -EmptyAnimations[i].Offset.Z;
+                                return true;
+                            }
+                            break;
+                        default:
+                            break;
+                    }
+                    break;
+                case LoadPosition.CenterFront:
+                    switch (EmptyAnimations[other].LoadPosition)
+                    {
+                         case LoadPosition.CenterRear:
+                            if (Math.Abs(EmptyAnimations[i].LoadingAreaLength - EmptyAnimations[other].LoadingAreaLength) < 0.02)
+                            {
+                                EmptyAnimations[i].LoadingAreaLength += EmptyAnimations[other].LoadingAreaLength;
+                                EmptyAnimations[i].Offset.Z = Offset.Z;
+                                EmptyAnimations[i].LinkedIntakePoint.OffsetM = -EmptyAnimations[i].Offset.Z;
+                                EmptyAnimations[i].LoadPosition = LoadPosition.Center;
+                                return true;
+                            }
+                            break;
+                        case LoadPosition.Rear:
+                            if (Math.Abs(EmptyAnimations[other].LoadingAreaLength - LoadingAreaLength / 2) < 0.02)
+                            {
+                                EmptyAnimations[i].LoadingAreaLength += EmptyAnimations[other].LoadingAreaLength;
+                                EmptyAnimations[i].Offset.Z = Offset.Z + LoadingAreaLength / 2 - EmptyAnimations[i].LoadingAreaLength / 2;
+                                EmptyAnimations[i].LinkedIntakePoint.OffsetM = -EmptyAnimations[i].Offset.Z;
+                                EmptyAnimations[i].LoadPosition = LoadPosition.Rear;
+                                return true;
+                            }
+                            break;
+                        default:
+                            break;
+                    }
+                    break;
+                case LoadPosition.Center:
+                    switch (EmptyAnimations[other].LoadPosition)
+                    {
+                        case LoadPosition.Rear:
+                            if (Math.Abs(EmptyAnimations[other].LoadingAreaLength + EmptyAnimations[i].LoadingAreaLength / 2 - LoadingAreaLength / 2) < 0.02)
+                            {
+                                EmptyAnimations[i].LoadingAreaLength += EmptyAnimations[other].LoadingAreaLength;
+                                EmptyAnimations[i].Offset.Z = Offset.Z + LoadingAreaLength / 2 - EmptyAnimations[i].LoadingAreaLength / 2;
+                                EmptyAnimations[i].LinkedIntakePoint.OffsetM = -EmptyAnimations[i].Offset.Z;
+                                EmptyAnimations[i].LoadPosition = LoadPosition.Rear;
+                                return true;
+                            }
+                            break;
+                        default:
+                            break;
+                    }
+                    break;
+                case LoadPosition.CenterRear:
+                    switch (EmptyAnimations[other].LoadPosition)
+                    {
+                        case LoadPosition.Rear:
+                            if (Math.Abs(EmptyAnimations[other].LoadingAreaLength + EmptyAnimations[i].LoadingAreaLength - LoadingAreaLength / 2) < 0.02)
+                            {
+                                EmptyAnimations[i].LoadingAreaLength += EmptyAnimations[other].LoadingAreaLength;
+                                EmptyAnimations[i].Offset.Z = Offset.Z + LoadingAreaLength / 4;
+                                EmptyAnimations[i].LinkedIntakePoint.OffsetM = -EmptyAnimations[i].Offset.Z;
+                                EmptyAnimations[i].LoadPosition = LoadPosition.Rear;
+                                return true;
+                            }
+                            break;
+                        default:
+                            break;
+                    }
+                    break;
+                default:
+                    break;
+            }
+            return false;
         }
     }
 
+
     /// <summary>
     /// The 3 types of freightanims are inherited from the abstract FreightAnimation class.
     /// </summary>
@@ -310,13 +979,13 @@ public enum VisibleFrom
             Cab3D
         }
         public Type SubType;
-        public float XOffset = 0;
-        public float YOffset = 0;
-        public float ZOffset = 0;
         public float FreightWeight = 0;
         public bool Flipped = false;
         public bool Cab3DFreightAnim = false;
         public bool[] Visibility = { true, false, false };
+        public float XOffset = 0;
+        public float YOffset = 0;
+        public float ZOffset = 0;
 
         // additions to manage consequences of variable weight on friction and brake forces
         public float FullStaticORTSDavis_A = -9999;
@@ -414,53 +1083,139 @@ public class FreightAnimationDiscrete : FreightAnimation
     {
         public enum Type
         {
-            DEFAULT
+            DEFAULT,
+            Container
         }
         public Type SubType;
-        public float XOffset = 0;
-        public float YOffset = 0;
-        public float ZOffset = 0;
-        public float LoadWeight = 0;
+        public bool Loaded = false;
         public bool LoadedAtStart = false;
+        public IntakePoint LinkedIntakePoint = null;
+        public Vector3 Offset;
+        public MSTSWagon Wagon;
+        public FreightAnimations FreightAnimations;
+        public Container Container;
+        public float LoadingAreaLength = 12.19f;
+        public float AboveLoadingAreaLength = -1f;
+        public LoadPosition LoadPosition = LoadPosition.Center;
 
-        public FreightAnimationDiscrete(STFReader stf)
+         // for copy
+        public FreightAnimationDiscrete(FreightAnimationDiscrete freightAnimDiscrete, FreightAnimations freightAnimations)
         {
-            stf.MustMatch("(");
-            stf.ParseBlock(new STFReader.TokenProcessor[]
+            FreightAnimations = freightAnimations;
+            Wagon = FreightAnimations.Wagon;
+            if (freightAnimDiscrete.LinkedIntakePoint != null)
             {
-                new STFReader.TokenProcessor("subtype", ()=>
-                {
-                        var typeString = stf.ReadStringBlock(null);
-                        switch (typeString)
-	                    {
-                            default:
-                                SubType = FreightAnimationDiscrete.Type.DEFAULT;
-                                break;
-	                    }
-                }),
-                new STFReader.TokenProcessor("shape", ()=>{ ShapeFileName = stf.ReadStringBlock(null); }),
-                new STFReader.TokenProcessor("offset", ()=>{
-                    stf.MustMatch("(");
-                    XOffset = stf.ReadFloat(STFReader.UNITS.Distance, 0);
-                    YOffset = stf.ReadFloat(STFReader.UNITS.Distance, 0);
-                    ZOffset = stf.ReadFloat(STFReader.UNITS.Distance, 0);
-                    stf.MustMatch(")");
-                }),
-                new STFReader.TokenProcessor("loadweight", ()=>{ LoadWeight = stf.ReadFloatBlock(STFReader.UNITS.Mass, 0); }),
-                new STFReader.TokenProcessor("loadedatstart", ()=>{ LoadedAtStart = stf.ReadBoolBlock(true);}),
-            });
+                Wagon.IntakePointList.Add(new IntakePoint(freightAnimDiscrete.LinkedIntakePoint));
+                Wagon.IntakePointList.Last().LinkedFreightAnim = this;
+                LinkedIntakePoint = Wagon.IntakePointList.Last();
+            }
+            SubType = freightAnimDiscrete.SubType;
+            LoadedAtStart = freightAnimDiscrete.LoadedAtStart;
+            LoadingAreaLength = freightAnimDiscrete.LoadingAreaLength;
+            AboveLoadingAreaLength = freightAnimDiscrete.AboveLoadingAreaLength;
+            LoadPosition = freightAnimDiscrete.LoadPosition;
+            Offset = freightAnimDiscrete.Offset;
+            if (Wagon.Simulator.Initialize && freightAnimDiscrete.Container != null)
+            {
+                Container = new Container(freightAnimDiscrete, this);
+                Wagon.Simulator.ContainerManager.Containers.Add(Container);
+            }
         }
 
-        // for copy
-        public FreightAnimationDiscrete(FreightAnimationDiscrete freightAnimDiscrete)
+        public FreightAnimationDiscrete(FreightAnimations freightAnimations, Container container, LoadPosition loadPosition, Vector3 offset, float loadingAreaLength = 0)
         {
-            SubType = freightAnimDiscrete.SubType;
-            ShapeFileName = freightAnimDiscrete.ShapeFileName;
-            XOffset = freightAnimDiscrete.XOffset;
-            YOffset = freightAnimDiscrete.YOffset;
-            ZOffset = freightAnimDiscrete.ZOffset;
-            LoadWeight = freightAnimDiscrete.LoadWeight;
-            LoadedAtStart = freightAnimDiscrete.LoadedAtStart;
+            FreightAnimations = freightAnimations;
+            Wagon = FreightAnimations.Wagon;
+            Container = container;
+            AboveLoadingAreaLength = freightAnimations.AboveLoadingAreaLength;
+            if (container != null)
+            {
+                Loaded = true;
+                LoadedAtStart = true;
+                if (LoadPosition != LoadPosition.Above)
+                    LoadingAreaLength = Container.LengthM;
+            }
+            else
+                LoadingAreaLength = loadingAreaLength;
+            Offset = offset;
+            LoadPosition = loadPosition;
+            var intake = new IntakePoint();
+            intake.OffsetM -= Offset.Z;
+            intake.WidthM = 6;
+            intake.Type = MSTSWagon.PickupType.Container;
+            intake.LinkedFreightAnim = this;
+            Wagon.IntakePointList.Add(intake);
+            LinkedIntakePoint = intake;
+        }
+
+        // empty FreightAnimationDiscrete covering the whole Loading area
+        public FreightAnimationDiscrete(FreightAnimations freightAnimations, LoadPosition loadPosition)
+        {
+            FreightAnimations = freightAnimations;
+            Wagon = FreightAnimations.Wagon;
+            Loaded = false;
+            LoadedAtStart = false;
+            LoadPosition = loadPosition;
+            LinkedIntakePoint = new IntakePoint(freightAnimations.GeneralIntakePoint);
+            LinkedIntakePoint.LinkedFreightAnim = this;
+            Wagon.IntakePointList.Add(LinkedIntakePoint);
+            LoadingAreaLength = freightAnimations.LoadingAreaLength;
+            AboveLoadingAreaLength = freightAnimations.AboveLoadingAreaLength;
+            Offset = freightAnimations.Offset;
+        }
+
+        public void Save(BinaryWriter outf)
+        {
+            outf.Write(LinkedIntakePoint.OffsetM);
+            outf.Write(LinkedIntakePoint.WidthM);
+            outf.Write((int)LinkedIntakePoint.Type);
+            outf.Write(Offset.X);
+            outf.Write(Offset.Y);
+            outf.Write(Offset.Z);
+            outf.Write(LoadingAreaLength);
+            outf.Write(AboveLoadingAreaLength);
+            outf.Write((int)LoadPosition);
+            outf.Write(Loaded);
+            outf.Write(LinkedIntakePoint.OffsetM);
+            outf.Write(LinkedIntakePoint.WidthM);
+            outf.Write((int)LinkedIntakePoint.Type);
+            if (Container != null)
+            {
+                outf.Write(true);
+                Container.Save(outf);
+            }
+            else outf.Write(false);
+        }
+
+        public FreightAnimationDiscrete(BinaryReader inf, FreightAnimations freightAnimations)
+        {
+            FreightAnimations = freightAnimations;
+            Wagon = freightAnimations.Wagon;
+            LinkedIntakePoint = new IntakePoint();
+            LinkedIntakePoint.OffsetM = inf.ReadSingle();
+            LinkedIntakePoint.WidthM = inf.ReadSingle();
+            LinkedIntakePoint.Type = (MSTSWagon.PickupType)inf.ReadInt32();
+            Offset.X = inf.ReadSingle();
+            Offset.Y = inf.ReadSingle();
+            Offset.Z = inf.ReadSingle();
+            LoadingAreaLength = inf.ReadSingle();
+            AboveLoadingAreaLength = inf.ReadSingle();
+            LoadPosition = (LoadPosition)inf.ReadInt32();
+            Loaded = inf.ReadBoolean();
+            var intake = new IntakePoint();
+            intake.OffsetM = inf.ReadSingle();
+            intake.WidthM = inf.ReadSingle();
+            intake.Type = (MSTSWagon.PickupType)inf.ReadInt32();
+            intake.LinkedFreightAnim = this;
+            Wagon.IntakePointList.Add(intake);
+            LinkedIntakePoint = intake;
+            var containerPresent = inf.ReadBoolean();
+            if (containerPresent)
+            {
+                Container = new Container(inf, this, null, false);
+                Wagon.Simulator.ContainerManager.Containers.Add(Container);
+            }
         }
     }
 }
+
diff --git a/Source/Orts.Simulation/Simulation/RollingStocks/TrainCar.cs b/Source/Orts.Simulation/Simulation/RollingStocks/TrainCar.cs
index 5d76e379b..705e7c6b5 100644
--- a/Source/Orts.Simulation/Simulation/RollingStocks/TrainCar.cs
+++ b/Source/Orts.Simulation/Simulation/RollingStocks/TrainCar.cs
@@ -891,6 +891,32 @@ public virtual void Update(float elapsedClockSeconds)
             }
         }
 
+
+
+        /// <summary>
+        /// update position of discrete freight animations (e.g. containers)
+        /// </summary>  
+        public void UpdateFreightAnimationDiscretePositions()
+        {
+            if (FreightAnimations?.Animations != null)
+            {
+                foreach (var freightAnim in FreightAnimations.Animations)
+                {
+                    if (freightAnim is FreightAnimationDiscrete)
+                    {
+                        var discreteFreightAnim = freightAnim as FreightAnimationDiscrete;
+                        if (discreteFreightAnim.Loaded && discreteFreightAnim.Container != null)
+                        {
+                            var container = discreteFreightAnim.Container;
+                            container.WorldPosition.XNAMatrix = Matrix.Multiply(container.RelativeContainerMatrix, discreteFreightAnim.Wagon.WorldPosition.XNAMatrix);
+                            container.WorldPosition.TileX = WorldPosition.TileX;
+                            container.WorldPosition.TileZ = WorldPosition.TileZ;
+                        }
+                    }
+                }
+            }
+        }
+
         /// <summary>
         /// Initialise Train Temperatures
         /// <\summary>           
@@ -2260,6 +2286,7 @@ public virtual void Restore(BinaryReader inf)
             CarHeatCurrentCompartmentHeatJ = inf.ReadSingle();
             CarSteamHeatMainPipeSteamPressurePSI = inf.ReadSingle();
             CarHeatCompartmentHeaterOn = inf.ReadBoolean();
+            FreightAnimations?.LoadDataList?.Clear();
         }
 
         //================================================================================================//
@@ -2332,6 +2359,22 @@ public virtual bool GetCabFlipped()
             return false;
         }
 
+        //<comment>
+        //Initializes the physics of the car taking into account its variable discrete loads
+        //</comment>
+        public void InitializeLoadPhysics()
+        {
+            // TODO
+        }
+
+        //<comment>
+        //Updates the physics of the car taking into account its variable discrete loads
+        //</comment>
+        public void UpdateLoadPhysics()
+        {
+            // TODO
+        }
+
         public virtual float GetCouplerZeroLengthM()
         {
             return 0;
diff --git a/Source/Orts.Simulation/Simulation/Signalling/Signals.cs b/Source/Orts.Simulation/Simulation/Signalling/Signals.cs
index d93d35078..9b510a746 100644
--- a/Source/Orts.Simulation/Simulation/Signalling/Signals.cs
+++ b/Source/Orts.Simulation/Simulation/Signalling/Signals.cs
@@ -32,6 +32,7 @@
 using Orts.Parsers.Msts;
 using Orts.Simulation.AIs;
 using Orts.Simulation.Physics;
+using Orts.Simulation.RollingStocks;
 using ORTS.Common;
 using System;
 using System.Collections.Generic;
@@ -470,6 +471,7 @@ private void BuildSignalWorld(Simulator simulator, SignalConfigurationFile sigcf
             Tokens.Add(TokenID.Signal);
             Tokens.Add(TokenID.Speedpost);
             Tokens.Add(TokenID.Platform);
+            Tokens.Add(TokenID.Pickup);
 
             // loop through files, use only extention .w, skip w+1000000+1000000.w file
 
@@ -496,7 +498,7 @@ private void BuildSignalWorld(Simulator simulator, SignalConfigurationFile sigcf
                 }
 
                 // loop through all signals
-
+                var extendedWFileRead = false;
                 foreach (var worldObject in WFile.Tr_Worldfile)
                 {
                     if (worldObject.GetType() == typeof(SignalObj))
@@ -558,6 +560,37 @@ private void BuildSignalWorld(Simulator simulator, SignalConfigurationFile sigcf
                         if (!PlatformSidesList.ContainsKey(thisWorldObj.trItemIDList[0].dbID)) PlatformSidesList.Add(thisWorldObj.trItemIDList[0].dbID, thisWorldObj.PlatformData);
                         if (!PlatformSidesList.ContainsKey(thisWorldObj.trItemIDList[0].dbID)) PlatformSidesList.Add(thisWorldObj.trItemIDList[1].dbID, thisWorldObj.PlatformData);
                     }
+                    else if (worldObject.GetType() == typeof(PickupObj))
+                    {
+                        var thisWorldObj = worldObject as PickupObj;
+                        if (thisWorldObj.PickupType == (uint)MSTSWagon.PickupType.Container)
+                        {
+                            if (!extendedWFileRead)
+                            {
+                                WFilePath = Simulator.RoutePath + @"\World\Openrails\" + Path.GetFileName(fileName);
+                                if (File.Exists(WFilePath))
+                                {
+                                    // We have an OR-specific addition to world file
+                                    WFile.InsertORSpecificData(WFilePath, Tokens);
+                                    extendedWFileRead = true;
+                                }
+                            }
+                            if (worldObject.QDirection != null && worldObject.Position != null)
+                            {
+                                var MSTSPosition = worldObject.Position;
+                                var MSTSQuaternion = worldObject.QDirection;
+                                var XNAQuaternion = new Quaternion((float)MSTSQuaternion.A, (float)MSTSQuaternion.B, -(float)MSTSQuaternion.C, (float)MSTSQuaternion.D);
+                                var XNAPosition = new Vector3((float)MSTSPosition.X, (float)MSTSPosition.Y, -(float)MSTSPosition.Z);
+                                var worldMatrix = new WorldPosition(WFile.TileX, WFile.TileZ, XNAPosition, XNAQuaternion);
+                                var containerStation = Simulator.ContainerManager.CreateContainerStation(worldMatrix, from tid in thisWorldObj.TrItemIDList where tid.db == 0 select tid.dbID, thisWorldObj);
+                                Simulator.ContainerManager.ContainerHandlingItems.Add(thisWorldObj.TrItemIDList[0].dbID, containerStation);
+                            }
+                            else
+                            {
+                                Trace.TraceWarning("Container station {0} within .w file {1} {2} is missing Matrix3x3 and QDirection", worldObject.UID, WFile.TileX, WFile.TileZ);
+                            }
+                        }
+                    }
                 }
             }
 
diff --git a/Source/Orts.Simulation/Simulation/Simulator.cs b/Source/Orts.Simulation/Simulation/Simulator.cs
index b5e0d9b10..581f5293d 100644
--- a/Source/Orts.Simulation/Simulation/Simulator.cs
+++ b/Source/Orts.Simulation/Simulation/Simulator.cs
@@ -131,13 +131,16 @@ public class Simulator
         public SuperElevation SuperElevation;
         public int SuperElevationMinLen = 50;
         public float SuperElevationGauge = 1.435f;//1.435 guage
+        public LoadStationsOccupancyFile LoadStationsOccupancyFile;
 
         // Used in save and restore form
         public string PathName = "<unknown>";
         public float InitialTileX;
         public float InitialTileZ;
+        public bool Initialize = true;
         public HazzardManager HazzardManager;
         public FuelManager FuelManager;
+        public ContainerManager ContainerManager;
         public bool InControl = true;//For multiplayer, a player may not control his/her own train (as helper)
         public TurntableFile TurntableFile;
         public List<MovingTable> MovingTables = new List<MovingTable>();
@@ -370,6 +373,7 @@ public Simulator(UserSettings settings, string activityPath, bool useOpenRailsDi
             Confirmer = new Confirmer(this, 1.5);
             HazzardManager = new HazzardManager(this);
             FuelManager = new FuelManager(this);
+            ContainerManager = new ContainerManager(this);
             ScriptManager = new ScriptManager();
             Log = new CommandLog(this);
         }
@@ -440,6 +444,12 @@ public void SetExploreThroughActivity(string path, string consist, string start,
 
         public void Start(CancellationToken cancellation)
         {
+            ContainerManager = new ContainerManager(this);
+            if (Activity?.Tr_Activity?.Tr_Activity_Header?.LoadStationsOccupancyFile != null)
+            {
+                var occupancyFilePath = RoutePath + @"\Activities\Openrails\" + Activity.Tr_Activity.Tr_Activity_Header.LoadStationsOccupancyFile + ".lso";
+                LoadStationsOccupancyFile = new LoadStationsOccupancyFile(occupancyFilePath);
+            }
             Signals = new Signals(this, SIGCFG, cancellation);
             TurntableFile = new TurntableFile(RoutePath + @"\openrails\turntables.dat", RoutePath + @"\shapes\", MovingTables, this);
             LevelCrossings = new LevelCrossings(this);
@@ -481,6 +491,7 @@ public void StartTimetable(string[] arguments, CancellationToken cancellation)
             TurntableFile = new TurntableFile(RoutePath + @"\openrails\turntables.dat", RoutePath + @"\shapes\", MovingTables, this);
             LevelCrossings = new LevelCrossings(this);
             FuelManager = new FuelManager(this);
+            ContainerManager = new ContainerManager(this);
             Trains = new TrainList(this);
             PoolHolder = new Poolholder(this, arguments, cancellation);
             PathName = String.Copy(arguments[1]);
@@ -518,6 +529,7 @@ public void Stop()
 
         public void Restore(BinaryReader inf, string pathName, float initialTileX, float initialTileZ, CancellationToken cancellation)
         {
+            Initialize = false;
             ClockTime = inf.ReadDouble();
             Season = (SeasonType)inf.ReadInt32();
             WeatherType = (WeatherType)inf.ReadInt32();
@@ -527,9 +539,8 @@ public void Restore(BinaryReader inf, string pathName, float initialTileX, float
             InitialTileX = initialTileX;
             InitialTileZ = initialTileZ;
             PoolHolder = new Poolholder(inf, this);
-
+            ContainerManager = new ContainerManager(this);
             Signals = new Signals(this, SIGCFG, inf, cancellation);
-
             RestoreTrains(inf);
             LevelCrossings = new LevelCrossings(this);
             AI = new AI(this, inf);
@@ -548,6 +559,7 @@ public void Restore(BinaryReader inf, string pathName, float initialTileX, float
             ActivityRun = Orts.Simulation.Activity.Restore(inf, this, ActivityRun);
             Signals.RestoreTrains(Trains);  // restore links to trains
             Signals.Update(true);           // update all signals once to set proper stat
+            ContainerManager.Restore(inf);
             MPManager.Instance().RememberOriginalSwitchState(); // this prepares a string that must then be passed to clients
         }
 
@@ -570,6 +582,7 @@ public void Save(BinaryWriter outf)
                 foreach (var movingtable in MovingTables) movingtable.Save(outf);
 
             Orts.Simulation.Activity.Save(outf, ActivityRun);
+            ContainerManager.Save(outf);
         }
 
         Train InitializeTrains(CancellationToken cancellation)
@@ -773,6 +786,8 @@ public void Update(float elapsedClockSeconds)
             }
 
             if (HazzardManager != null) HazzardManager.Update(elapsedClockSeconds);
+
+            if (ContainerManager != null) ContainerManager.Update();
         }
 
         internal void SetWeather(WeatherType weather, SeasonType season)
@@ -1175,6 +1190,7 @@ private Train InitializePlayerTrain()
                     if (car is EOT) train.EOT = car as EOT;
 
                     if (car is EOT) train.EOT = car as EOT;
+                    car.FreightAnimations?.Load(car as MSTSWagon, wagon.LoadDataList);
                     train.Length += car.CarLengthM;
 
                     var mstsDieselLocomotive = car as MSTSDieselLocomotive;
@@ -1376,6 +1392,7 @@ private void InitializeStaticConsists()
                             car.CarID = activityObject.ID + " - " + car.UiD;
                             if (car is EOT)
                                 train.EOT = car as EOT;
+                            car.FreightAnimations?.Load(car as MSTSWagon, wagon.LoadDataList);
                         }
                         catch (Exception error)
                         {
diff --git a/Source/Orts.Simulation/Simulation/Transfertables.cs b/Source/Orts.Simulation/Simulation/Transfertables.cs
index 162d3b62a..00765ed29 100644
--- a/Source/Orts.Simulation/Simulation/Transfertables.cs
+++ b/Source/Orts.Simulation/Simulation/Transfertables.cs
@@ -326,6 +326,7 @@ public void TransferTrain(Matrix animationXNAMatrix)
                 foreach (TrainCar traincar in TrainsOnMovingTable[0].Train.Cars)
                 {
                     traincar.WorldPosition.XNAMatrix = Matrix.Multiply(RelativeCarPositions[iRelativeCarPositions], AnimationXNAMatrix);
+                    traincar.UpdateFreightAnimationDiscretePositions();
                     iRelativeCarPositions++;
                 }
             }
diff --git a/Source/Orts.Simulation/Simulation/Turntables.cs b/Source/Orts.Simulation/Simulation/Turntables.cs
index 1a45c7bb6..f8ce26198 100644
--- a/Source/Orts.Simulation/Simulation/Turntables.cs
+++ b/Source/Orts.Simulation/Simulation/Turntables.cs
@@ -670,6 +670,7 @@ public void RotateTrain(Matrix animationXNAMatrix)
                 foreach (TrainCar traincar in TrainsOnMovingTable[0].Train.Cars)
                 {
                     traincar.WorldPosition.XNAMatrix = Matrix.Multiply(RelativeCarPositions[iRelativeCarPositions], AnimationXNAMatrix);
+                    traincar.UpdateFreightAnimationDiscretePositions();
                     iRelativeCarPositions++;
                 }
             }
diff --git a/Source/RunActivity/RunActivity.csproj b/Source/RunActivity/RunActivity.csproj
index a47ec645b..5236955bd 100644
--- a/Source/RunActivity/RunActivity.csproj
+++ b/Source/RunActivity/RunActivity.csproj
@@ -183,6 +183,7 @@
     <Compile Include="Viewer3D\RollingStock\MSTSLocomotiveViewer.cs" />
     <Compile Include="Viewer3D\RollingStock\MSTSSteamLocomotiveViewer.cs" />
     <Compile Include="Viewer3D\RollingStock\MSTSWagonViewer.cs" />
+    <Compile Include="Viewer3D\RollingStock\SubSystems\ContainerViewer.cs" />
     <Compile Include="Viewer3D\RollingStock\SubSystems\DistributedPowerInterface.cs" />
     <Compile Include="Viewer3D\RollingStock\SubSystems\ETCS\DataEntry.cs" />
     <Compile Include="Viewer3D\RollingStock\SubSystems\ETCS\Menus.cs" />
diff --git a/Source/RunActivity/Viewer3D/RollingStock/MSTSLocomotiveViewer.cs b/Source/RunActivity/Viewer3D/RollingStock/MSTSLocomotiveViewer.cs
index 190da65ab..0a9eee044 100644
--- a/Source/RunActivity/Viewer3D/RollingStock/MSTSLocomotiveViewer.cs
+++ b/Source/RunActivity/Viewer3D/RollingStock/MSTSLocomotiveViewer.cs
@@ -29,6 +29,7 @@
 using Orts.Simulation;
 using Orts.Simulation.Physics;
 using Orts.Simulation.RollingStocks;
+using Orts.Simulation.RollingStocks.SubSystems;
 using Orts.Simulation.RollingStocks.SubSystems.Controllers;
 using Orts.Viewer3D.Common;
 using Orts.Viewer3D.Popups;
@@ -181,6 +182,7 @@ public override void InitializeUserInputCommands()
             UserInputCommands.Add(UserCommand.ControlHeadlightDecrease, new Action[] { Noop, () => new HeadlightCommand(Viewer.Log, false) });
             UserInputCommands.Add(UserCommand.ControlLight, new Action[] { Noop, () => new ToggleCabLightCommand(Viewer.Log) });
             UserInputCommands.Add(UserCommand.ControlRefill, new Action[] { () => StopRefillingOrUnloading(Viewer.Log), () => AttemptToRefillOrUnload() });
+            UserInputCommands.Add(UserCommand.ControlDiscreteUnload, new Action[] { () => StopRefillingOrUnloading(Viewer.Log, true), () => AttemptToRefillOrUnload(true) });
             UserInputCommands.Add(UserCommand.ControlImmediateRefill, new Action[] { () => StopImmediateRefilling(Viewer.Log), () => ImmediateRefill() });
             UserInputCommands.Add(UserCommand.ControlWaterScoop, new Action[] { Noop, () => new ToggleWaterScoopCommand(Viewer.Log) });
             UserInputCommands.Add(UserCommand.ControlOdoMeterShowHide, new Action[] { Noop, () => new ToggleOdometerCommand(Viewer.Log) });
@@ -423,7 +425,8 @@ public override void Unload()
             {(uint)MSTSWagon.PickupType.FreightLivestock, Viewer.Catalog.GetString("freight-livestock")},
             {(uint)MSTSWagon.PickupType.FreightFuel, Viewer.Catalog.GetString("freight-fuel")},
             {(uint)MSTSWagon.PickupType.FreightMilk, Viewer.Catalog.GetString("freight-milk")},
-            {(uint)MSTSWagon.PickupType.SpecialMail, Viewer.Catalog.GetString("mail")}
+            {(uint)MSTSWagon.PickupType.SpecialMail, Viewer.Catalog.GetString("mail")},
+            {(uint)MSTSWagon.PickupType.Container, Viewer.Catalog.GetString("container")}
         };
 
         /// <summary>
@@ -446,13 +449,14 @@ public class WagonAndMatchingPickup
         /// <param name="train"></param>
         /// <returns>a combination of intake point and pickup that are closest</returns>
         // <CJComment> Might be better in the MSTSLocomotive class, but can't see the World objects from there. </CJComment>
-        WagonAndMatchingPickup GetMatchingPickup(Train train)
+        WagonAndMatchingPickup GetMatchingPickup(Train train, bool onlyUnload = false)
         {
             var worldFiles = Viewer.World.Scenery.WorldFiles;
             var shortestD2 = float.MaxValue;
             WagonAndMatchingPickup nearestPickup = null;
             float distanceFromFrontOfTrainM = 0f;
             int index = 0;
+            ContainerHandlingItem containerStation = null;
             foreach (var car in train.Cars)
             {
                 if (car is MSTSWagon)
@@ -473,10 +477,15 @@ WagonAndMatchingPickup GetMatchingPickup(Train train)
                                     pickup.Location = new WorldLocation(
                                         worldFile.TileX, worldFile.TileZ,
                                         pickup.Position.X, pickup.Position.Y, pickup.Position.Z);
-                                if ((wagon.FreightAnimations != null && ((uint)wagon.FreightAnimations.FreightType == pickup.PickupType || wagon.FreightAnimations.FreightType == MSTSWagon.PickupType.None) &&
+                                  if ((wagon.FreightAnimations != null && ((uint)wagon.FreightAnimations.FreightType == pickup.PickupType || wagon.FreightAnimations.FreightType == MSTSWagon.PickupType.None) &&
                                     (uint)intake.Type == pickup.PickupType)
                                  || ((uint)intake.Type == pickup.PickupType && (uint)intake.Type > (uint)MSTSWagon.PickupType.FreightSand && (wagon.WagonType == TrainCar.WagonTypes.Tender || wagon is MSTSLocomotive)))
                                 {
+                                    if (intake.Type == MSTSWagon.PickupType.Container)
+                                    {
+                                        if (!intake.Validity(onlyUnload, pickup, Viewer.Simulator.ContainerManager, wagon.FreightAnimations, out containerStation))
+                                            continue;
+                                    }
                                     var intakePosition = new Vector3(0, 0, -intake.OffsetM);
                                     Vector3.Transform(ref intakePosition, ref car.WorldPosition.XNAMatrix, out intakePosition);
 
@@ -485,6 +494,19 @@ WagonAndMatchingPickup GetMatchingPickup(Train train)
                                         intakePosition.X, intakePosition.Y, -intakePosition.Z);
 
                                     var d2 = WorldLocation.GetDistanceSquared(intakeLocation, pickup.Location);
+                                    if (intake.Type == MSTSWagon.PickupType.Container && containerStation != null && 
+                                        (wagon.Train.FrontTDBTraveller.TN.Index == containerStation.TrackNode.Index ||
+                                        wagon.Train.FrontTDBTraveller.TN.Index == containerStation.TrackNode.Index) &&
+                                        d2 < containerStation.MinZSpan * containerStation.MinZSpan)
+                                    // for container it's enough if the intake is within the reachable range of the container crane
+                                    {
+                                        nearestPickup = new WagonAndMatchingPickup();
+                                        nearestPickup.Pickup = pickup;
+                                        nearestPickup.Wagon = wagon;
+                                        nearestPickup.IntakePoint = intake;
+                                        return nearestPickup;
+                                    }
+
                                     if (d2 < shortestD2)
                                     {
                                         shortestD2 = d2;
@@ -562,13 +584,13 @@ public void ImmediateRefill()
         /// Prompts if cannot refill yet, else starts continuous refilling.
         /// Tries to find the nearest supply (pickup point) which can refill the locos and tenders in the train.  
         /// </summary>
-        public void AttemptToRefillOrUnload()
+        public void AttemptToRefillOrUnload(bool onlyUnload = false)
         {
             MatchedWagonAndPickup = null;   // Ensures that releasing the T key doesn't do anything unless there is something to do.
 
             var loco = this.Locomotive;
 
-            var match = GetMatchingPickup(loco.Train);
+            var match = GetMatchingPickup(loco.Train, onlyUnload);
             if (match == null && !(loco is MSTSElectricLocomotive && loco.IsSteamHeatFitted))
                 return;
             if (match == null)
@@ -576,16 +598,32 @@ public void AttemptToRefillOrUnload()
                 Viewer.Simulator.Confirmer.Message(ConfirmLevel.None, Viewer.Catalog.GetString("Refill: Electric loco and no pickup. Command rejected"));
                 return;
             }
-
-            float distanceToPickupM = GetDistanceToM(match) - 2.5f; // Deduct an extra 2.5 so that the tedious placement is less of an issue.
-            if (distanceToPickupM > match.IntakePoint.WidthM / 2)
+            float distanceToPickupM = GetDistanceToM(match);
+            if (match.IntakePoint.LinkedFreightAnim != null && match.IntakePoint.LinkedFreightAnim is FreightAnimationDiscrete)
+                // for container cranes handle distance management using Z span of crane
             {
-                Viewer.Simulator.Confirmer.Message(ConfirmLevel.None, Viewer.Catalog.GetStringFmt("Refill: Distance to {0} supply is {1}.",
-                    PickupTypeDictionary[(uint)match.Pickup.PickupType], Viewer.Catalog.GetPluralStringFmt("{0} meter", "{0} meters", (long)(distanceToPickupM+1f))));
-                return;
-            }
-            if (distanceToPickupM <= match.IntakePoint.WidthM / 2)
+                var containerStation = Viewer.Simulator.ContainerManager.ContainerHandlingItems.Where(item => item.Key == match.Pickup.TrItemIDList[0].dbID).Select(item => item.Value).First();
+                if (distanceToPickupM > containerStation.MinZSpan)
+                {
+                    Viewer.Simulator.Confirmer.Message(ConfirmLevel.None, Viewer.Catalog.GetStringFmt("Container crane: Distance to {0} supply is {1}.",
+                        PickupTypeDictionary[(uint)match.Pickup.PickupType], Viewer.Catalog.GetPluralStringFmt("{0} meter", "{0} meters", (long)(distanceToPickupM + 0.5f))));
+                    return;
+                }
                 MSTSWagon.RefillProcess.ActivePickupObjectUID = (int)match.Pickup.UID;
+            }
+            else
+            {
+                distanceToPickupM -= 2.5f; // Deduct an extra 2.5 so that the tedious placement is less of an issue.
+                if (distanceToPickupM > match.IntakePoint.WidthM / 2)
+                {
+                    Viewer.Simulator.Confirmer.Message(ConfirmLevel.None, Viewer.Catalog.GetStringFmt("Refill: Distance to {0} supply is {1}.",
+                        PickupTypeDictionary[(uint)match.Pickup.PickupType], Viewer.Catalog.GetPluralStringFmt("{0} meter", "{0} meters", (long)(distanceToPickupM + 1f))));
+                    return;
+                }
+                if (distanceToPickupM <= match.IntakePoint.WidthM / 2)
+                    MSTSWagon.RefillProcess.ActivePickupObjectUID = (int)match.Pickup.UID;
+            }
+
             if (loco.SpeedMpS != 0 && match.Pickup.SpeedRange.MaxMpS == 0f)
             {
                 Viewer.Simulator.Confirmer.Message(ConfirmLevel.None, Viewer.Catalog.GetStringFmt("Refill: Loco must be stationary to refill {0}.",
@@ -605,18 +643,18 @@ public void AttemptToRefillOrUnload()
                     FormatStrings.FormatSpeedLimit(match.Pickup.SpeedRange.MaxMpS, Viewer.MilepostUnitsMetric)));
                 return;
             }
-            if (match.Wagon is MSTSDieselLocomotive || match.Wagon is MSTSSteamLocomotive || match.Wagon is MSTSElectricLocomotive ||  (match.Wagon.WagonType == TrainCar.WagonTypes.Tender && match.SteamLocomotiveWithTender != null))
+            if (match.Wagon is MSTSDieselLocomotive || match.Wagon is MSTSSteamLocomotive || match.Wagon is MSTSElectricLocomotive || (match.Wagon.WagonType == TrainCar.WagonTypes.Tender && match.SteamLocomotiveWithTender != null))
             {
                 // Note: The tender contains the intake information, but the steam locomotive includes the controller information that is needed for the refueling process.
 
                 float fraction = 0;
 
                 // classical MSTS Freightanim, handled as usual
-                if(match.SteamLocomotiveWithTender != null)
+                if (match.SteamLocomotiveWithTender != null)
                     fraction = match.SteamLocomotiveWithTender.GetFilledFraction(match.Pickup.PickupType);
                 else
                     fraction = match.Wagon.GetFilledFraction(match.Pickup.PickupType);
-                                
+
                 if (fraction > 0.99)
                 {
                     Viewer.Simulator.Confirmer.Message(ConfirmLevel.None, Viewer.Catalog.GetStringFmt("Refill: {0} supply now replenished.",
@@ -634,7 +672,7 @@ public void AttemptToRefillOrUnload()
                     MatchedWagonAndPickup = match;  // Save away for HandleUserInput() to use when key is released.
                 }
             }
-            else if (match.Wagon.FreightAnimations != null)
+            else if (match.Wagon.FreightAnimations?.Animations?.Count > 0 && match.Wagon.FreightAnimations.Animations[0] is FreightAnimationContinuous)
             {
                 // freight wagon animation
                 var fraction = match.Wagon.GetFilledFraction(match.Pickup.PickupType);
@@ -658,6 +696,34 @@ public void AttemptToRefillOrUnload()
                     MatchedWagonAndPickup = match;  // Save away for HandleUserInput() to use when key is released.
                 }
             }
+            else if (match.IntakePoint.LinkedFreightAnim is FreightAnimationDiscrete)
+            {
+                var load = match.IntakePoint.LinkedFreightAnim as FreightAnimationDiscrete;
+                // discrete freight wagon animation
+                if (load == null)
+                {
+                    Viewer.Simulator.Confirmer.Message(ConfirmLevel.None, Viewer.Catalog.GetStringFmt("wag file not equipped for containers"));
+                    return;
+                }
+                else if (load.Loaded && !onlyUnload)
+                {
+                    Viewer.Simulator.Confirmer.Message(ConfirmLevel.None, Viewer.Catalog.GetStringFmt("{0} now loaded.",
+                        PickupTypeDictionary[match.Pickup.PickupType]));
+                    return;
+                }
+                else if (!load.Loaded && onlyUnload)
+                {
+                    Viewer.Simulator.Confirmer.Message(ConfirmLevel.None, Viewer.Catalog.GetStringFmt("{0} now unloaded.",
+                        PickupTypeDictionary[match.Pickup.PickupType]));
+                    return;
+                }
+
+                MSTSWagon.RefillProcess.OkToRefill = true;
+                MSTSWagon.RefillProcess.Unload = onlyUnload;
+                match.Wagon.StartLoadingOrUnloading(match.Pickup, match.IntakePoint, MSTSWagon.RefillProcess.Unload);
+                MatchedWagonAndPickup = match;  // Save away for HandleUserInput() to use when key is released.
+
+            }
         }
 
         /// <summary>
@@ -728,13 +794,20 @@ public void StopImmediateRefilling(CommandLog log)
         /// <summary>
         /// Ends a continuous increase in controlled value.
         /// </summary>
-        public void StopRefillingOrUnloading(CommandLog log)
+        public void StopRefillingOrUnloading(CommandLog log, bool onlyUnload = true)
         {
             if (MatchedWagonAndPickup == null)
                 return;
+            if (MatchedWagonAndPickup.Pickup.PickupType == (uint)MSTSWagon.PickupType.Container)
+                return;
             MSTSWagon.RefillProcess.OkToRefill = false;
             MSTSWagon.RefillProcess.ActivePickupObjectUID = 0;
             var match = MatchedWagonAndPickup;
+            if (MatchedWagonAndPickup.Pickup.PickupType == (uint)MSTSWagon.PickupType.Container)
+            {
+                match.Wagon.UnloadingPartsOpen = false;
+                return;
+            }
             var controller = new MSTSNotchController();
             if (match.Wagon is MSTSElectricLocomotive || match.Wagon is MSTSDieselLocomotive || match.Wagon is MSTSSteamLocomotive || (match.Wagon.WagonType == TrainCar.WagonTypes.Tender && match.SteamLocomotiveWithTender != null))
             {
diff --git a/Source/RunActivity/Viewer3D/RollingStock/SubSystems/ContainerViewer.cs b/Source/RunActivity/Viewer3D/RollingStock/SubSystems/ContainerViewer.cs
new file mode 100644
index 000000000..b97964617
--- /dev/null
+++ b/Source/RunActivity/Viewer3D/RollingStock/SubSystems/ContainerViewer.cs
@@ -0,0 +1,182 @@
+﻿// COPYRIGHT 2015 by the Open Rails project.
+// 
+// This file is part of Open Rails.
+// 
+// Open Rails is free software: you can redistribute it and/or modify
+// it under the terms of the GNU General Public License as published by
+// the Free Software Foundation, either version 3 of the License, or
+// (at your option) any later version.
+// 
+// Open Rails is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+// 
+// You should have received a copy of the GNU General Public License
+// along with Open Rails.  If not, see <http://www.gnu.org/licenses/>.
+
+using Microsoft.Xna.Framework;
+using Orts.Simulation;
+using Orts.Simulation.RollingStocks;
+using Orts.Simulation.RollingStocks.SubSystems;
+using ORTS.Common;
+using System.Collections.Generic;
+using System.Linq;
+
+namespace Orts.Viewer3D.RollingStock.SubSystems
+{
+    public class ContainersViewer
+    {
+        public Dictionary<Container, ContainerViewer> Containers = new Dictionary<Container, ContainerViewer>();
+        List<Container> VisibleContainers = new List<Container>();
+        readonly Viewer Viewer;
+
+        public ContainersViewer(Viewer viewer, ContainerHandlingItem containerHandlingItem, string wagonFolderSlash)
+        {
+            foreach (var container in containerHandlingItem.Containers)
+            {
+                if (container.ShapeFileName != null)
+                    Containers.Add(container, new ContainerViewer(viewer, containerHandlingItem, wagonFolderSlash, container));
+            }
+        }
+
+        public ContainersViewer(Viewer viewer)
+        {
+            Viewer = viewer;
+        }
+
+
+        [CallOnThread("Updater")]
+        public void LoadPrep()
+        {
+            var visibleContainers = new List<Container>();
+            var removeDistance = Viewer.Settings.ViewingDistance * 1.5f;
+            foreach (var container in Viewer.Simulator.ContainerManager.Containers)
+                if (WorldLocation.ApproximateDistance(Viewer.Camera.CameraWorldLocation, container.WorldPosition.WorldLocation) < removeDistance)
+                    visibleContainers.Add(container);
+            VisibleContainers = visibleContainers;
+        }
+
+        public void Mark()
+        {
+            foreach (var container in Containers.Values)
+            {
+                container.Mark();
+            }
+        }
+
+        [CallOnThread("Loader")]
+        public void Load()
+        {
+            var cancellation = Viewer.LoaderProcess.CancellationToken;
+            var visibleContainers = VisibleContainers;
+            var containers = Containers;
+            if (visibleContainers.Any(c => !containers.ContainsKey(c)) || containers.Keys.Any(c => !visibleContainers.Contains(c)))
+            {
+                var newContainers = new Dictionary<Container, ContainerViewer>();
+                foreach (var container in visibleContainers)
+                {
+                    if (cancellation.IsCancellationRequested)
+                        break;
+                    if (containers.ContainsKey(container))
+                        newContainers.Add(container, containers[container]);
+                    else
+                        newContainers.Add(container, LoadContainer(container));
+                }
+                Containers = newContainers;
+            }
+        }
+
+        [CallOnThread("Loader")]
+        ContainerViewer LoadContainer(Container container)
+        {
+            return new ContainerViewer(Viewer, container);
+        }
+
+        [CallOnThread("Updater")]
+        public void PrepareFrame(RenderFrame frame, ElapsedTime elapsedTime)
+        {
+            var containers = Containers;
+            foreach (var container in containers.Values)
+                container.PrepareFrame(frame, elapsedTime);
+        }
+    }
+
+    public class ContainerViewer
+    {
+        public Container Container;
+        public AnimatedShape ContainerShape;
+        public Viewer Viewer;
+
+        public ContainerViewer(Viewer viewer, ContainerHandlingItem containerHandlingItem, string wagonFolderSlash, Container container)
+        {
+            Container = container;
+            Viewer = viewer;
+            ContainerShape = new AnimatedShape(viewer, container.BaseShapeFileFolderSlash + container.ShapeFileName + '\0' + container.BaseShapeFileFolderSlash, new WorldPosition(containerHandlingItem.ShapePosition), ShapeFlags.ShadowCaster);
+            if (ContainerShape.SharedShape.LodControls.Length > 0)
+            {
+                foreach (var lodControl in ContainerShape.SharedShape.LodControls)
+                {
+                    if (lodControl.DistanceLevels.Length > 0)
+                    {
+                        foreach (var distanceLevel in lodControl.DistanceLevels)
+                        {
+                            if (distanceLevel.SubObjects.Length > 0
+                                && distanceLevel.SubObjects[0].ShapePrimitives.Length > 0
+                                && distanceLevel.SubObjects[0].ShapePrimitives[0].Hierarchy.Length > 0)
+                            {
+                                distanceLevel.SubObjects[0].ShapePrimitives[0].Hierarchy[0] = distanceLevel.SubObjects[0].ShapePrimitives[0].Hierarchy.Length;
+                            }
+                        }
+                    }
+
+                }
+            }
+        }
+
+        public ContainerViewer(Viewer viewer, Container container)
+        {
+            Container = container;
+            Viewer = viewer;
+            ContainerShape = new AnimatedShape(viewer, container.BaseShapeFileFolderSlash + container.ShapeFileName + '\0' + container.BaseShapeFileFolderSlash, new WorldPosition(container.WorldPosition), ShapeFlags.ShadowCaster);
+            if (ContainerShape.SharedShape.LodControls.Length > 0)
+            {
+                foreach (var lodControl in ContainerShape.SharedShape.LodControls)
+                {
+                    if (lodControl.DistanceLevels.Length > 0)
+                    {
+                        foreach (var distanceLevel in lodControl.DistanceLevels)
+                        {
+                            if (distanceLevel.SubObjects.Length > 0
+                                && distanceLevel.SubObjects[0].ShapePrimitives.Length > 0
+                                && distanceLevel.SubObjects[0].ShapePrimitives[0].Hierarchy.Length > 0)
+                            {
+                                distanceLevel.SubObjects[0].ShapePrimitives[0].Hierarchy[0] = distanceLevel.SubObjects[0].ShapePrimitives[0].Hierarchy.Length;
+                            }
+                        }
+                    }
+                }
+            }
+/*            if (ContainerShape.XNAMatrices.Length > 0 && animation is FreightAnimationDiscrete && (animation as FreightAnimationDiscrete).Flipped)
+            {
+                var flipper = Matrix.Identity;
+                flipper.M11 = -1;
+                flipper.M33 = -1;
+                ContainerShape.XNAMatrices[0] *= flipper;
+            }*/
+        }
+
+        public void Mark()
+        {
+            ContainerShape.Mark();
+        }
+
+        public void PrepareFrame(RenderFrame frame, ElapsedTime elapsedTime)
+        {
+            ContainerShape.Location.TileX = Container.WorldPosition.TileX;
+            ContainerShape.Location.TileZ = Container.WorldPosition.TileZ;
+            ContainerShape.Location.XNAMatrix = Container.WorldPosition.XNAMatrix;
+            ContainerShape.PrepareFrame(frame, elapsedTime);
+        }
+    }
+}
diff --git a/Source/RunActivity/Viewer3D/Scenery.cs b/Source/RunActivity/Viewer3D/Scenery.cs
index 4b93bd923..52a5e8e95 100644
--- a/Source/RunActivity/Viewer3D/Scenery.cs
+++ b/Source/RunActivity/Viewer3D/Scenery.cs
@@ -46,6 +46,7 @@
 using Orts.Formats.Msts;
 using Orts.Formats.OR;
 using ORTS.Common;
+using Orts.Simulation.RollingStocks;
 using System;
 using System.Collections.Generic;
 using System.Diagnostics;
@@ -295,7 +296,7 @@ public WorldFile(Viewer viewer, int tileX, int tileZ, bool visible)
             if (File.Exists(WFilePath))
             {
                 // We have an OR-specific addition to world file
-                WFile.InsertORSpecificData(WFilePath);
+                WFile.InsertORSpecificData(WFilePath, null);
             }
 
 
@@ -396,7 +397,7 @@ public WorldFile(Viewer viewer, int tileX, int tileZ, bool visible)
                             else
                             {
                                 var found = false;
-                                foreach (var movingTable in Program.Simulator.MovingTables)
+                                foreach (var movingTable in Program.Simulator.            MovingTables)
                                 {
                                     if (worldObject.UID == movingTable.UID && WFileName == movingTable.WFile)
                                     {
@@ -511,6 +512,11 @@ public WorldFile(Viewer viewer, int tileX, int tileZ, bool visible)
                     }
                     else if (worldObject.GetType() == typeof(PickupObj))
                     {
+                        if ((worldObject as PickupObj).PickupType == (uint)(MSTSWagon.PickupType.Container))
+                        {
+                            sceneryObjects.Add(new ContainerHandlingItemShape(viewer, shapeFilePath, worldMatrix, shadowCaster ? ShapeFlags.ShadowCaster : ShapeFlags.None, (PickupObj)worldObject));
+                        }
+                        else
                         sceneryObjects.Add(new FuelPickupItemShape(viewer, shapeFilePath, worldMatrix, shadowCaster ? ShapeFlags.ShadowCaster : ShapeFlags.None, (PickupObj)worldObject));
                         PickupList.Add((PickupObj)worldObject);
                     }
diff --git a/Source/RunActivity/Viewer3D/Shapes.cs b/Source/RunActivity/Viewer3D/Shapes.cs
index d1bc84b1e..7b40d24e2 100644
--- a/Source/RunActivity/Viewer3D/Shapes.cs
+++ b/Source/RunActivity/Viewer3D/Shapes.cs
@@ -1023,36 +1023,42 @@ public override void PrepareFrame(RenderFrame frame, ElapsedTime elapsedTime)
 
     public class FuelPickupItemShape : PoseableShape
     {
-        readonly PickupObj FuelPickupItemObj;
-        readonly FuelPickupItem FuelPickupItem;
-        readonly SoundSource Sound;
-        readonly float FrameRate;
-
-        readonly int AnimationFrames;
+        protected PickupObj FuelPickupItemObj;
+        protected FuelPickupItem FuelPickupItem;
+        protected SoundSource Sound;
+        protected float FrameRate;
+        protected Viewer Viewer;
+        protected WorldPosition Position;
+
+        protected int AnimationFrames;
         protected float AnimationKey;
 
-
         public FuelPickupItemShape(Viewer viewer, string path, WorldPosition position, ShapeFlags shapeFlags, PickupObj fuelpickupitemObj)
             : base(viewer, path, position, shapeFlags)
         {
             FuelPickupItemObj = fuelpickupitemObj;
+            Viewer = viewer;
+            Position = position;
+            Initialize();
+        }
 
-
-            if (viewer.Simulator.TRK.Tr_RouteFile.DefaultDieselTowerSMS != null && FuelPickupItemObj.PickupType == 7) // Testing for Diesel PickupType
+        public virtual void Initialize()
+        {
+            if (Viewer.Simulator.TRK.Tr_RouteFile.DefaultDieselTowerSMS != null && FuelPickupItemObj.PickupType == 7) // Testing for Diesel PickupType
             {
-                var soundPath = viewer.Simulator.RoutePath + @"\\sound\\" + viewer.Simulator.TRK.Tr_RouteFile.DefaultDieselTowerSMS;
+                var soundPath = Viewer.Simulator.RoutePath + @"\\sound\\" + Viewer.Simulator.TRK.Tr_RouteFile.DefaultDieselTowerSMS;
                 try
                 {
-                    Sound = new SoundSource(viewer, position.WorldLocation, Events.Source.MSTSFuelTower, soundPath);
-                    viewer.SoundProcess.AddSoundSources(this, new List<SoundSourceBase>() { Sound });
+                    Sound = new SoundSource(Viewer, Position.WorldLocation, Events.Source.MSTSFuelTower, soundPath);
+                    Viewer.SoundProcess.AddSoundSources(this, new List<SoundSourceBase>() { Sound });
                 }
                 catch
                 {
-                    soundPath = viewer.Simulator.BasePath + @"\\sound\\" + viewer.Simulator.TRK.Tr_RouteFile.DefaultDieselTowerSMS;
+                    soundPath = Viewer.Simulator.BasePath + @"\\sound\\" + Viewer.Simulator.TRK.Tr_RouteFile.DefaultDieselTowerSMS;
                     try
                     {
-                        Sound = new SoundSource(viewer, position.WorldLocation, Events.Source.MSTSFuelTower, soundPath);
-                        viewer.SoundProcess.AddSoundSources(this, new List<SoundSourceBase>() { Sound });
+                        Sound = new SoundSource(Viewer, Position.WorldLocation, Events.Source.MSTSFuelTower, soundPath);
+                        Viewer.SoundProcess.AddSoundSources(this, new List<SoundSourceBase>() { Sound });
                     }
                     catch (Exception error)
                     {
@@ -1060,21 +1066,21 @@ public FuelPickupItemShape(Viewer viewer, string path, WorldPosition position, S
                     }
                 }
             }
-            if (viewer.Simulator.TRK.Tr_RouteFile.DefaultWaterTowerSMS != null && FuelPickupItemObj.PickupType == 5) // Testing for Water PickupType
+            if (Viewer.Simulator.TRK.Tr_RouteFile.DefaultWaterTowerSMS != null && FuelPickupItemObj.PickupType == 5) // Testing for Water PickupType
             {
-                var soundPath = viewer.Simulator.RoutePath + @"\\sound\\" + viewer.Simulator.TRK.Tr_RouteFile.DefaultWaterTowerSMS;
+                var soundPath = Viewer.Simulator.RoutePath + @"\\sound\\" + Viewer.Simulator.TRK.Tr_RouteFile.DefaultWaterTowerSMS;
                 try
                 {
-                    Sound = new SoundSource(viewer, position.WorldLocation, Events.Source.MSTSFuelTower, soundPath);
-                    viewer.SoundProcess.AddSoundSources(this, new List<SoundSourceBase>() { Sound });
+                    Sound = new SoundSource(Viewer, Position.WorldLocation, Events.Source.MSTSFuelTower, soundPath);
+                    Viewer.SoundProcess.AddSoundSources(this, new List<SoundSourceBase>() { Sound });
                 }
                 catch
                 {
-                    soundPath = viewer.Simulator.BasePath + @"\\sound\\" + viewer.Simulator.TRK.Tr_RouteFile.DefaultWaterTowerSMS;
+                    soundPath = Viewer.Simulator.BasePath + @"\\sound\\" + Viewer.Simulator.TRK.Tr_RouteFile.DefaultWaterTowerSMS;
                     try
                     {
-                        Sound = new SoundSource(viewer, position.WorldLocation, Events.Source.MSTSFuelTower, soundPath);
-                        viewer.SoundProcess.AddSoundSources(this, new List<SoundSourceBase>() { Sound });
+                        Sound = new SoundSource(Viewer, Position.WorldLocation, Events.Source.MSTSFuelTower, soundPath);
+                        Viewer.SoundProcess.AddSoundSources(this, new List<SoundSourceBase>() { Sound });
                     }
                     catch (Exception error)
                     {
@@ -1082,21 +1088,21 @@ public FuelPickupItemShape(Viewer viewer, string path, WorldPosition position, S
                     }
                 }
             }
-            if (viewer.Simulator.TRK.Tr_RouteFile.DefaultCoalTowerSMS != null && (FuelPickupItemObj.PickupType == 6 || FuelPickupItemObj.PickupType == 2))
+            if (Viewer.Simulator.TRK.Tr_RouteFile.DefaultCoalTowerSMS != null && (FuelPickupItemObj.PickupType == 6 || FuelPickupItemObj.PickupType == 2))
             {
-                var soundPath = viewer.Simulator.RoutePath + @"\\sound\\" + viewer.Simulator.TRK.Tr_RouteFile.DefaultCoalTowerSMS;
+                var soundPath = Viewer.Simulator.RoutePath + @"\\sound\\" + Viewer.Simulator.TRK.Tr_RouteFile.DefaultCoalTowerSMS;
                 try
                 {
-                    Sound = new SoundSource(viewer, position.WorldLocation, Events.Source.MSTSFuelTower, soundPath);
-                    viewer.SoundProcess.AddSoundSources(this, new List<SoundSourceBase>() { Sound });
+                    Sound = new SoundSource(Viewer, Position.WorldLocation, Events.Source.MSTSFuelTower, soundPath);
+                    Viewer.SoundProcess.AddSoundSources(this, new List<SoundSourceBase>() { Sound });
                 }
                 catch
                 {
-                    soundPath = viewer.Simulator.BasePath + @"\\sound\\" + viewer.Simulator.TRK.Tr_RouteFile.DefaultCoalTowerSMS;
+                    soundPath = Viewer.Simulator.BasePath + @"\\sound\\" + Viewer.Simulator.TRK.Tr_RouteFile.DefaultCoalTowerSMS;
                     try
                     {
-                        Sound = new SoundSource(viewer, position.WorldLocation, Events.Source.MSTSFuelTower, soundPath);
-                        viewer.SoundProcess.AddSoundSources(this, new List<SoundSourceBase>() { Sound });
+                        Sound = new SoundSource(Viewer, Position.WorldLocation, Events.Source.MSTSFuelTower, soundPath);
+                        Viewer.SoundProcess.AddSoundSources(this, new List<SoundSourceBase>() { Sound });
                     }
                     catch (Exception error)
                     {
@@ -1104,7 +1110,7 @@ public FuelPickupItemShape(Viewer viewer, string path, WorldPosition position, S
                     }
                 }
             }
-            FuelPickupItem = viewer.Simulator.FuelManager.CreateFuelStation(position, from tid in FuelPickupItemObj.TrItemIDList where tid.db == 0 select tid.dbID);
+            FuelPickupItem = Viewer.Simulator.FuelManager.CreateFuelStation(Position, from tid in FuelPickupItemObj.TrItemIDList where tid.db == 0 select tid.dbID);
             AnimationFrames = 1;
             FrameRate = 1;
             if (SharedShape.Animations != null && SharedShape.Animations.Count > 0 && SharedShape.Animations[0].anim_nodes != null && SharedShape.Animations[0].anim_nodes.Count > 0)
@@ -1168,1077 +1174,1430 @@ public override void PrepareFrame(RenderFrame frame, ElapsedTime elapsedTime)
         }
     } // End Class FuelPickupItemShape
 
-    public class RoadCarShape : AnimatedShape
+    public class ContainerHandlingItemShape : FuelPickupItemShape
     {
-        public RoadCarShape(Viewer viewer, string path)
-            : base(viewer, path, new WorldPosition(), ShapeFlags.ShadowCaster)
+        protected float AnimationKeyX;
+        protected float AnimationKeyY;
+        protected float AnimationKeyZ;
+        protected float AnimationKeyGrabber01;
+        protected float AnimationKeyGrabber02;
+        protected int IAnimationMatrixX;
+        protected int IAnimationMatrixY;
+        protected int IAnimationMatrixZ;
+        protected int IGrabber01;
+        protected int IGrabber02;
+        protected controller controllerX;
+        protected controller controllerY;
+        protected controller controllerZ;
+        protected controller controllerGrabber01;
+        protected controller controllerGrabber02;
+        protected float slowDownThreshold = 0.03f;
+        protected SoundSource Sound;
+        // To detect transitions that trigger sounds
+        protected bool OldMoveX;
+        protected bool OldMoveY;
+        protected bool OldMoveZ;
+            
+
+        protected ContainerHandlingItem ContainerHandlingItem;
+        public ContainerHandlingItemShape(Viewer viewer, string path, WorldPosition position, ShapeFlags shapeFlags, PickupObj fuelpickupitemObj)
+                        : base(viewer, path, position, shapeFlags, fuelpickupitemObj)
+        {
+        }
+
+        public override void Initialize()
         {
-        }
-    }
-
-    public class TurntableShape : PoseableShape
-    {
-        protected float AnimationKey;  // advances with time
-        protected Turntable Turntable; // linked turntable data
-        readonly SoundSource Sound;
-        bool Rotating = false;
-        protected int IAnimationMatrix = -1; // index of animation matrix
-
-        /// <summary>
-        /// Construct and initialize the class
-        /// </summary>
-        public TurntableShape(Viewer viewer, string path, WorldPosition initialPosition, ShapeFlags flags, Turntable turntable, double startingY)
-            : base(viewer, path, initialPosition, flags)
-        {
-            Turntable = turntable;
-            Turntable.StartingY = (float)startingY;
-            Turntable.TurntableFrameRate = SharedShape.Animations[0].FrameRate;
-            AnimationKey = (Turntable.YAngle / (float)Math.PI * 1800.0f + 3600) % 3600.0f;
             for (var imatrix = 0; imatrix < SharedShape.Matrices.Length; ++imatrix)
             {
-                if (SharedShape.MatrixNames[imatrix].ToLower() == turntable.Animations[0].ToLower())
-                {
-                    IAnimationMatrix = imatrix;
-                    break;
-                }
-            }
-            if (viewer.Simulator.TRK.Tr_RouteFile.DefaultTurntableSMS != null)
-            {
-                var soundPath = viewer.Simulator.RoutePath + @"\\sound\\" + viewer.Simulator.TRK.Tr_RouteFile.DefaultTurntableSMS;
+                if (SharedShape.MatrixNames[imatrix].ToLower() == "zaxis")
+                    IAnimationMatrixZ = imatrix;
+                else if (SharedShape.MatrixNames[imatrix].ToLower() == "xaxis")
+                    IAnimationMatrixX = imatrix;
+                else if (SharedShape.MatrixNames[imatrix].ToLower() == "yaxis")
+                    IAnimationMatrixY = imatrix;
+                else if (SharedShape.MatrixNames[imatrix].ToLower() == "grabber01")
+                    IGrabber01 = imatrix;
+                else if (SharedShape.MatrixNames[imatrix].ToLower() == "grabber02")
+                    IGrabber02 = imatrix;
+            }
+            
+            controllerX = SharedShape.Animations[0].anim_nodes[IAnimationMatrixX].controllers[0];
+            controllerY = SharedShape.Animations[0].anim_nodes[IAnimationMatrixY].controllers[0];
+            controllerZ = SharedShape.Animations[0].anim_nodes[IAnimationMatrixZ].controllers[0];
+            controllerGrabber01 = SharedShape.Animations[0].anim_nodes[IGrabber01].controllers[0];
+            controllerGrabber02 = SharedShape.Animations[0].anim_nodes[IGrabber02].controllers[0];
+            AnimationKeyX = Math.Abs((0 - ((linear_key)controllerX[0]).X) / (((linear_key)controllerX[1]).X - ((linear_key)controllerX[0]).X)) * controllerX[1].Frame;
+            AnimationKeyY = Math.Abs((0 - ((linear_key)controllerY[0]).Y) / (((linear_key)controllerY[1]).Y - ((linear_key)controllerY[0]).Y)) * controllerY[1].Frame;
+            AnimationKeyZ = Math.Abs((0 - ((linear_key)controllerZ[0]).Z) / (((linear_key)controllerZ[1]).Z - ((linear_key)controllerZ[0]).Z)) * controllerZ[1].Frame;
+            if (FuelPickupItemObj.CraneSound != null)
+            {
+                var soundPath = Viewer.Simulator.RoutePath + @"\\sound\\" + FuelPickupItemObj.CraneSound;
                 try
                 {
-                    Sound = new SoundSource(viewer, initialPosition.WorldLocation, Events.Source.ORTSTurntable, soundPath);
-                    viewer.SoundProcess.AddSoundSources(this, new List<SoundSourceBase>() { Sound });
+                    Sound = new SoundSource(Viewer, Position.WorldLocation, Events.Source.ORTSContainerCrane, soundPath);
+                    Viewer.SoundProcess.AddSoundSources(this, new List<SoundSourceBase>() { Sound });
                 }
                 catch
                 {
-                    soundPath = viewer.Simulator.BasePath + @"\\sound\\" + viewer.Simulator.TRK.Tr_RouteFile.DefaultTurntableSMS;
+                    soundPath = Viewer.Simulator.BasePath + @"\\sound\\containercrane.sms";
                     try
                     {
-                        Sound = new SoundSource(viewer, initialPosition.WorldLocation, Events.Source.ORTSTurntable, soundPath);
-                        viewer.SoundProcess.AddSoundSources(this, new List<SoundSourceBase>() { Sound });
+                        Sound = new SoundSource(Viewer, Position.WorldLocation, Events.Source.ORTSContainerCrane, soundPath);
+                        Viewer.SoundProcess.AddSoundSources(this, new List<SoundSourceBase>() { Sound });
                     }
-                    catch (Exception error)
+                    catch
                     {
-                        Trace.WriteLine(new FileLoadException(soundPath, error));
+                        Trace.TraceWarning("Cannot find sound file {0}", soundPath);
                     }
                 }
             }
-            for (var matrix = 0; matrix < SharedShape.Matrices.Length; ++matrix)
-                AnimateMatrix(matrix, AnimationKey);
-
-            var absAnimationMatrix = XNAMatrices[IAnimationMatrix];
-            Matrix.Multiply(ref absAnimationMatrix, ref Location.XNAMatrix, out absAnimationMatrix);
-            Turntable.ReInitTrainPositions(absAnimationMatrix);
-        }
-
-        public override void PrepareFrame(RenderFrame frame, ElapsedTime elapsedTime)
-        {
-            float nextKey;
-            var animation = SharedShape.Animations[0];
-            if (Turntable.GoToTarget || Turntable.GoToAutoTarget)
-            {
-                nextKey = Turntable.TargetY / (2 * (float)Math.PI) * animation.FrameCount;
-            }
             else
             {
-                float moveFrames;
-                if (Turntable.Counterclockwise)
-                    moveFrames = animation.FrameRate * elapsedTime.ClockSeconds;
-                else if (Turntable.Clockwise)
-                    moveFrames = -animation.FrameRate * elapsedTime.ClockSeconds;
-                else
-                    moveFrames = 0;
-                nextKey = AnimationKey + moveFrames;
-            }
-            AnimationKey = nextKey % animation.FrameCount;
-            if (AnimationKey < 0)
-                AnimationKey += animation.FrameCount;
-            Turntable.YAngle = MathHelper.WrapAngle(nextKey / animation.FrameCount * 2 * (float)Math.PI);
-
-            if ((Turntable.Clockwise || Turntable.Counterclockwise || Turntable.AutoClockwise || Turntable.AutoCounterclockwise) && !Rotating)
-            {
-                Rotating = true;
-                if (Sound != null) Sound.HandleEvent(Turntable.TrainsOnMovingTable.Count == 1 &&
-                    Turntable.TrainsOnMovingTable[0].FrontOnBoard && Turntable.TrainsOnMovingTable[0].BackOnBoard ? Event.MovingTableMovingLoaded : Event.MovingTableMovingEmpty);
+                var soundPath = Viewer.Simulator.BasePath + @"\\sound\\containercrane.sms";
+                try
+                {
+                    Sound = new SoundSource(Viewer, Position.WorldLocation, Events.Source.ORTSContainerCrane, soundPath);
+                    Viewer.SoundProcess.AddSoundSources(this, new List<SoundSourceBase>() { Sound });
+                }
+                catch
+                {
+                    Trace.TraceWarning("Cannot find sound file {0}", soundPath);
+                }
             }
-            else if ((!Turntable.Clockwise && !Turntable.Counterclockwise && !Turntable.AutoClockwise && !Turntable.AutoCounterclockwise && Rotating))
+            ContainerHandlingItem = Viewer.Simulator.ContainerManager.ContainerHandlingItems[FuelPickupItemObj.TrItemIDList[0].dbID];
+            AnimationFrames = 1;
+            FrameRate = 1;
+            if (SharedShape.Animations != null && SharedShape.Animations.Count > 0 && SharedShape.Animations[0].anim_nodes != null && SharedShape.Animations[0].anim_nodes.Count > 0)
             {
-                Rotating = false;
-                if (Sound != null) Sound.HandleEvent(Event.MovingTableStopped);
+                FrameRate = SharedShape.Animations[0].FrameCount / FuelPickupItemObj.PickupAnimData.AnimationSpeed;
+                foreach (var anim_node in SharedShape.Animations[0].anim_nodes)
+                    if (anim_node.Name == "ANIMATED_PARTS")
+                    {
+                        AnimationFrames = SharedShape.Animations[0].FrameCount;
+                        break;
+                    }
             }
+            AnimateOneMatrix(IAnimationMatrixX, AnimationKeyX);
+            AnimateOneMatrix(IAnimationMatrixY, AnimationKeyY);
+            AnimateOneMatrix(IAnimationMatrixZ, AnimationKeyZ);
 
-            // Update the pose for each matrix
-            for (var matrix = 0; matrix < SharedShape.Matrices.Length; ++matrix)
-                AnimateMatrix(matrix, AnimationKey);
-
-            var absAnimationMatrix = XNAMatrices[IAnimationMatrix];
+            var absAnimationMatrix = XNAMatrices[IAnimationMatrixY];
+            Matrix.Multiply(ref absAnimationMatrix, ref XNAMatrices[IAnimationMatrixX], out absAnimationMatrix);
+            Matrix.Multiply(ref absAnimationMatrix, ref XNAMatrices[IAnimationMatrixZ], out absAnimationMatrix);
             Matrix.Multiply(ref absAnimationMatrix, ref Location.XNAMatrix, out absAnimationMatrix);
-            Turntable.PerformUpdateActions(absAnimationMatrix);
-            SharedShape.PrepareFrame(frame, Location, XNAMatrices, Flags);
+            ContainerHandlingItem.PassSpanParameters(((linear_key)controllerZ[0]).Z, ((linear_key)controllerZ[1]).Z,
+                ((linear_key)controllerGrabber01[0]).Z, ((linear_key)controllerGrabber02[0]).Z);
+            ContainerHandlingItem.ReInitPositionOffset(absAnimationMatrix);
+
+            AnimationKeyX = Math.Abs((ContainerHandlingItem.PickingSurfaceRelativeTopStartPosition.X - ((linear_key)controllerX[0]).X) / (((linear_key)controllerX[1]).X - ((linear_key)controllerX[0]).X)) * controllerX[1].Frame;
+            AnimationKeyY = Math.Abs((ContainerHandlingItem.PickingSurfaceRelativeTopStartPosition.Y - ((linear_key)controllerY[0]).Y) / (((linear_key)controllerY[1]).Y - ((linear_key)controllerY[0]).Y)) * controllerY[1].Frame;
+            AnimationKeyZ = Math.Abs((ContainerHandlingItem.PickingSurfaceRelativeTopStartPosition.Z - ((linear_key)controllerZ[0]).Z) / (((linear_key)controllerZ[1]).Z - ((linear_key)controllerZ[0]).Z)) * controllerZ[1].Frame;
+            AnimateOneMatrix(IAnimationMatrixX, AnimationKeyX);
+            AnimateOneMatrix(IAnimationMatrixY, AnimationKeyY);
+            AnimateOneMatrix(IAnimationMatrixZ, AnimationKeyZ);
+            for (var imatrix = 0; imatrix < SharedShape.Matrices.Length; ++imatrix)
+            {
+                if (SharedShape.MatrixNames[imatrix].ToLower().StartsWith("cable"))
+                    AnimateOneMatrix(imatrix, AnimationKeyY);
+                if (SharedShape.MatrixNames[imatrix].ToLower().StartsWith("grabber"))
+                    AnimateOneMatrix(imatrix, 0);
+            }
         }
-    }
-
-    public class TransfertableShape : PoseableShape
-    {
-        protected float AnimationKey;  // advances with time
-        protected Transfertable Transfertable; // linked turntable data
-        readonly SoundSource Sound;
-        bool Translating = false;
-        protected int IAnimationMatrix = -1; // index of animation matrix
 
-        /// <summary>
-        /// Construct and initialize the class
-        /// </summary>
-        public TransfertableShape(Viewer viewer, string path, WorldPosition initialPosition, ShapeFlags flags, Transfertable transfertable)
-            : base(viewer, path, initialPosition, flags)
+        public override void PrepareFrame(RenderFrame frame, ElapsedTime elapsedTime)
         {
-            Transfertable = transfertable;
-            AnimationKey = (Transfertable.OffsetPos - Transfertable.CenterOffsetComponent) / Transfertable.Span * SharedShape.Animations[0].FrameCount;
-            for (var imatrix = 0; imatrix < SharedShape.Matrices.Length; ++imatrix)
-            {
-                if (SharedShape.MatrixNames[imatrix].ToLower() == transfertable.Animations[0].ToLower())
+
+            // 0 can be used as a setting for instant animation.
+            /*           if (ContainerHandlingItem.ReFill() && FuelPickupItemObj.UID == MSTSWagon.RefillProcess.ActivePickupObjectUID)
+                       {
+                           if (AnimationKey == 0 && Sound != null) Sound.HandleEvent(Event.FuelTowerDown);
+                           if (FuelPickupItemObj.PickupAnimData.AnimationSpeed == 0) AnimationKey = 1.0f;
+                           else if (AnimationKey < AnimationFrames)
+                               AnimationKey += elapsedTime.ClockSeconds * FrameRate;
+                       }
+
+                       if (!ContainerHandlingItem.ReFill() && AnimationKey > 0)
+                       {
+                           if (AnimationKey == AnimationFrames && Sound != null)
+                           {
+                               Sound.HandleEvent(Event.FuelTowerTransferEnd);
+                               Sound.HandleEvent(Event.FuelTowerUp);
+                           }
+                           AnimationKey -= elapsedTime.ClockSeconds * FrameRate;
+                       }
+
+                       if (AnimationKey < 0)
+                       {
+                           AnimationKey = 0;
+                       }
+                       if (AnimationKey > AnimationFrames)
+                       {
+                           AnimationKey = AnimationFrames;
+                           if (Sound != null) Sound.HandleEvent(Event.FuelTowerTransferStart);
+                       }
+
+                       for (var i = 0; i < SharedShape.Matrices.Length; ++i)
+                           AnimateMatrix(i, AnimationKey);
+            */
+            if (FuelPickupItemObj.UID == MSTSWagon.RefillProcess.ActivePickupObjectUID)
+            {
+                float tempFrameRate;
+                if (ContainerHandlingItem.MoveX)
                 {
-                    IAnimationMatrix = imatrix;
-                    break;
+                    var animationTarget = Math.Abs((ContainerHandlingItem.TargetX - ((linear_key)controllerX[0]).X) / (((linear_key)controllerX[1]).X - ((linear_key)controllerX[0]).X)) * controllerX[1].Frame;
+                    //                    if (AnimationKey == 0 && Sound != null) Sound.HandleEvent(Event.FuelTowerDown);
+                    tempFrameRate = Math.Abs(AnimationKeyX - animationTarget) > slowDownThreshold ? FrameRate : FrameRate / 4;
+                    if (AnimationKeyX < animationTarget)
+                    {
+                        AnimationKeyX += elapsedTime.ClockSeconds * tempFrameRate;
+                        // don't oscillate!
+                        if (AnimationKeyX >= animationTarget)
+                        {
+                            AnimationKeyX = animationTarget;
+                            ContainerHandlingItem.MoveX = false;
+                        }
+                    }
+                    else if (AnimationKeyX > animationTarget)
+                    {
+                        AnimationKeyX -= elapsedTime.ClockSeconds * tempFrameRate;
+                        if (AnimationKeyX <= animationTarget)
+                        {
+                            AnimationKeyX = animationTarget;
+                            ContainerHandlingItem.MoveX = false;
+                        }
+                    }
+                    else
+                        ContainerHandlingItem.MoveX = false;
+                    if (AnimationKeyX < 0)
+                        AnimationKeyX = 0;
                 }
-            }
-            if (viewer.Simulator.TRK.Tr_RouteFile.DefaultTurntableSMS != null)
-            {
-                var soundPath = viewer.Simulator.RoutePath + @"\\sound\\" + viewer.Simulator.TRK.Tr_RouteFile.DefaultTurntableSMS;
-                try
+
+                if (ContainerHandlingItem.MoveY)
                 {
-                    Sound = new SoundSource(viewer, initialPosition.WorldLocation, Events.Source.ORTSTurntable, soundPath);
-                    viewer.SoundProcess.AddSoundSources(this, new List<SoundSourceBase>() { Sound });
+                    var animationTarget = Math.Abs((ContainerHandlingItem.TargetY - ((linear_key)controllerY[0]).Y) / (((linear_key)controllerY[1]).Y - ((linear_key)controllerY[0]).Y)) * controllerY[1].Frame;
+                    tempFrameRate = Math.Abs(AnimationKeyY - animationTarget) > slowDownThreshold ? FrameRate : FrameRate / 4;
+                    if (AnimationKeyY < animationTarget)
+                    {
+                        AnimationKeyY += elapsedTime.ClockSeconds * tempFrameRate;
+                        if (AnimationKeyY >= animationTarget)
+                        {
+                            AnimationKeyY = animationTarget;
+                            ContainerHandlingItem.MoveY = false;
+                        }
+                    }
+                    else if (AnimationKeyY > animationTarget)
+                    {
+                        AnimationKeyY -= elapsedTime.ClockSeconds * tempFrameRate;
+                        if (AnimationKeyY <= animationTarget)
+                        {
+                            AnimationKeyY = animationTarget;
+                            ContainerHandlingItem.MoveY = false;
+                        }
+                    }
+                    else
+                        ContainerHandlingItem.MoveY = false;
+                    if (AnimationKeyY < 0)
+                        AnimationKeyY = 0;
                 }
-                catch
+
+                if (ContainerHandlingItem.MoveZ)
                 {
-                    soundPath = viewer.Simulator.BasePath + @"\\sound\\" + viewer.Simulator.TRK.Tr_RouteFile.DefaultTurntableSMS;
-                    try
+                    var animationTarget = Math.Abs((ContainerHandlingItem.TargetZ - ((linear_key)controllerZ[0]).Z) / (((linear_key)controllerZ[1]).Z - ((linear_key)controllerZ[0]).Z)) * controllerZ[1].Frame;
+                    tempFrameRate = Math.Abs(AnimationKeyZ - animationTarget) > slowDownThreshold ? FrameRate : FrameRate / 4;
+                    if (AnimationKeyZ < animationTarget)
                     {
-                        Sound = new SoundSource(viewer, initialPosition.WorldLocation, Events.Source.ORTSTurntable, soundPath);
-                        viewer.SoundProcess.AddSoundSources(this, new List<SoundSourceBase>() { Sound });
+                        AnimationKeyZ += elapsedTime.ClockSeconds * tempFrameRate;
+                        if (AnimationKeyZ >= animationTarget)
+                        {
+                            AnimationKeyZ = animationTarget;
+                            ContainerHandlingItem.MoveZ = false;
+                        }
                     }
-                    catch (Exception error)
+                    else if (AnimationKeyZ > animationTarget)
                     {
-                        Trace.WriteLine(new FileLoadException(soundPath, error));
+                        AnimationKeyZ -= elapsedTime.ClockSeconds * tempFrameRate;
+                        if (AnimationKeyZ <= animationTarget)
+                        {
+                            AnimationKeyZ = animationTarget;
+                            ContainerHandlingItem.MoveZ = false;
+                        }
                     }
+                    else
+                        ContainerHandlingItem.MoveZ = false;
+                    if (AnimationKeyZ < 0)
+                        AnimationKeyZ = 0;
                 }
-            }
-            for (var matrix = 0; matrix < SharedShape.Matrices.Length; ++matrix)
-                AnimateMatrix(matrix, AnimationKey);
 
-            var absAnimationMatrix = XNAMatrices[IAnimationMatrix];
-            Matrix.Multiply(ref absAnimationMatrix, ref Location.XNAMatrix, out absAnimationMatrix);
-            Transfertable.ReInitTrainPositions(absAnimationMatrix);
-        }
-
-        public override void PrepareFrame(RenderFrame frame, ElapsedTime elapsedTime)
-        {
-            if (Transfertable.GoToTarget)
-            {
-                AnimationKey = (Transfertable.TargetOffset - Transfertable.CenterOffsetComponent) / Transfertable.Span * SharedShape.Animations[0].FrameCount;
-            }
-
-            else if (Transfertable.Forward)
-            {
-                AnimationKey += SharedShape.Animations[0].FrameRate * elapsedTime.ClockSeconds;
-            }
-            else if (Transfertable.Reverse)
-            {
-                AnimationKey -= SharedShape.Animations[0].FrameRate * elapsedTime.ClockSeconds;
+                if (ContainerHandlingItem.MoveGrabber)
+                {
+                    var animationTarget = Math.Abs((ContainerHandlingItem.TargetGrabber01 - ((linear_key)controllerGrabber01[0]).Z) / (((linear_key)controllerGrabber01[1]).Z - ((linear_key)controllerGrabber01[0]).Z)) * controllerGrabber01[1].Frame;
+                    tempFrameRate = Math.Abs(AnimationKeyGrabber01 - animationTarget) > slowDownThreshold ? FrameRate : FrameRate / 4;
+                    if (AnimationKeyGrabber01 < animationTarget)
+                    {
+                        AnimationKeyGrabber01 += elapsedTime.ClockSeconds * tempFrameRate;
+                        if (AnimationKeyGrabber01 >= animationTarget)
+                        {
+                            AnimationKeyGrabber01 = animationTarget;
+                        }
+                    }
+                    else if (AnimationKeyGrabber01 > animationTarget)
+                    {
+                        AnimationKeyGrabber01 -= elapsedTime.ClockSeconds * tempFrameRate;
+                        if (AnimationKeyGrabber01 <= animationTarget)
+                        {
+                            AnimationKeyGrabber01 = animationTarget;
+                        }
+                    }
+                    if (AnimationKeyGrabber01 < 0)
+                        AnimationKeyGrabber01 = 0;
+                    var animationTarget2 = Math.Abs((ContainerHandlingItem.TargetGrabber02 - ((linear_key)controllerGrabber02[0]).Z) / (((linear_key)controllerGrabber02[1]).Z - ((linear_key)controllerGrabber02[0]).Z)) * controllerGrabber02[1].Frame;
+                    tempFrameRate = Math.Abs(AnimationKeyGrabber01 - animationTarget2) > slowDownThreshold ? FrameRate : FrameRate / 4;
+                    if (AnimationKeyGrabber02 < animationTarget2)
+                    {
+                        AnimationKeyGrabber02 += elapsedTime.ClockSeconds * tempFrameRate;
+                        if (AnimationKeyGrabber02 >= animationTarget2)
+                        {
+                            AnimationKeyGrabber02 = animationTarget2;
+                        }
+                    }
+                    else if (AnimationKeyGrabber02 > animationTarget2)
+                    {
+                        AnimationKeyGrabber02 -= elapsedTime.ClockSeconds * tempFrameRate;
+                        if (AnimationKeyGrabber02 <= animationTarget2)
+                        {
+                            AnimationKeyGrabber02 = animationTarget2;
+                        }
+                    }
+                    if (animationTarget == AnimationKeyGrabber01 && animationTarget2 == AnimationKeyGrabber02)
+                        ContainerHandlingItem.MoveGrabber = false;
+                    if (AnimationKeyGrabber02 < 0)
+                        AnimationKeyGrabber02 = 0;
+                }
             }
-            if (AnimationKey > SharedShape.Animations[0].FrameCount) AnimationKey = SharedShape.Animations[0].FrameCount;
-            if (AnimationKey < 0) AnimationKey = 0;
+            ContainerHandlingItem.ActualX = (((linear_key)controllerX[1]).X - ((linear_key)controllerX[0]).X) * AnimationKeyX / controllerX[1].Frame + ((linear_key)controllerX[0]).X;
+            ContainerHandlingItem.ActualY = (((linear_key)controllerY[1]).Y - ((linear_key)controllerY[0]).Y) * AnimationKeyY / controllerY[1].Frame + ((linear_key)controllerY[0]).Y;
+            ContainerHandlingItem.ActualZ = (((linear_key)controllerZ[1]).Z - ((linear_key)controllerZ[0]).Z) * AnimationKeyZ / controllerZ[1].Frame + ((linear_key)controllerZ[0]).Z;
+            ContainerHandlingItem.ActualGrabber01 = (((linear_key)controllerGrabber01[1]).Z - ((linear_key)controllerGrabber01[0]).Z) * AnimationKeyGrabber01 / controllerGrabber01[1].Frame + ((linear_key)controllerGrabber01[0]).Z;
+            ContainerHandlingItem.ActualGrabber02 = (((linear_key)controllerGrabber02[1]).Z - ((linear_key)controllerGrabber02[0]).Z) * AnimationKeyGrabber02 / controllerGrabber02[1].Frame + ((linear_key)controllerGrabber02[0]).Z;
 
-            Transfertable.OffsetPos = AnimationKey / SharedShape.Animations[0].FrameCount * Transfertable.Span + Transfertable.CenterOffsetComponent;
-
-            if ((Transfertable.Forward || Transfertable.Reverse) && !Translating)
-            {
-                Translating = true;
-                if (Sound != null) Sound.HandleEvent(Transfertable.TrainsOnMovingTable.Count == 1 &&
-                    Transfertable.TrainsOnMovingTable[0].FrontOnBoard && Transfertable.TrainsOnMovingTable[0].BackOnBoard ? Event.MovingTableMovingLoaded : Event.MovingTableMovingEmpty);
-            }
-            else if ((!Transfertable.Forward && !Transfertable.Reverse && Translating))
+            AnimateOneMatrix(IAnimationMatrixX, AnimationKeyX);
+            AnimateOneMatrix(IAnimationMatrixY, AnimationKeyY);
+            AnimateOneMatrix(IAnimationMatrixZ, AnimationKeyZ);
+            for (var imatrix = 0; imatrix < SharedShape.Matrices.Length; ++imatrix)
             {
-                Translating = false;
-                if (Sound != null) Sound.HandleEvent(Event.MovingTableStopped);
+                if (SharedShape.MatrixNames[imatrix].ToLower().StartsWith("cable"))
+                    AnimateOneMatrix(imatrix, AnimationKeyY);
+                else if (SharedShape.MatrixNames[imatrix].ToLower().StartsWith("grabber01"))
+                    AnimateOneMatrix(imatrix, AnimationKeyGrabber01);
+                else if (SharedShape.MatrixNames[imatrix].ToLower().StartsWith("grabber02"))
+                    AnimateOneMatrix(imatrix, AnimationKeyGrabber02);
             }
 
-            // Update the pose for each matrix
-            for (var matrix = 0; matrix < SharedShape.Matrices.Length; ++matrix)
-                AnimateMatrix(matrix, AnimationKey);
-
-            var absAnimationMatrix = XNAMatrices[IAnimationMatrix];
-            Matrix.Multiply(ref absAnimationMatrix, ref Location.XNAMatrix, out absAnimationMatrix);
-            Transfertable.PerformUpdateActions(absAnimationMatrix, Location);
             SharedShape.PrepareFrame(frame, Location, XNAMatrices, Flags);
-        }
-    }
-
-    public class ShapePrimitive : RenderPrimitive
-    {
-        public Material Material { get; protected set; }
-        public int[] Hierarchy { get; protected set; } // the hierarchy from the sub_object
-        public int HierarchyIndex { get; protected set; } // index into the hiearchy array which provides pose for this primitive
-
-        protected internal VertexBuffer VertexBuffer;
-        protected internal IndexBuffer IndexBuffer;
-        protected internal int PrimitiveCount;
-        protected internal VertexBufferBinding[] VertexBufferBindings;
-
-        public ShapePrimitive()
-        {
-        }
-
-        public ShapePrimitive(Material material, SharedShape.VertexBufferSet vertexBufferSet, IndexBuffer indexBuffer, int primitiveCount, int[] hierarchy, int hierarchyIndex)
-        {
-            Material = material;
-            VertexBuffer = vertexBufferSet.Buffer;
-            IndexBuffer = indexBuffer;
-            PrimitiveCount = primitiveCount;
-            Hierarchy = hierarchy;
-            HierarchyIndex = hierarchyIndex;
-
-            VertexBufferBindings = new[] { new VertexBufferBinding(VertexBuffer), new VertexBufferBinding(GetDummyVertexBuffer(material.Viewer.GraphicsDevice)) };
-        }
-
-        public ShapePrimitive(Material material, SharedShape.VertexBufferSet vertexBufferSet, IList<ushort> indexData, GraphicsDevice graphicsDevice, int[] hierarchy, int hierarchyIndex)
-            : this(material, vertexBufferSet, null, indexData.Count / 3, hierarchy, hierarchyIndex)
-        {
-            IndexBuffer = new IndexBuffer(graphicsDevice, typeof(short), indexData.Count, BufferUsage.WriteOnly);
-            IndexBuffer.SetData(indexData.ToArray());
-        }
-
-        public override void Draw(GraphicsDevice graphicsDevice)
-        {
-            if (PrimitiveCount > 0)
-            {
-                // TODO consider sorting by Vertex set so we can reduce the number of SetSources required.
-                graphicsDevice.SetVertexBuffers(VertexBufferBindings);
-                graphicsDevice.Indices = IndexBuffer;
-                graphicsDevice.DrawIndexedPrimitives(PrimitiveType.TriangleList, baseVertex: 0, startIndex: 0, primitiveCount: PrimitiveCount);
-            }
-        }
-
-        [CallOnThread("Loader")]
-        public virtual void Mark()
-        {
-            Material.Mark();
-        }
-    }
-
-    /// <summary>
-    /// A <c>ShapePrimitive</c> that permits manipulation of vertex and index buffers to change geometry efficiently.
-    /// It permits also change of material
-    /// </summary>
-    public class MutableShapePrimitive : ShapePrimitive
-    {
-        /// <remarks>
-        /// Buffers cannot be expanded, so take care to properly set <paramref name="maxVertices"/> and <paramref name="maxIndices"/>,
-        /// which define the maximum sizes of the vertex and index buffers, respectively.
-        /// </remarks>
-        public MutableShapePrimitive(Material material, int maxVertices, int maxIndices, int[] hierarchy, int hierarchyIndex)
-            : base(material: material,
-                   vertexBufferSet: new SharedShape.VertexBufferSet(new VertexPositionNormalTexture[maxVertices], material.Viewer.GraphicsDevice),
-                   indexData: new ushort[maxIndices],
-                   graphicsDevice: material.Viewer.GraphicsDevice,
-                   hierarchy: hierarchy,
-                   hierarchyIndex: hierarchyIndex) { }
-
-        public void SetVertexData(VertexPositionNormalTexture[] data, int minVertexIndex, int numVertices, int primitiveCount)
-        {
-            VertexBuffer.SetData(data);
-            PrimitiveCount = primitiveCount;
-        }
-
-        public void SetIndexData(short[] data)
-        {
-            IndexBuffer.SetData(data);
-        }
-
-        public void SetMaterial(Material material)
-        {
-            Material = material;
-        }
-    }
-
-    struct ShapeInstanceData
-    {
+            if (ContainerHandlingItem.ContainerAttached)
+            {
+                var absAnimationMatrix = XNAMatrices[IAnimationMatrixY];
+                Matrix.Multiply(ref absAnimationMatrix, ref XNAMatrices[IAnimationMatrixX], out absAnimationMatrix);
+                Matrix.Multiply(ref absAnimationMatrix, ref XNAMatrices[IAnimationMatrixZ], out absAnimationMatrix);
+                Matrix.Multiply(ref absAnimationMatrix, ref Location.XNAMatrix, out absAnimationMatrix);
+                ContainerHandlingItem.TransferContainer(absAnimationMatrix);
+            }
+
+
+            // let's make some noise
+
+            if (!OldMoveX && ContainerHandlingItem.MoveX)
+                Sound?.HandleEvent(Event.CraneXAxisMove);
+            if (OldMoveX && !ContainerHandlingItem.MoveX)
+                Sound?.HandleEvent(Event.CraneXAxisSlowDown);
+            if (!OldMoveY && ContainerHandlingItem.MoveY)
+                Sound?.HandleEvent(Event.CraneYAxisMove);
+            if (OldMoveY && !ContainerHandlingItem.MoveY)
+                Sound?.HandleEvent(Event.CraneYAxisSlowDown);
+            if (!OldMoveZ && ContainerHandlingItem.MoveZ)
+                Sound?.HandleEvent(Event.CraneZAxisMove);
+            if (OldMoveZ && !ContainerHandlingItem.MoveZ)
+                Sound?.HandleEvent(Event.CraneZAxisSlowDown);
+            if (OldMoveY && !ContainerHandlingItem.MoveY && !(ContainerHandlingItem.TargetY == ContainerHandlingItem.PickingSurfaceRelativeTopStartPosition.Y))
+                Sound?.HandleEvent(Event.CraneYAxisDown);
+            OldMoveX = ContainerHandlingItem.MoveX;
+            OldMoveY = ContainerHandlingItem.MoveY;
+            OldMoveZ = ContainerHandlingItem.MoveZ;
+        }
+
+  }
+
+  public class RoadCarShape : AnimatedShape
+  {
+      public RoadCarShape(Viewer viewer, string path)
+          : base(viewer, path, new WorldPosition(), ShapeFlags.ShadowCaster)
+      {
+      }
+  }
+
+  public class TurntableShape : PoseableShape
+  {
+      protected float AnimationKey;  // advances with time
+      protected Turntable Turntable; // linked turntable data
+      readonly SoundSource Sound;
+      bool Rotating = false;
+      protected int IAnimationMatrix = -1; // index of animation matrix
+
+      /// <summary>
+      /// Construct and initialize the class
+      /// </summary>
+      public TurntableShape(Viewer viewer, string path, WorldPosition initialPosition, ShapeFlags flags, Turntable turntable, double startingY)
+          : base(viewer, path, initialPosition, flags)
+      {
+          Turntable = turntable;
+          Turntable.StartingY = (float)startingY;
+          Turntable.TurntableFrameRate = SharedShape.Animations[0].FrameRate;
+          AnimationKey = (Turntable.YAngle / (float)Math.PI * 1800.0f + 3600) % 3600.0f;
+          for (var imatrix = 0; imatrix < SharedShape.Matrices.Length; ++imatrix)
+          {
+              if (SharedShape.MatrixNames[imatrix].ToLower() == turntable.Animations[0].ToLower())
+              {
+                  IAnimationMatrix = imatrix;
+                  break;
+              }
+          }
+          if (viewer.Simulator.TRK.Tr_RouteFile.DefaultTurntableSMS != null)
+          {
+              var soundPath = viewer.Simulator.RoutePath + @"\\sound\\" + viewer.Simulator.TRK.Tr_RouteFile.DefaultTurntableSMS;
+              try
+              {
+                  Sound = new SoundSource(viewer, initialPosition.WorldLocation, Events.Source.ORTSTurntable, soundPath);
+                  viewer.SoundProcess.AddSoundSources(this, new List<SoundSourceBase>() { Sound });
+              }
+              catch
+              {
+                  soundPath = viewer.Simulator.BasePath + @"\\sound\\" + viewer.Simulator.TRK.Tr_RouteFile.DefaultTurntableSMS;
+                  try
+                  {
+                      Sound = new SoundSource(viewer, initialPosition.WorldLocation, Events.Source.ORTSTurntable, soundPath);
+                      viewer.SoundProcess.AddSoundSources(this, new List<SoundSourceBase>() { Sound });
+                  }
+                  catch (Exception error)
+                  {
+                      Trace.WriteLine(new FileLoadException(soundPath, error));
+                  }
+              }
+          }
+          for (var matrix = 0; matrix < SharedShape.Matrices.Length; ++matrix)
+              AnimateMatrix(matrix, AnimationKey);
+
+          var absAnimationMatrix = XNAMatrices[IAnimationMatrix];
+          Matrix.Multiply(ref absAnimationMatrix, ref Location.XNAMatrix, out absAnimationMatrix);
+          Turntable.ReInitTrainPositions(absAnimationMatrix);
+      }
+
+      public override void PrepareFrame(RenderFrame frame, ElapsedTime elapsedTime)
+      {
+          float nextKey;
+          var animation = SharedShape.Animations[0];
+          if (Turntable.GoToTarget || Turntable.GoToAutoTarget)
+          {
+              nextKey = Turntable.TargetY / (2 * (float)Math.PI) * animation.FrameCount;
+          }
+          else
+          {
+              float moveFrames;
+              if (Turntable.Counterclockwise)
+                  moveFrames = animation.FrameRate * elapsedTime.ClockSeconds;
+              else if (Turntable.Clockwise)
+                  moveFrames = -animation.FrameRate * elapsedTime.ClockSeconds;
+              else
+                  moveFrames = 0;
+              nextKey = AnimationKey + moveFrames;
+          }
+          AnimationKey = nextKey % animation.FrameCount;
+          if (AnimationKey < 0)
+              AnimationKey += animation.FrameCount;
+          Turntable.YAngle = MathHelper.WrapAngle(nextKey / animation.FrameCount * 2 * (float)Math.PI);
+
+          if ((Turntable.Clockwise || Turntable.Counterclockwise || Turntable.AutoClockwise || Turntable.AutoCounterclockwise) && !Rotating)
+          {
+              Rotating = true;
+              if (Sound != null) Sound.HandleEvent(Turntable.TrainsOnMovingTable.Count == 1 &&
+                  Turntable.TrainsOnMovingTable[0].FrontOnBoard && Turntable.TrainsOnMovingTable[0].BackOnBoard ? Event.MovingTableMovingLoaded : Event.MovingTableMovingEmpty);
+          }
+          else if ((!Turntable.Clockwise && !Turntable.Counterclockwise && !Turntable.AutoClockwise && !Turntable.AutoCounterclockwise && Rotating))
+          {
+              Rotating = false;
+              if (Sound != null) Sound.HandleEvent(Event.MovingTableStopped);
+          }
+
+          // Update the pose for each matrix
+          for (var matrix = 0; matrix < SharedShape.Matrices.Length; ++matrix)
+              AnimateMatrix(matrix, AnimationKey);
+
+          var absAnimationMatrix = XNAMatrices[IAnimationMatrix];
+          Matrix.Multiply(ref absAnimationMatrix, ref Location.XNAMatrix, out absAnimationMatrix);
+          Turntable.PerformUpdateActions(absAnimationMatrix);
+          SharedShape.PrepareFrame(frame, Location, XNAMatrices, Flags);
+      }
+  }
+
+  public class TransfertableShape : PoseableShape
+  {
+      protected float AnimationKey;  // advances with time
+      protected Transfertable Transfertable; // linked turntable data
+      readonly SoundSource Sound;
+      bool Translating = false;
+      protected int IAnimationMatrix = -1; // index of animation matrix
+
+      /// <summary>
+      /// Construct and initialize the class
+      /// </summary>
+      public TransfertableShape(Viewer viewer, string path, WorldPosition initialPosition, ShapeFlags flags, Transfertable transfertable)
+          : base(viewer, path, initialPosition, flags)
+      {
+          Transfertable = transfertable;
+          AnimationKey = (Transfertable.OffsetPos - Transfertable.CenterOffsetComponent) / Transfertable.Span * SharedShape.Animations[0].FrameCount;
+          for (var imatrix = 0; imatrix < SharedShape.Matrices.Length; ++imatrix)
+          {
+              if (SharedShape.MatrixNames[imatrix].ToLower() == transfertable.Animations[0].ToLower())
+              {
+                  IAnimationMatrix = imatrix;
+                  break;
+              }
+          }
+          if (viewer.Simulator.TRK.Tr_RouteFile.DefaultTurntableSMS != null)
+          {
+              var soundPath = viewer.Simulator.RoutePath + @"\\sound\\" + viewer.Simulator.TRK.Tr_RouteFile.DefaultTurntableSMS;
+              try
+              {
+                  Sound = new SoundSource(viewer, initialPosition.WorldLocation, Events.Source.ORTSTurntable, soundPath);
+                  viewer.SoundProcess.AddSoundSources(this, new List<SoundSourceBase>() { Sound });
+              }
+              catch
+              {
+                  soundPath = viewer.Simulator.BasePath + @"\\sound\\" + viewer.Simulator.TRK.Tr_RouteFile.DefaultTurntableSMS;
+                  try
+                  {
+                      Sound = new SoundSource(viewer, initialPosition.WorldLocation, Events.Source.ORTSTurntable, soundPath);
+                      viewer.SoundProcess.AddSoundSources(this, new List<SoundSourceBase>() { Sound });
+                  }
+                  catch (Exception error)
+                  {
+                      Trace.WriteLine(new FileLoadException(soundPath, error));
+                  }
+              }
+          }
+          for (var matrix = 0; matrix < SharedShape.Matrices.Length; ++matrix)
+              AnimateMatrix(matrix, AnimationKey);
+
+          var absAnimationMatrix = XNAMatrices[IAnimationMatrix];
+          Matrix.Multiply(ref absAnimationMatrix, ref Location.XNAMatrix, out absAnimationMatrix);
+          Transfertable.ReInitTrainPositions(absAnimationMatrix);
+      }
+
+      public override void PrepareFrame(RenderFrame frame, ElapsedTime elapsedTime)
+      {
+          if (Transfertable.GoToTarget)
+          {
+              AnimationKey = (Transfertable.TargetOffset - Transfertable.CenterOffsetComponent) / Transfertable.Span * SharedShape.Animations[0].FrameCount;
+          }
+
+          else if (Transfertable.Forward)
+          {
+              AnimationKey += SharedShape.Animations[0].FrameRate * elapsedTime.ClockSeconds;
+          }
+          else if (Transfertable.Reverse)
+          {
+              AnimationKey -= SharedShape.Animations[0].FrameRate * elapsedTime.ClockSeconds;
+          }
+          if (AnimationKey > SharedShape.Animations[0].FrameCount) AnimationKey = SharedShape.Animations[0].FrameCount;
+          if (AnimationKey < 0) AnimationKey = 0;
+
+          Transfertable.OffsetPos = AnimationKey / SharedShape.Animations[0].FrameCount * Transfertable.Span + Transfertable.CenterOffsetComponent;
+
+          if ((Transfertable.Forward || Transfertable.Reverse) && !Translating)
+          {
+              Translating = true;
+              if (Sound != null) Sound.HandleEvent(Transfertable.TrainsOnMovingTable.Count == 1 &&
+                  Transfertable.TrainsOnMovingTable[0].FrontOnBoard && Transfertable.TrainsOnMovingTable[0].BackOnBoard ? Event.MovingTableMovingLoaded : Event.MovingTableMovingEmpty);
+          }
+          else if ((!Transfertable.Forward && !Transfertable.Reverse && Translating))
+          {
+              Translating = false;
+              if (Sound != null) Sound.HandleEvent(Event.MovingTableStopped);
+          }
+
+          // Update the pose for each matrix
+          for (var matrix = 0; matrix < SharedShape.Matrices.Length; ++matrix)
+              AnimateMatrix(matrix, AnimationKey);
+
+          var absAnimationMatrix = XNAMatrices[IAnimationMatrix];
+          Matrix.Multiply(ref absAnimationMatrix, ref Location.XNAMatrix, out absAnimationMatrix);
+          Transfertable.PerformUpdateActions(absAnimationMatrix, Location);
+          SharedShape.PrepareFrame(frame, Location, XNAMatrices, Flags);
+      }
+  }
+
+  public class ShapePrimitive : RenderPrimitive
+  {
+      public Material Material { get; protected set; }
+      public int[] Hierarchy { get; protected set; } // the hierarchy from the sub_object
+      public int HierarchyIndex { get; protected set; } // index into the hiearchy array which provides pose for this primitive
+
+      protected internal VertexBuffer VertexBuffer;
+      protected internal IndexBuffer IndexBuffer;
+      protected internal int PrimitiveCount;
+      protected internal VertexBufferBinding[] VertexBufferBindings;
+
+      public ShapePrimitive()
+      {
+      }
+
+      public ShapePrimitive(Material material, SharedShape.VertexBufferSet vertexBufferSet, IndexBuffer indexBuffer, int primitiveCount, int[] hierarchy, int hierarchyIndex)
+      {
+          Material = material;
+          VertexBuffer = vertexBufferSet.Buffer;
+          IndexBuffer = indexBuffer;
+          PrimitiveCount = primitiveCount;
+          Hierarchy = hierarchy;
+          HierarchyIndex = hierarchyIndex;
+
+          VertexBufferBindings = new[] { new VertexBufferBinding(VertexBuffer), new VertexBufferBinding(GetDummyVertexBuffer(material.Viewer.GraphicsDevice)) };
+      }
+
+      public ShapePrimitive(Material material, SharedShape.VertexBufferSet vertexBufferSet, IList<ushort> indexData, GraphicsDevice graphicsDevice, int[] hierarchy, int hierarchyIndex)
+          : this(material, vertexBufferSet, null, indexData.Count / 3, hierarchy, hierarchyIndex)
+      {
+          IndexBuffer = new IndexBuffer(graphicsDevice, typeof(short), indexData.Count, BufferUsage.WriteOnly);
+          IndexBuffer.SetData(indexData.ToArray());
+      }
+
+      public override void Draw(GraphicsDevice graphicsDevice)
+      {
+          if (PrimitiveCount > 0)
+          {
+              // TODO consider sorting by Vertex set so we can reduce the number of SetSources required.
+              graphicsDevice.SetVertexBuffers(VertexBufferBindings);
+              graphicsDevice.Indices = IndexBuffer;
+              graphicsDevice.DrawIndexedPrimitives(PrimitiveType.TriangleList, baseVertex: 0, startIndex: 0, primitiveCount: PrimitiveCount);
+          }
+      }
+
+      [CallOnThread("Loader")]
+      public virtual void Mark()
+      {
+          Material.Mark();
+      }
+  }
+
+  /// <summary>
+  /// A <c>ShapePrimitive</c> that permits manipulation of vertex and index buffers to change geometry efficiently.
+  /// It permits also change of material
+  /// </summary>
+  public class MutableShapePrimitive : ShapePrimitive
+  {
+      /// <remarks>
+      /// Buffers cannot be expanded, so take care to properly set <paramref name="maxVertices"/> and <paramref name="maxIndices"/>,
+      /// which define the maximum sizes of the vertex and index buffers, respectively.
+      /// </remarks>
+      public MutableShapePrimitive(Material material, int maxVertices, int maxIndices, int[] hierarchy, int hierarchyIndex)
+          : base(material: material,
+                 vertexBufferSet: new SharedShape.VertexBufferSet(new VertexPositionNormalTexture[maxVertices], material.Viewer.GraphicsDevice),
+                 indexData: new ushort[maxIndices],
+                 graphicsDevice: material.Viewer.GraphicsDevice,
+                 hierarchy: hierarchy,
+                 hierarchyIndex: hierarchyIndex) { }
+
+      public void SetVertexData(VertexPositionNormalTexture[] data, int minVertexIndex, int numVertices, int primitiveCount)
+      {
+          VertexBuffer.SetData(data);
+          PrimitiveCount = primitiveCount;
+      }
+
+      public void SetIndexData(short[] data)
+      {
+          IndexBuffer.SetData(data);
+      }
+
+      public void SetMaterial(Material material)
+      {
+          Material = material;
+      }
+  }
+
+  struct ShapeInstanceData
+  {
 #pragma warning disable 0649
-        public Matrix World;
+      public Matrix World;
 #pragma warning restore 0649
 
-        public static readonly VertexElement[] VertexElements = {
-            new VertexElement(sizeof(float) * 0, VertexElementFormat.Vector4, VertexElementUsage.TextureCoordinate, 1),
-            new VertexElement(sizeof(float) * 4, VertexElementFormat.Vector4, VertexElementUsage.TextureCoordinate, 2),
-            new VertexElement(sizeof(float) * 8, VertexElementFormat.Vector4, VertexElementUsage.TextureCoordinate, 3),
-            new VertexElement(sizeof(float) * 12, VertexElementFormat.Vector4, VertexElementUsage.TextureCoordinate, 4),
-        };
-
-        public static int SizeInBytes = sizeof(float) * 16;
-    }
-
-    public class ShapePrimitiveInstances : RenderPrimitive
-    {
-        public Material Material { get; protected set; }
-        public int[] Hierarchy { get; protected set; } // the hierarchy from the sub_object
-        public int HierarchyIndex { get; protected set; } // index into the hiearchy array which provides pose for this primitive
-        public int SubObjectIndex { get; protected set; }
-
-        protected VertexBuffer VertexBuffer;
-        protected VertexDeclaration VertexDeclaration;
-        protected int VertexBufferStride;
-        protected IndexBuffer IndexBuffer;
-        protected int PrimitiveCount;
-
-        protected VertexBuffer InstanceBuffer;
-        protected VertexDeclaration InstanceDeclaration;
-        protected int InstanceBufferStride;
-        protected int InstanceCount;
-        protected VertexBufferBinding[] VertexBufferBindings;
-
-        internal ShapePrimitiveInstances(GraphicsDevice graphicsDevice, ShapePrimitive shapePrimitive, Matrix[] positions, int subObjectIndex)
-        {
-            Material = shapePrimitive.Material;
-            Hierarchy = shapePrimitive.Hierarchy;
-            HierarchyIndex = shapePrimitive.HierarchyIndex;
-            SubObjectIndex = subObjectIndex;
-            VertexBuffer = shapePrimitive.VertexBuffer;
-            VertexDeclaration = shapePrimitive.VertexBuffer.VertexDeclaration;
-            IndexBuffer = shapePrimitive.IndexBuffer;
-            PrimitiveCount = shapePrimitive.PrimitiveCount;
-
-            InstanceDeclaration = new VertexDeclaration(ShapeInstanceData.SizeInBytes, ShapeInstanceData.VertexElements);
-            InstanceBuffer = new VertexBuffer(graphicsDevice, InstanceDeclaration, positions.Length, BufferUsage.WriteOnly);
-            InstanceBuffer.SetData(positions);
-            InstanceCount = positions.Length;
-
-            VertexBufferBindings = new[] { new VertexBufferBinding(VertexBuffer), new VertexBufferBinding(InstanceBuffer, 0, 1) };
-        }
-
-        public override void Draw(GraphicsDevice graphicsDevice)
-        {
-            graphicsDevice.Indices = IndexBuffer;
-            graphicsDevice.SetVertexBuffers(VertexBufferBindings);
-            graphicsDevice.DrawInstancedPrimitives(PrimitiveType.TriangleList, 0, 0, PrimitiveCount, InstanceCount);
-        }
-    }
+      public static readonly VertexElement[] VertexElements = {
+          new VertexElement(sizeof(float) * 0, VertexElementFormat.Vector4, VertexElementUsage.TextureCoordinate, 1),
+          new VertexElement(sizeof(float) * 4, VertexElementFormat.Vector4, VertexElementUsage.TextureCoordinate, 2),
+          new VertexElement(sizeof(float) * 8, VertexElementFormat.Vector4, VertexElementUsage.TextureCoordinate, 3),
+          new VertexElement(sizeof(float) * 12, VertexElementFormat.Vector4, VertexElementUsage.TextureCoordinate, 4),
+      };
+
+      public static int SizeInBytes = sizeof(float) * 16;
+  }
+
+  public class ShapePrimitiveInstances : RenderPrimitive
+  {
+      public Material Material { get; protected set; }
+      public int[] Hierarchy { get; protected set; } // the hierarchy from the sub_object
+      public int HierarchyIndex { get; protected set; } // index into the hiearchy array which provides pose for this primitive
+      public int SubObjectIndex { get; protected set; }
+
+      protected VertexBuffer VertexBuffer;
+      protected VertexDeclaration VertexDeclaration;
+      protected int VertexBufferStride;
+      protected IndexBuffer IndexBuffer;
+      protected int PrimitiveCount;
+
+      protected VertexBuffer InstanceBuffer;
+      protected VertexDeclaration InstanceDeclaration;
+      protected int InstanceBufferStride;
+      protected int InstanceCount;
+      protected VertexBufferBinding[] VertexBufferBindings;
+
+      internal ShapePrimitiveInstances(GraphicsDevice graphicsDevice, ShapePrimitive shapePrimitive, Matrix[] positions, int subObjectIndex)
+      {
+          Material = shapePrimitive.Material;
+          Hierarchy = shapePrimitive.Hierarchy;
+          HierarchyIndex = shapePrimitive.HierarchyIndex;
+          SubObjectIndex = subObjectIndex;
+          VertexBuffer = shapePrimitive.VertexBuffer;
+          VertexDeclaration = shapePrimitive.VertexBuffer.VertexDeclaration;
+          IndexBuffer = shapePrimitive.IndexBuffer;
+          PrimitiveCount = shapePrimitive.PrimitiveCount;
+
+          InstanceDeclaration = new VertexDeclaration(ShapeInstanceData.SizeInBytes, ShapeInstanceData.VertexElements);
+          InstanceBuffer = new VertexBuffer(graphicsDevice, InstanceDeclaration, positions.Length, BufferUsage.WriteOnly);
+          InstanceBuffer.SetData(positions);
+          InstanceCount = positions.Length;
+
+          VertexBufferBindings = new[] { new VertexBufferBinding(VertexBuffer), new VertexBufferBinding(InstanceBuffer, 0, 1) };
+      }
+
+      public override void Draw(GraphicsDevice graphicsDevice)
+      {
+          graphicsDevice.Indices = IndexBuffer;
+          graphicsDevice.SetVertexBuffers(VertexBufferBindings);
+          graphicsDevice.DrawInstancedPrimitives(PrimitiveType.TriangleList, 0, 0, PrimitiveCount, InstanceCount);
+      }
+  }
 
 #if DEBUG_SHAPE_NORMALS
-    public class ShapeDebugNormalsPrimitive : ShapePrimitive
-    {
-        public ShapeDebugNormalsPrimitive(Material material, SharedShape.VertexBufferSet vertexBufferSet, List<ushort> indexData, GraphicsDevice graphicsDevice, int[] hierarchy, int hierarchyIndex)
-        {
-            Material = material;
-            VertexBuffer = vertexBufferSet.DebugNormalsBuffer;
-            VertexDeclaration = vertexBufferSet.DebugNormalsDeclaration;
-            VertexBufferStride = vertexBufferSet.DebugNormalsDeclaration.GetVertexStrideSize(0);
-            var debugNormalsIndexBuffer = new List<ushort>(indexData.Count * SharedShape.VertexBufferSet.DebugNormalsVertexPerVertex);
-            for (var i = 0; i < indexData.Count; i++)
-                for (var j = 0; j < SharedShape.VertexBufferSet.DebugNormalsVertexPerVertex; j++)
-                    debugNormalsIndexBuffer.Add((ushort)(indexData[i] * SharedShape.VertexBufferSet.DebugNormalsVertexPerVertex + j));
-            IndexBuffer = new IndexBuffer(graphicsDevice, typeof(short), debugNormalsIndexBuffer.Count, BufferUsage.WriteOnly);
-            IndexBuffer.SetData(debugNormalsIndexBuffer.ToArray());
-            MinVertexIndex = indexData.Min() * SharedShape.VertexBufferSet.DebugNormalsVertexPerVertex;
-            NumVerticies = (indexData.Max() - indexData.Min() + 1) * SharedShape.VertexBufferSet.DebugNormalsVertexPerVertex;
-            PrimitiveCount = indexData.Count / 3 * SharedShape.VertexBufferSet.DebugNormalsVertexPerVertex;
-            Hierarchy = hierarchy;
-            HierarchyIndex = hierarchyIndex;
-        }
-
-        public override void Draw(GraphicsDevice graphicsDevice)
-        {
-            if (PrimitiveCount > 0)
-            {
-                graphicsDevice.VertexDeclaration = VertexDeclaration;
-                graphicsDevice.Vertices[0].SetSource(VertexBuffer, 0, VertexBufferStride);
-                graphicsDevice.Indices = IndexBuffer;
-                graphicsDevice.DrawIndexedPrimitives(PrimitiveType.TriangleList, 0, MinVertexIndex, NumVerticies, 0, PrimitiveCount);
-            }
-        }
-
-        [CallOnThread("Loader")]
-        public virtual void Mark()
-        {
-            Material.Mark();
-        }
-    }
+  public class ShapeDebugNormalsPrimitive : ShapePrimitive
+  {
+      public ShapeDebugNormalsPrimitive(Material material, SharedShape.VertexBufferSet vertexBufferSet, List<ushort> indexData, GraphicsDevice graphicsDevice, int[] hierarchy, int hierarchyIndex)
+      {
+          Material = material;
+          VertexBuffer = vertexBufferSet.DebugNormalsBuffer;
+          VertexDeclaration = vertexBufferSet.DebugNormalsDeclaration;
+          VertexBufferStride = vertexBufferSet.DebugNormalsDeclaration.GetVertexStrideSize(0);
+          var debugNormalsIndexBuffer = new List<ushort>(indexData.Count * SharedShape.VertexBufferSet.DebugNormalsVertexPerVertex);
+          for (var i = 0; i < indexData.Count; i++)
+              for (var j = 0; j < SharedShape.VertexBufferSet.DebugNormalsVertexPerVertex; j++)
+                  debugNormalsIndexBuffer.Add((ushort)(indexData[i] * SharedShape.VertexBufferSet.DebugNormalsVertexPerVertex + j));
+          IndexBuffer = new IndexBuffer(graphicsDevice, typeof(short), debugNormalsIndexBuffer.Count, BufferUsage.WriteOnly);
+          IndexBuffer.SetData(debugNormalsIndexBuffer.ToArray());
+          MinVertexIndex = indexData.Min() * SharedShape.VertexBufferSet.DebugNormalsVertexPerVertex;
+          NumVerticies = (indexData.Max() - indexData.Min() + 1) * SharedShape.VertexBufferSet.DebugNormalsVertexPerVertex;
+          PrimitiveCount = indexData.Count / 3 * SharedShape.VertexBufferSet.DebugNormalsVertexPerVertex;
+          Hierarchy = hierarchy;
+          HierarchyIndex = hierarchyIndex;
+      }
+
+      public override void Draw(GraphicsDevice graphicsDevice)
+      {
+          if (PrimitiveCount > 0)
+          {
+              graphicsDevice.VertexDeclaration = VertexDeclaration;
+              graphicsDevice.Vertices[0].SetSource(VertexBuffer, 0, VertexBufferStride);
+              graphicsDevice.Indices = IndexBuffer;
+              graphicsDevice.DrawIndexedPrimitives(PrimitiveType.TriangleList, 0, MinVertexIndex, NumVerticies, 0, PrimitiveCount);
+          }
+      }
+
+      [CallOnThread("Loader")]
+      public virtual void Mark()
+      {
+          Material.Mark();
+      }
+  }
 #endif
 
-    public class SharedShape
-    {
-        static List<string> ShapeWarnings = new List<string>();
-
-        // This data is common to all instances of the shape
-        public List<string> MatrixNames = new List<string>();
-        public Matrix[] Matrices = new Matrix[0];  // the original natural pose for this shape - shared by all instances
-        public animations Animations;
-        public LodControl[] LodControls;
-        public bool HasNightSubObj;
-        public int RootSubObjectIndex = 0;
-        //public bool negativeBogie = false;
-        public string SoundFileName = "";
-        public float CustomAnimationFPS = 8;
-
-
-        readonly Viewer Viewer;
-        public readonly string FilePath;
-        public readonly string ReferencePath;
-
-        /// <summary>
-        /// Create an empty shape used as a sub when the shape won't load
-        /// </summary>
-        /// <param name="viewer"></param>
-        public SharedShape(Viewer viewer)
-        {
-            Viewer = viewer;
-            FilePath = "Empty";
-            LodControls = new LodControl[0];
-        }
-
-        /// <summary>
-        /// MSTS shape from shape file
-        /// </summary>
-        /// <param name="viewer"></param>
-        /// <param name="filePath">Path to shape's S file</param>
-        public SharedShape(Viewer viewer, string filePath)
-        {
-            Viewer = viewer;
-            FilePath = filePath;
-            if (filePath.Contains('\0'))
-            {
-                var parts = filePath.Split('\0');
-                FilePath = parts[0];
-                ReferencePath = parts[1];
-            }
-            LoadContent();
-        }
-
-        /// <summary>
-        /// Only one copy of the model is loaded regardless of how many copies are placed in the scene.
-        /// </summary>
-        void LoadContent()
-        {
-            Trace.Write("S");
-            var filePath = FilePath;
-            // commented lines allow reading the animation block from an additional file in an Openrails subfolder
+  public class SharedShape
+  {
+      static List<string> ShapeWarnings = new List<string>();
+
+      // This data is common to all instances of the shape
+      public List<string> MatrixNames = new List<string>();
+      public Matrix[] Matrices = new Matrix[0];  // the original natural pose for this shape - shared by all instances
+      public animations Animations;
+      public LodControl[] LodControls;
+      public bool HasNightSubObj;
+      public int RootSubObjectIndex = 0;
+      //public bool negativeBogie = false;
+      public string SoundFileName = "";
+      public float CustomAnimationFPS = 8;
+
+
+      readonly Viewer Viewer;
+      public readonly string FilePath;
+      public readonly string ReferencePath;
+
+      /// <summary>
+      /// Create an empty shape used as a sub when the shape won't load
+      /// </summary>
+      /// <param name="viewer"></param>
+      public SharedShape(Viewer viewer)
+      {
+          Viewer = viewer;
+          FilePath = "Empty";
+          LodControls = new LodControl[0];
+      }
+
+      /// <summary>
+      /// MSTS shape from shape file
+      /// </summary>
+      /// <param name="viewer"></param>
+      /// <param name="filePath">Path to shape's S file</param>
+      public SharedShape(Viewer viewer, string filePath)
+      {
+          Viewer = viewer;
+          FilePath = filePath;
+          if (filePath.Contains('\0'))
+          {
+              var parts = filePath.Split('\0');
+              FilePath = parts[0];
+              ReferencePath = parts[1];
+          }
+          LoadContent();
+      }
+
+      /// <summary>
+      /// Only one copy of the model is loaded regardless of how many copies are placed in the scene.
+      /// </summary>
+      void LoadContent()
+      {
+          Trace.Write("S");
+          var filePath = FilePath;
+          // commented lines allow reading the animation block from an additional file in an Openrails subfolder
 //           string dir = Path.GetDirectoryName(filePath);
 //            string file = Path.GetFileName(filePath);
 //            string orFilePath = dir + @"\openrails\" + file;
-            var sFile = new ShapeFile(filePath, Viewer.Settings.SuppressShapeWarnings);
+          var sFile = new ShapeFile(filePath, Viewer.Settings.SuppressShapeWarnings);
 //            if (file.ToLower().Contains("turntable") && File.Exists(orFilePath))
 //            {
 //                sFile.ReadAnimationBlock(orFilePath);
 //            }
 
 
-            var textureFlags = Helpers.TextureFlags.None;
-            if (File.Exists(FilePath + "d"))
-            {
-                var sdFile = new ShapeDescriptorFile(FilePath + "d");
-                textureFlags = (Helpers.TextureFlags)sdFile.shape.ESD_Alternative_Texture;
-                if (FilePath != null && FilePath.Contains("\\global\\")) textureFlags |= Helpers.TextureFlags.SnowTrack;//roads and tracks are in global, as MSTS will always use snow texture in snow weather
-                HasNightSubObj = sdFile.shape.ESD_SubObj;
-                if ((textureFlags & Helpers.TextureFlags.Night) != 0 && FilePath.Contains("\\trainset\\"))
-                    textureFlags |= Helpers.TextureFlags.Underground;
-                SoundFileName = sdFile.shape.ESD_SoundFileName;
-                CustomAnimationFPS = sdFile.shape.ESD_CustomAnimationFPS;
-            }
-
-            var matrixCount = sFile.shape.matrices.Count;
-            MatrixNames.Capacity = matrixCount;
-            Matrices = new Matrix[matrixCount];
-            for (var i = 0; i < matrixCount; ++i)
-            {
-                MatrixNames.Add(sFile.shape.matrices[i].Name.ToUpper());
-                Matrices[i] = XNAMatrixFromMSTS(sFile.shape.matrices[i]);
-            }
-            Animations = sFile.shape.animations;
+          var textureFlags = Helpers.TextureFlags.None;
+          if (File.Exists(FilePath + "d"))
+          {
+              var sdFile = new ShapeDescriptorFile(FilePath + "d");
+              textureFlags = (Helpers.TextureFlags)sdFile.shape.ESD_Alternative_Texture;
+              if (FilePath != null && FilePath.Contains("\\global\\")) textureFlags |= Helpers.TextureFlags.SnowTrack;//roads and tracks are in global, as MSTS will always use snow texture in snow weather
+              HasNightSubObj = sdFile.shape.ESD_SubObj;
+              if ((textureFlags & Helpers.TextureFlags.Night) != 0 && FilePath.Contains("\\trainset\\"))
+                  textureFlags |= Helpers.TextureFlags.Underground;
+              SoundFileName = sdFile.shape.ESD_SoundFileName;
+              CustomAnimationFPS = sdFile.shape.ESD_CustomAnimationFPS;
+          }
+
+          var matrixCount = sFile.shape.matrices.Count;
+          MatrixNames.Capacity = matrixCount;
+          Matrices = new Matrix[matrixCount];
+          for (var i = 0; i < matrixCount; ++i)
+          {
+              MatrixNames.Add(sFile.shape.matrices[i].Name.ToUpper());
+              Matrices[i] = XNAMatrixFromMSTS(sFile.shape.matrices[i]);
+          }
+          Animations = sFile.shape.animations;
 
 #if DEBUG_SHAPE_HIERARCHY
-            var debugShapeHierarchy = new StringBuilder();
-            debugShapeHierarchy.AppendFormat("Shape {0}:\n", Path.GetFileNameWithoutExtension(FilePath).ToUpper());
-            for (var i = 0; i < MatrixNames.Count; ++i)
-                debugShapeHierarchy.AppendFormat("  Matrix {0,-2}: {1}\n", i, MatrixNames[i]);
-            for (var i = 0; i < sFile.shape.prim_states.Count; ++i)
-                debugShapeHierarchy.AppendFormat("  PState {0,-2}: flags={1,-8:X8} shader={2,-15} alpha={3,-2} vstate={4,-2} lstate={5,-2} zbias={6,-5:F3} zbuffer={7,-2} name={8}\n", i, sFile.shape.prim_states[i].flags, sFile.shape.shader_names[sFile.shape.prim_states[i].ishader], sFile.shape.prim_states[i].alphatestmode, sFile.shape.prim_states[i].ivtx_state, sFile.shape.prim_states[i].LightCfgIdx, sFile.shape.prim_states[i].ZBias, sFile.shape.prim_states[i].ZBufMode, sFile.shape.prim_states[i].Name);
-            for (var i = 0; i < sFile.shape.vtx_states.Count; ++i)
-                debugShapeHierarchy.AppendFormat("  VState {0,-2}: flags={1,-8:X8} lflags={2,-8:X8} lstate={3,-2} material={4,-3} matrix2={5,-2}\n", i, sFile.shape.vtx_states[i].flags, sFile.shape.vtx_states[i].LightFlags, sFile.shape.vtx_states[i].LightCfgIdx, sFile.shape.vtx_states[i].LightMatIdx, sFile.shape.vtx_states[i].Matrix2);
-            for (var i = 0; i < sFile.shape.light_model_cfgs.Count; ++i)
-            {
-                debugShapeHierarchy.AppendFormat("  LState {0,-2}: flags={1,-8:X8} uv_ops={2,-2}\n", i, sFile.shape.light_model_cfgs[i].flags, sFile.shape.light_model_cfgs[i].uv_ops.Count);
-                for (var j = 0; j < sFile.shape.light_model_cfgs[i].uv_ops.Count; ++j)
-                    debugShapeHierarchy.AppendFormat("    UV OP {0,-2}: texture_address_mode={1,-2}\n", j, sFile.shape.light_model_cfgs[i].uv_ops[j].TexAddrMode);
-            }
-            Console.Write(debugShapeHierarchy.ToString());
+          var debugShapeHierarchy = new StringBuilder();
+          debugShapeHierarchy.AppendFormat("Shape {0}:\n", Path.GetFileNameWithoutExtension(FilePath).ToUpper());
+          for (var i = 0; i < MatrixNames.Count; ++i)
+              debugShapeHierarchy.AppendFormat("  Matrix {0,-2}: {1}\n", i, MatrixNames[i]);
+          for (var i = 0; i < sFile.shape.prim_states.Count; ++i)
+              debugShapeHierarchy.AppendFormat("  PState {0,-2}: flags={1,-8:X8} shader={2,-15} alpha={3,-2} vstate={4,-2} lstate={5,-2} zbias={6,-5:F3} zbuffer={7,-2} name={8}\n", i, sFile.shape.prim_states[i].flags, sFile.shape.shader_names[sFile.shape.prim_states[i].ishader], sFile.shape.prim_states[i].alphatestmode, sFile.shape.prim_states[i].ivtx_state, sFile.shape.prim_states[i].LightCfgIdx, sFile.shape.prim_states[i].ZBias, sFile.shape.prim_states[i].ZBufMode, sFile.shape.prim_states[i].Name);
+          for (var i = 0; i < sFile.shape.vtx_states.Count; ++i)
+              debugShapeHierarchy.AppendFormat("  VState {0,-2}: flags={1,-8:X8} lflags={2,-8:X8} lstate={3,-2} material={4,-3} matrix2={5,-2}\n", i, sFile.shape.vtx_states[i].flags, sFile.shape.vtx_states[i].LightFlags, sFile.shape.vtx_states[i].LightCfgIdx, sFile.shape.vtx_states[i].LightMatIdx, sFile.shape.vtx_states[i].Matrix2);
+          for (var i = 0; i < sFile.shape.light_model_cfgs.Count; ++i)
+          {
+              debugShapeHierarchy.AppendFormat("  LState {0,-2}: flags={1,-8:X8} uv_ops={2,-2}\n", i, sFile.shape.light_model_cfgs[i].flags, sFile.shape.light_model_cfgs[i].uv_ops.Count);
+              for (var j = 0; j < sFile.shape.light_model_cfgs[i].uv_ops.Count; ++j)
+                  debugShapeHierarchy.AppendFormat("    UV OP {0,-2}: texture_address_mode={1,-2}\n", j, sFile.shape.light_model_cfgs[i].uv_ops[j].TexAddrMode);
+          }
+          Console.Write(debugShapeHierarchy.ToString());
 #endif
-            LodControls = (from lod_control lod in sFile.shape.lod_controls
-                           select new LodControl(lod, textureFlags, sFile, this)).ToArray();
-            if (LodControls.Length == 0)
-                throw new InvalidDataException("Shape file missing lod_control section");
-            else if (LodControls[0].DistanceLevels.Length > 0 && LodControls[0].DistanceLevels[0].SubObjects.Length > 0)
-            {
-                // Zero the position offset of the root matrix for compatibility with MSTS
-                if (LodControls[0].DistanceLevels[0].SubObjects[0].ShapePrimitives.Length > 0 && LodControls[0].DistanceLevels[0].SubObjects[0].ShapePrimitives[0].Hierarchy[0] == -1)
-                {
-                    Matrices[0].M41 = 0;
-                    Matrices[0].M42 = 0;
-                    Matrices[0].M43 = 0;
-                }
-                // Look for root subobject, it is not necessarily the first (see ProTrain signal)
-                for (int soIndex = 0; soIndex <= LodControls[0].DistanceLevels[0].SubObjects.Length - 1; soIndex++)
-                {
-                    sub_object subObject = sFile.shape.lod_controls[0].distance_levels[0].sub_objects[soIndex];
-                    if (subObject.sub_object_header.geometry_info.geometry_node_map[0] == 0)
-                    {
-                        RootSubObjectIndex = soIndex;
-                        break;
-                    }
-                }
-            }
-        }
-
-        public class LodControl
-        {
-            public DistanceLevel[] DistanceLevels;
-
-            public LodControl(lod_control MSTSlod_control, Helpers.TextureFlags textureFlags, ShapeFile sFile, SharedShape sharedShape)
-            {
+          LodControls = (from lod_control lod in sFile.shape.lod_controls
+                         select new LodControl(lod, textureFlags, sFile, this)).ToArray();
+          if (LodControls.Length == 0)
+              throw new InvalidDataException("Shape file missing lod_control section");
+          else if (LodControls[0].DistanceLevels.Length > 0 && LodControls[0].DistanceLevels[0].SubObjects.Length > 0)
+          {
+              // Zero the position offset of the root matrix for compatibility with MSTS
+              if (LodControls[0].DistanceLevels[0].SubObjects[0].ShapePrimitives.Length > 0 && LodControls[0].DistanceLevels[0].SubObjects[0].ShapePrimitives[0].Hierarchy[0] == -1)
+              {
+                  Matrices[0].M41 = 0;
+                  Matrices[0].M42 = 0;
+                  Matrices[0].M43 = 0;
+              }
+              // Look for root subobject, it is not necessarily the first (see ProTrain signal)
+              for (int soIndex = 0; soIndex <= LodControls[0].DistanceLevels[0].SubObjects.Length - 1; soIndex++)
+              {
+                  sub_object subObject = sFile.shape.lod_controls[0].distance_levels[0].sub_objects[soIndex];
+                  if (subObject.sub_object_header.geometry_info.geometry_node_map[0] == 0)
+                  {
+                      RootSubObjectIndex = soIndex;
+                      break;
+                  }
+              }
+          }
+      }
+
+      public class LodControl
+      {
+          public DistanceLevel[] DistanceLevels;
+
+          public LodControl(lod_control MSTSlod_control, Helpers.TextureFlags textureFlags, ShapeFile sFile, SharedShape sharedShape)
+          {
 #if DEBUG_SHAPE_HIERARCHY
-                Console.WriteLine("  LOD control:");
+              Console.WriteLine("  LOD control:");
 #endif
-                DistanceLevels = (from distance_level level in MSTSlod_control.distance_levels
-                                  select new DistanceLevel(level, textureFlags, sFile, sharedShape)).ToArray();
-                if (DistanceLevels.Length == 0)
-                    throw new InvalidDataException("Shape file missing distance_level");
-            }
-
-            [CallOnThread("Loader")]
-            internal void Mark()
-            {
-                foreach (var dl in DistanceLevels)
-                    dl.Mark();
-            }
-        }
-
-        public class DistanceLevel
-        {
-            public float ViewingDistance;
-            public float ViewSphereRadius;
-            public SubObject[] SubObjects;
-
-            public DistanceLevel(distance_level MSTSdistance_level, Helpers.TextureFlags textureFlags, ShapeFile sFile, SharedShape sharedShape)
-            {
+              DistanceLevels = (from distance_level level in MSTSlod_control.distance_levels
+                                select new DistanceLevel(level, textureFlags, sFile, sharedShape)).ToArray();
+              if (DistanceLevels.Length == 0)
+                  throw new InvalidDataException("Shape file missing distance_level");
+          }
+
+          [CallOnThread("Loader")]
+          internal void Mark()
+          {
+              foreach (var dl in DistanceLevels)
+                  dl.Mark();
+          }
+      }
+
+      public class DistanceLevel
+      {
+          public float ViewingDistance;
+          public float ViewSphereRadius;
+          public SubObject[] SubObjects;
+
+          public DistanceLevel(distance_level MSTSdistance_level, Helpers.TextureFlags textureFlags, ShapeFile sFile, SharedShape sharedShape)
+          {
 #if DEBUG_SHAPE_HIERARCHY
-                Console.WriteLine("    Distance level {0}: hierarchy={1}", MSTSdistance_level.distance_level_header.dlevel_selection, String.Join(" ", MSTSdistance_level.distance_level_header.hierarchy.Select(i => i.ToString()).ToArray()));
+              Console.WriteLine("    Distance level {0}: hierarchy={1}", MSTSdistance_level.distance_level_header.dlevel_selection, String.Join(" ", MSTSdistance_level.distance_level_header.hierarchy.Select(i => i.ToString()).ToArray()));
 #endif
-                ViewingDistance = MSTSdistance_level.distance_level_header.dlevel_selection;
-                // TODO, work out ViewShereRadius from all sub_object radius and centers.
-                if (sFile.shape.volumes.Count > 0)
-                    ViewSphereRadius = sFile.shape.volumes[0].Radius;
-                else
-                    ViewSphereRadius = 100;
-
-                var index = 0;
+              ViewingDistance = MSTSdistance_level.distance_level_header.dlevel_selection;
+              // TODO, work out ViewShereRadius from all sub_object radius and centers.
+              if (sFile.shape.volumes.Count > 0)
+                  ViewSphereRadius = sFile.shape.volumes[0].Radius;
+              else
+                  ViewSphereRadius = 100;
+
+              var index = 0;
 #if DEBUG_SHAPE_HIERARCHY
-                var subObjectIndex = 0;
-                SubObjects = (from sub_object obj in MSTSdistance_level.sub_objects
-                              select new SubObject(obj, ref index, MSTSdistance_level.distance_level_header.hierarchy, textureFlags, subObjectIndex++, sFile, sharedShape)).ToArray();
+              var subObjectIndex = 0;
+              SubObjects = (from sub_object obj in MSTSdistance_level.sub_objects
+                            select new SubObject(obj, ref index, MSTSdistance_level.distance_level_header.hierarchy, textureFlags, subObjectIndex++, sFile, sharedShape)).ToArray();
 #else
-                SubObjects = (from sub_object obj in MSTSdistance_level.sub_objects
-                              select new SubObject(obj, ref index, MSTSdistance_level.distance_level_header.hierarchy, textureFlags, sFile, sharedShape)).ToArray();
+              SubObjects = (from sub_object obj in MSTSdistance_level.sub_objects
+                            select new SubObject(obj, ref index, MSTSdistance_level.distance_level_header.hierarchy, textureFlags, sFile, sharedShape)).ToArray();
 #endif
-                if (SubObjects.Length == 0)
-                    throw new InvalidDataException("Shape file missing sub_object");
-            }
-
-            [CallOnThread("Loader")]
-            internal void Mark()
-            {
-                foreach (var so in SubObjects)
-                    so.Mark();
-            }
-        }
-
-        public class SubObject
-        {
-            static readonly SceneryMaterialOptions[] UVTextureAddressModeMap = new[] {
-                SceneryMaterialOptions.TextureAddressModeWrap,
-                SceneryMaterialOptions.TextureAddressModeMirror,
-                SceneryMaterialOptions.TextureAddressModeClamp,
-                SceneryMaterialOptions.TextureAddressModeBorder,
-            };
-
-            static readonly Dictionary<string, SceneryMaterialOptions> ShaderNames = new Dictionary<string, SceneryMaterialOptions> {
-                { "Tex", SceneryMaterialOptions.ShaderFullBright },
-                { "TexDiff", SceneryMaterialOptions.Diffuse },
-                { "BlendATex", SceneryMaterialOptions.AlphaBlendingBlend | SceneryMaterialOptions.ShaderFullBright},
-                { "BlendATexDiff", SceneryMaterialOptions.AlphaBlendingBlend | SceneryMaterialOptions.Diffuse },
-                { "AddATex", SceneryMaterialOptions.AlphaBlendingAdd | SceneryMaterialOptions.ShaderFullBright},
-                { "AddATexDiff", SceneryMaterialOptions.AlphaBlendingAdd | SceneryMaterialOptions.Diffuse },
-            };
-
-            static readonly SceneryMaterialOptions[] VertexLightModeMap = new[] {
-                SceneryMaterialOptions.ShaderDarkShade,
-                SceneryMaterialOptions.ShaderHalfBright,
-                SceneryMaterialOptions.ShaderVegetation, // Not certain this is right.
-                SceneryMaterialOptions.ShaderVegetation,
-                SceneryMaterialOptions.ShaderFullBright,
-                SceneryMaterialOptions.None | SceneryMaterialOptions.Specular750,
-                SceneryMaterialOptions.None | SceneryMaterialOptions.Specular25,
-                SceneryMaterialOptions.None | SceneryMaterialOptions.None,
-            };
-
-            public ShapePrimitive[] ShapePrimitives;
+              if (SubObjects.Length == 0)
+                  throw new InvalidDataException("Shape file missing sub_object");
+          }
+
+          [CallOnThread("Loader")]
+          internal void Mark()
+          {
+              foreach (var so in SubObjects)
+                  so.Mark();
+          }
+      }
+
+      public class SubObject
+      {
+          static readonly SceneryMaterialOptions[] UVTextureAddressModeMap = new[] {
+              SceneryMaterialOptions.TextureAddressModeWrap,
+              SceneryMaterialOptions.TextureAddressModeMirror,
+              SceneryMaterialOptions.TextureAddressModeClamp,
+              SceneryMaterialOptions.TextureAddressModeBorder,
+          };
+
+          static readonly Dictionary<string, SceneryMaterialOptions> ShaderNames = new Dictionary<string, SceneryMaterialOptions> {
+              { "Tex", SceneryMaterialOptions.ShaderFullBright },
+              { "TexDiff", SceneryMaterialOptions.Diffuse },
+              { "BlendATex", SceneryMaterialOptions.AlphaBlendingBlend | SceneryMaterialOptions.ShaderFullBright},
+              { "BlendATexDiff", SceneryMaterialOptions.AlphaBlendingBlend | SceneryMaterialOptions.Diffuse },
+              { "AddATex", SceneryMaterialOptions.AlphaBlendingAdd | SceneryMaterialOptions.ShaderFullBright},
+              { "AddATexDiff", SceneryMaterialOptions.AlphaBlendingAdd | SceneryMaterialOptions.Diffuse },
+          };
+
+          static readonly SceneryMaterialOptions[] VertexLightModeMap = new[] {
+              SceneryMaterialOptions.ShaderDarkShade,
+              SceneryMaterialOptions.ShaderHalfBright,
+              SceneryMaterialOptions.ShaderVegetation, // Not certain this is right.
+              SceneryMaterialOptions.ShaderVegetation,
+              SceneryMaterialOptions.ShaderFullBright,
+              SceneryMaterialOptions.None | SceneryMaterialOptions.Specular750,
+              SceneryMaterialOptions.None | SceneryMaterialOptions.Specular25,
+              SceneryMaterialOptions.None | SceneryMaterialOptions.None,
+          };
+
+          public ShapePrimitive[] ShapePrimitives;
 
 #if DEBUG_SHAPE_HIERARCHY
-            public SubObject(sub_object sub_object, ref int totalPrimitiveIndex, int[] hierarchy, Helpers.TextureFlags textureFlags, int subObjectIndex, SFile sFile, SharedShape sharedShape)
+          public SubObject(sub_object sub_object, ref int totalPrimitiveIndex, int[] hierarchy, Helpers.TextureFlags textureFlags, int subObjectIndex, SFile sFile, SharedShape sharedShape)
 #else
-            public SubObject(sub_object sub_object, ref int totalPrimitiveIndex, int[] hierarchy, Helpers.TextureFlags textureFlags, ShapeFile sFile, SharedShape sharedShape)
+          public SubObject(sub_object sub_object, ref int totalPrimitiveIndex, int[] hierarchy, Helpers.TextureFlags textureFlags, ShapeFile sFile, SharedShape sharedShape)
 #endif
-            {
+          {
 #if DEBUG_SHAPE_HIERARCHY
-                var debugShapeHierarchy = new StringBuilder();
-                debugShapeHierarchy.AppendFormat("      Sub object {0}:\n", subObjectIndex);
+              var debugShapeHierarchy = new StringBuilder();
+              debugShapeHierarchy.AppendFormat("      Sub object {0}:\n", subObjectIndex);
 #endif
-                var vertexBufferSet = new VertexBufferSet(sub_object, sFile, sharedShape.Viewer.GraphicsDevice);
+              var vertexBufferSet = new VertexBufferSet(sub_object, sFile, sharedShape.Viewer.GraphicsDevice);
 #if DEBUG_SHAPE_NORMALS
-                var debugNormalsMaterial = sharedShape.Viewer.MaterialManager.Load("DebugNormals");
+              var debugNormalsMaterial = sharedShape.Viewer.MaterialManager.Load("DebugNormals");
 #endif
 
 #if OPTIMIZE_SHAPES_ON_LOAD
-                var primitiveMaterials = sub_object.primitives.Cast<primitive>().Select((primitive) =>
+              var primitiveMaterials = sub_object.primitives.Cast<primitive>().Select((primitive) =>
 #else
-                var primitiveIndex = 0;
+              var primitiveIndex = 0;
 #if DEBUG_SHAPE_NORMALS
-                ShapePrimitives = new ShapePrimitive[sub_object.primitives.Count * 2];
+              ShapePrimitives = new ShapePrimitive[sub_object.primitives.Count * 2];
 #else
-                ShapePrimitives = new ShapePrimitive[sub_object.primitives.Count];
+              ShapePrimitives = new ShapePrimitive[sub_object.primitives.Count];
 #endif
-                foreach (primitive primitive in sub_object.primitives)
+              foreach (primitive primitive in sub_object.primitives)
 #endif
-                {
-                    var primitiveState = sFile.shape.prim_states[primitive.prim_state_idx];
-                    var vertexState = sFile.shape.vtx_states[primitiveState.ivtx_state];
-                    var lightModelConfiguration = sFile.shape.light_model_cfgs[vertexState.LightCfgIdx];
-                    var options = SceneryMaterialOptions.None;
-
-                    // Validate hierarchy position.
-                    var hierarchyIndex = vertexState.imatrix;
-                    while (hierarchyIndex != -1)
-                    {
-                        if (hierarchyIndex < 0 || hierarchyIndex >= hierarchy.Length)
-                        {
-                            var hierarchyList = new List<int>();
-                            hierarchyIndex = vertexState.imatrix;
-                            while (hierarchyIndex >= 0 && hierarchyIndex < hierarchy.Length)
-                            {
-                                hierarchyList.Add(hierarchyIndex);
-                                hierarchyIndex = hierarchy[hierarchyIndex];
-                            }
-                            hierarchyList.Add(hierarchyIndex);
-                            Trace.TraceWarning("Ignored invalid primitive hierarchy {1} in shape {0}", sharedShape.FilePath, String.Join(" ", hierarchyList.Select(hi => hi.ToString()).ToArray()));
-                            break;
-                        }
-                        hierarchyIndex = hierarchy[hierarchyIndex];
-                    }
-
-                    if (lightModelConfiguration.uv_ops.Count > 0)
-                        if (lightModelConfiguration.uv_ops[0].TexAddrMode - 1 >= 0 && lightModelConfiguration.uv_ops[0].TexAddrMode - 1 < UVTextureAddressModeMap.Length)
-                            options |= UVTextureAddressModeMap[lightModelConfiguration.uv_ops[0].TexAddrMode - 1];
-                        else if (!ShapeWarnings.Contains("texture_addressing_mode:" + lightModelConfiguration.uv_ops[0].TexAddrMode))
-                        {
-                            Trace.TraceInformation("Skipped unknown texture addressing mode {1} first seen in shape {0}", sharedShape.FilePath, lightModelConfiguration.uv_ops[0].TexAddrMode);
-                            ShapeWarnings.Add("texture_addressing_mode:" + lightModelConfiguration.uv_ops[0].TexAddrMode);
-                        }
-
-                    if (primitiveState.alphatestmode == 1)
-                        options |= SceneryMaterialOptions.AlphaTest;
-
-                    if (ShaderNames.ContainsKey(sFile.shape.shader_names[primitiveState.ishader]))
-                        options |= ShaderNames[sFile.shape.shader_names[primitiveState.ishader]];
-                    else if (!ShapeWarnings.Contains("shader_name:" + sFile.shape.shader_names[primitiveState.ishader]))
-                    {
-                        Trace.TraceInformation("Skipped unknown shader name {1} first seen in shape {0}", sharedShape.FilePath, sFile.shape.shader_names[primitiveState.ishader]);
-                        ShapeWarnings.Add("shader_name:" + sFile.shape.shader_names[primitiveState.ishader]);
-                    }
-
-                    if (12 + vertexState.LightMatIdx >= 0 && 12 + vertexState.LightMatIdx < VertexLightModeMap.Length)
-                        options |= VertexLightModeMap[12 + vertexState.LightMatIdx];
-                    else if (!ShapeWarnings.Contains("lighting_model:" + vertexState.LightMatIdx))
-                    {
-                        Trace.TraceInformation("Skipped unknown lighting model index {1} first seen in shape {0}", sharedShape.FilePath, vertexState.LightMatIdx);
-                        ShapeWarnings.Add("lighting_model:" + vertexState.LightMatIdx);
-                    }
-
-                    if ((textureFlags & Helpers.TextureFlags.Night) != 0)
-                        options |= SceneryMaterialOptions.NightTexture;
-
-                    if ((textureFlags & Helpers.TextureFlags.Underground) != 0)
-                        options |= SceneryMaterialOptions.UndergroundTexture;
-
-                    Material material;
-                    if (primitiveState.tex_idxs.Length != 0)
-                    {
-                        var texture = sFile.shape.textures[primitiveState.tex_idxs[0]];
-                        var imageName = sFile.shape.images[texture.iImage];
-                        if (String.IsNullOrEmpty(sharedShape.ReferencePath))
-                            material = sharedShape.Viewer.MaterialManager.Load("Scenery", Helpers.GetRouteTextureFile(sharedShape.Viewer.Simulator, textureFlags, imageName), (int)options, texture.MipMapLODBias);
-                        else
-                            material = sharedShape.Viewer.MaterialManager.Load("Scenery", Helpers.GetTextureFile(sharedShape.Viewer.Simulator, textureFlags, sharedShape.ReferencePath, imageName), (int)options, texture.MipMapLODBias);
-                    }
-                    else
-                    {
-                        material = sharedShape.Viewer.MaterialManager.Load("Scenery", null, (int)options);
-                    }
+              {
+                  var primitiveState = sFile.shape.prim_states[primitive.prim_state_idx];
+                  var vertexState = sFile.shape.vtx_states[primitiveState.ivtx_state];
+                  var lightModelConfiguration = sFile.shape.light_model_cfgs[vertexState.LightCfgIdx];
+                  var options = SceneryMaterialOptions.None;
+
+                  // Validate hierarchy position.
+                  var hierarchyIndex = vertexState.imatrix;
+                  while (hierarchyIndex != -1)
+                  {
+                      if (hierarchyIndex < 0 || hierarchyIndex >= hierarchy.Length)
+                      {
+                          var hierarchyList = new List<int>();
+                          hierarchyIndex = vertexState.imatrix;
+                          while (hierarchyIndex >= 0 && hierarchyIndex < hierarchy.Length)
+                          {
+                              hierarchyList.Add(hierarchyIndex);
+                              hierarchyIndex = hierarchy[hierarchyIndex];
+                          }
+                          hierarchyList.Add(hierarchyIndex);
+                          Trace.TraceWarning("Ignored invalid primitive hierarchy {1} in shape {0}", sharedShape.FilePath, String.Join(" ", hierarchyList.Select(hi => hi.ToString()).ToArray()));
+                          break;
+                      }
+                      hierarchyIndex = hierarchy[hierarchyIndex];
+                  }
+
+                  if (lightModelConfiguration.uv_ops.Count > 0)
+                      if (lightModelConfiguration.uv_ops[0].TexAddrMode - 1 >= 0 && lightModelConfiguration.uv_ops[0].TexAddrMode - 1 < UVTextureAddressModeMap.Length)
+                          options |= UVTextureAddressModeMap[lightModelConfiguration.uv_ops[0].TexAddrMode - 1];
+                      else if (!ShapeWarnings.Contains("texture_addressing_mode:" + lightModelConfiguration.uv_ops[0].TexAddrMode))
+                      {
+                          Trace.TraceInformation("Skipped unknown texture addressing mode {1} first seen in shape {0}", sharedShape.FilePath, lightModelConfiguration.uv_ops[0].TexAddrMode);
+                          ShapeWarnings.Add("texture_addressing_mode:" + lightModelConfiguration.uv_ops[0].TexAddrMode);
+                      }
+
+                  if (primitiveState.alphatestmode == 1)
+                      options |= SceneryMaterialOptions.AlphaTest;
+
+                  if (ShaderNames.ContainsKey(sFile.shape.shader_names[primitiveState.ishader]))
+                      options |= ShaderNames[sFile.shape.shader_names[primitiveState.ishader]];
+                  else if (!ShapeWarnings.Contains("shader_name:" + sFile.shape.shader_names[primitiveState.ishader]))
+                  {
+                      Trace.TraceInformation("Skipped unknown shader name {1} first seen in shape {0}", sharedShape.FilePath, sFile.shape.shader_names[primitiveState.ishader]);
+                      ShapeWarnings.Add("shader_name:" + sFile.shape.shader_names[primitiveState.ishader]);
+                  }
+
+                  if (12 + vertexState.LightMatIdx >= 0 && 12 + vertexState.LightMatIdx < VertexLightModeMap.Length)
+                      options |= VertexLightModeMap[12 + vertexState.LightMatIdx];
+                  else if (!ShapeWarnings.Contains("lighting_model:" + vertexState.LightMatIdx))
+                  {
+                      Trace.TraceInformation("Skipped unknown lighting model index {1} first seen in shape {0}", sharedShape.FilePath, vertexState.LightMatIdx);
+                      ShapeWarnings.Add("lighting_model:" + vertexState.LightMatIdx);
+                  }
+
+                  if ((textureFlags & Helpers.TextureFlags.Night) != 0)
+                      options |= SceneryMaterialOptions.NightTexture;
+
+                  if ((textureFlags & Helpers.TextureFlags.Underground) != 0)
+                      options |= SceneryMaterialOptions.UndergroundTexture;
+
+                  Material material;
+                  if (primitiveState.tex_idxs.Length != 0)
+                  {
+                      var texture = sFile.shape.textures[primitiveState.tex_idxs[0]];
+                      var imageName = sFile.shape.images[texture.iImage];
+                      if (String.IsNullOrEmpty(sharedShape.ReferencePath))
+                          material = sharedShape.Viewer.MaterialManager.Load("Scenery", Helpers.GetRouteTextureFile(sharedShape.Viewer.Simulator, textureFlags, imageName), (int)options, texture.MipMapLODBias);
+                      else
+                          material = sharedShape.Viewer.MaterialManager.Load("Scenery", Helpers.GetTextureFile(sharedShape.Viewer.Simulator, textureFlags, sharedShape.ReferencePath, imageName), (int)options, texture.MipMapLODBias);
+                  }
+                  else
+                  {
+                      material = sharedShape.Viewer.MaterialManager.Load("Scenery", null, (int)options);
+                  }
 
 #if DEBUG_SHAPE_HIERARCHY
-                    debugShapeHierarchy.AppendFormat("        Primitive {0,-2}: pstate={1,-2} vstate={2,-2} lstate={3,-2} matrix={4,-2}", primitiveIndex, primitive.prim_state_idx, primitiveState.ivtx_state, vertexState.LightCfgIdx, vertexState.imatrix);
-                    var debugMatrix = vertexState.imatrix;
-                    while (debugMatrix >= 0)
-                    {
-                        debugShapeHierarchy.AppendFormat(" {0}", sharedShape.MatrixNames[debugMatrix]);
-                        debugMatrix = hierarchy[debugMatrix];
-                    }
-                    debugShapeHierarchy.Append("\n");
+                  debugShapeHierarchy.AppendFormat("        Primitive {0,-2}: pstate={1,-2} vstate={2,-2} lstate={3,-2} matrix={4,-2}", primitiveIndex, primitive.prim_state_idx, primitiveState.ivtx_state, vertexState.LightCfgIdx, vertexState.imatrix);
+                  var debugMatrix = vertexState.imatrix;
+                  while (debugMatrix >= 0)
+                  {
+                      debugShapeHierarchy.AppendFormat(" {0}", sharedShape.MatrixNames[debugMatrix]);
+                      debugMatrix = hierarchy[debugMatrix];
+                  }
+                  debugShapeHierarchy.Append("\n");
 #endif
 
 #if OPTIMIZE_SHAPES_ON_LOAD
-                    return new { Key = material.ToString() + "/" + vertexState.imatrix.ToString(), Primitive = primitive, Material = material, HierachyIndex = vertexState.imatrix };
-                }).ToArray();
+                  return new { Key = material.ToString() + "/" + vertexState.imatrix.ToString(), Primitive = primitive, Material = material, HierachyIndex = vertexState.imatrix };
+              }).ToArray();
 #else
-                    if (primitive.indexed_trilist.vertex_idxs.Count == 0)
-                    {
-                        Trace.TraceWarning("Skipped primitive with 0 indices in {0}", sharedShape.FilePath);
-                        continue;
-                    }
-
-                    var indexData = new List<ushort>(primitive.indexed_trilist.vertex_idxs.Count * 3);
-                    foreach (vertex_idx vertex_idx in primitive.indexed_trilist.vertex_idxs)
-                        foreach (var index in new[] { vertex_idx.a, vertex_idx.b, vertex_idx.c })
-                            indexData.Add((ushort)index);
-
-                    ShapePrimitives[primitiveIndex] = new ShapePrimitive(material, vertexBufferSet, indexData, sharedShape.Viewer.GraphicsDevice, hierarchy, vertexState.imatrix);
-                    ShapePrimitives[primitiveIndex].SortIndex = ++totalPrimitiveIndex;
-                    ++primitiveIndex;
+                  if (primitive.indexed_trilist.vertex_idxs.Count == 0)
+                  {
+                      Trace.TraceWarning("Skipped primitive with 0 indices in {0}", sharedShape.FilePath);
+                      continue;
+                  }
+
+                  var indexData = new List<ushort>(primitive.indexed_trilist.vertex_idxs.Count * 3);
+                  foreach (vertex_idx vertex_idx in primitive.indexed_trilist.vertex_idxs)
+                      foreach (var index in new[] { vertex_idx.a, vertex_idx.b, vertex_idx.c })
+                          indexData.Add((ushort)index);
+
+                  ShapePrimitives[primitiveIndex] = new ShapePrimitive(material, vertexBufferSet, indexData, sharedShape.Viewer.GraphicsDevice, hierarchy, vertexState.imatrix);
+                  ShapePrimitives[primitiveIndex].SortIndex = ++totalPrimitiveIndex;
+                  ++primitiveIndex;
 #if DEBUG_SHAPE_NORMALS
-                    ShapePrimitives[primitiveIndex] = new ShapeDebugNormalsPrimitive(debugNormalsMaterial, vertexBufferSet, indexData, sharedShape.Viewer.GraphicsDevice, hierarchy, vertexState.imatrix);
-                    ShapePrimitives[primitiveIndex].SortIndex = totalPrimitiveIndex;
-                    ++primitiveIndex;
+                  ShapePrimitives[primitiveIndex] = new ShapeDebugNormalsPrimitive(debugNormalsMaterial, vertexBufferSet, indexData, sharedShape.Viewer.GraphicsDevice, hierarchy, vertexState.imatrix);
+                  ShapePrimitives[primitiveIndex].SortIndex = totalPrimitiveIndex;
+                  ++primitiveIndex;
 #endif
-                }
+              }
 #endif
 
 #if OPTIMIZE_SHAPES_ON_LOAD
-                var indexes = new Dictionary<string, List<short>>(sub_object.primitives.Count);
-                foreach (var primitiveMaterial in primitiveMaterials)
-                {
-                    var baseIndex = 0;
-                    var indexData = new List<short>(0);
-                    if (indexes.TryGetValue(primitiveMaterial.Key, out indexData))
-                    {
-                        baseIndex = indexData.Count;
-                        indexData.Capacity += primitiveMaterial.Primitive.indexed_trilist.vertex_idxs.Count * 3;
-                    }
-                    else
-                    {
-                        indexData = new List<short>(primitiveMaterial.Primitive.indexed_trilist.vertex_idxs.Count * 3);
-                        indexes.Add(primitiveMaterial.Key, indexData);
-                    }
-
-                    var primitiveState = sFile.shape.prim_states[primitiveMaterial.Primitive.prim_state_idx];
-                    foreach (vertex_idx vertex_idx in primitiveMaterial.Primitive.indexed_trilist.vertex_idxs)
-                    {
-                        indexData.Add((short)vertex_idx.a);
-                        indexData.Add((short)vertex_idx.b);
-                        indexData.Add((short)vertex_idx.c);
-                    }
-                }
-
-                ShapePrimitives = new ShapePrimitive[indexes.Count];
-                var primitiveIndex = 0;
-                foreach (var index in indexes)
-                {
-                    var indexBuffer = new IndexBuffer(sharedShape.Viewer.GraphicsDevice, typeof(short), index.Value.Count, BufferUsage.WriteOnly);
-                    indexBuffer.SetData(index.Value.ToArray());
-                    var primitiveMaterial = primitiveMaterials.First(d => d.Key == index.Key);
-                    ShapePrimitives[primitiveIndex] = new ShapePrimitive(primitiveMaterial.Material, vertexBufferSet, indexBuffer, index.Value.Min(), index.Value.Max() - index.Value.Min() + 1, index.Value.Count / 3, hierarchy, primitiveMaterial.HierachyIndex);
-                    ++primitiveIndex;
-                }
-                if (sub_object.primitives.Count != indexes.Count)
-                    Trace.TraceInformation("{1} -> {2} primitives in {0}", sharedShape.FilePath, sub_object.primitives.Count, indexes.Count);
+              var indexes = new Dictionary<string, List<short>>(sub_object.primitives.Count);
+              foreach (var primitiveMaterial in primitiveMaterials)
+              {
+                  var baseIndex = 0;
+                  var indexData = new List<short>(0);
+                  if (indexes.TryGetValue(primitiveMaterial.Key, out indexData))
+                  {
+                      baseIndex = indexData.Count;
+                      indexData.Capacity += primitiveMaterial.Primitive.indexed_trilist.vertex_idxs.Count * 3;
+                  }
+                  else
+                  {
+                      indexData = new List<short>(primitiveMaterial.Primitive.indexed_trilist.vertex_idxs.Count * 3);
+                      indexes.Add(primitiveMaterial.Key, indexData);
+                  }
+
+                  var primitiveState = sFile.shape.prim_states[primitiveMaterial.Primitive.prim_state_idx];
+                  foreach (vertex_idx vertex_idx in primitiveMaterial.Primitive.indexed_trilist.vertex_idxs)
+                  {
+                      indexData.Add((short)vertex_idx.a);
+                      indexData.Add((short)vertex_idx.b);
+                      indexData.Add((short)vertex_idx.c);
+                  }
+              }
+
+              ShapePrimitives = new ShapePrimitive[indexes.Count];
+              var primitiveIndex = 0;
+              foreach (var index in indexes)
+              {
+                  var indexBuffer = new IndexBuffer(sharedShape.Viewer.GraphicsDevice, typeof(short), index.Value.Count, BufferUsage.WriteOnly);
+                  indexBuffer.SetData(index.Value.ToArray());
+                  var primitiveMaterial = primitiveMaterials.First(d => d.Key == index.Key);
+                  ShapePrimitives[primitiveIndex] = new ShapePrimitive(primitiveMaterial.Material, vertexBufferSet, indexBuffer, index.Value.Min(), index.Value.Max() - index.Value.Min() + 1, index.Value.Count / 3, hierarchy, primitiveMaterial.HierachyIndex);
+                  ++primitiveIndex;
+              }
+              if (sub_object.primitives.Count != indexes.Count)
+                  Trace.TraceInformation("{1} -> {2} primitives in {0}", sharedShape.FilePath, sub_object.primitives.Count, indexes.Count);
 #else
-                if (primitiveIndex < ShapePrimitives.Length)
-                    ShapePrimitives = ShapePrimitives.Take(primitiveIndex).ToArray();
+              if (primitiveIndex < ShapePrimitives.Length)
+                  ShapePrimitives = ShapePrimitives.Take(primitiveIndex).ToArray();
 #endif
 
 #if DEBUG_SHAPE_HIERARCHY
-                Console.Write(debugShapeHierarchy.ToString());
+              Console.Write(debugShapeHierarchy.ToString());
 #endif
-            }
+          }
 
-            [CallOnThread("Loader")]
-            internal void Mark()
-            {
-                foreach (var prim in ShapePrimitives)
-                    prim.Mark();
-            }
-        }
+          [CallOnThread("Loader")]
+          internal void Mark()
+          {
+              foreach (var prim in ShapePrimitives)
+                  prim.Mark();
+          }
+      }
 
-        public class VertexBufferSet
-        {
-            public VertexBuffer Buffer;
+      public class VertexBufferSet
+      {
+          public VertexBuffer Buffer;
 
 #if DEBUG_SHAPE_NORMALS
-            public VertexBuffer DebugNormalsBuffer;
-            public VertexDeclaration DebugNormalsDeclaration;
-            public int DebugNormalsVertexCount;
-            public const int DebugNormalsVertexPerVertex = 3 * 4;
+          public VertexBuffer DebugNormalsBuffer;
+          public VertexDeclaration DebugNormalsDeclaration;
+          public int DebugNormalsVertexCount;
+          public const int DebugNormalsVertexPerVertex = 3 * 4;
 #endif
 
-            public VertexBufferSet(VertexPositionNormalTexture[] vertexData, GraphicsDevice graphicsDevice)
-            {
-                Buffer = new VertexBuffer(graphicsDevice, typeof(VertexPositionNormalTexture), vertexData.Length, BufferUsage.WriteOnly);
-                Buffer.SetData(vertexData);
-            }
+          public VertexBufferSet(VertexPositionNormalTexture[] vertexData, GraphicsDevice graphicsDevice)
+          {
+              Buffer = new VertexBuffer(graphicsDevice, typeof(VertexPositionNormalTexture), vertexData.Length, BufferUsage.WriteOnly);
+              Buffer.SetData(vertexData);
+          }
 
 #if DEBUG_SHAPE_NORMALS
-            public VertexBufferSet(VertexPositionNormalTexture[] vertexData, VertexPositionColor[] debugNormalsVertexData, GraphicsDevice graphicsDevice)
-                :this(vertexData, graphicsDevice)
-            {
-                DebugNormalsVertexCount = debugNormalsVertexData.Length;
-                DebugNormalsDeclaration = new VertexDeclaration(graphicsDevice, VertexPositionColor.VertexElements);
-                DebugNormalsBuffer = new VertexBuffer(graphicsDevice, typeof(VertexPositionColor), DebugNormalsVertexCount, BufferUsage.WriteOnly);
-                DebugNormalsBuffer.SetData(debugNormalsVertexData);
-            }
+          public VertexBufferSet(VertexPositionNormalTexture[] vertexData, VertexPositionColor[] debugNormalsVertexData, GraphicsDevice graphicsDevice)
+              :this(vertexData, graphicsDevice)
+          {
+              DebugNormalsVertexCount = debugNormalsVertexData.Length;
+              DebugNormalsDeclaration = new VertexDeclaration(graphicsDevice, VertexPositionColor.VertexElements);
+              DebugNormalsBuffer = new VertexBuffer(graphicsDevice, typeof(VertexPositionColor), DebugNormalsVertexCount, BufferUsage.WriteOnly);
+              DebugNormalsBuffer.SetData(debugNormalsVertexData);
+          }
 #endif
 
-            public VertexBufferSet(sub_object sub_object, ShapeFile sFile, GraphicsDevice graphicsDevice)
+          public VertexBufferSet(sub_object sub_object, ShapeFile sFile, GraphicsDevice graphicsDevice)
 #if DEBUG_SHAPE_NORMALS
-                : this(CreateVertexData(sub_object, sFile.shape), CreateDebugNormalsVertexData(sub_object, sFile.shape), graphicsDevice)
+              : this(CreateVertexData(sub_object, sFile.shape), CreateDebugNormalsVertexData(sub_object, sFile.shape), graphicsDevice)
 #else
-                : this(CreateVertexData(sub_object, sFile.shape), graphicsDevice)
+              : this(CreateVertexData(sub_object, sFile.shape), graphicsDevice)
 #endif
-            {
-            }
-
-            static VertexPositionNormalTexture[] CreateVertexData(sub_object sub_object, shape shape)
-            {
-                // TODO - deal with vertex sets that have various numbers of texture coordinates - ie 0, 1, 2 etc
-                return (from vertex vertex in sub_object.vertices
-                        select XNAVertexPositionNormalTextureFromMSTS(vertex, shape)).ToArray();
-            }
-
-            static VertexPositionNormalTexture XNAVertexPositionNormalTextureFromMSTS(vertex vertex, shape shape)
-            {
-                var position = shape.points[vertex.ipoint];
-                var normal = shape.normals[vertex.inormal];
-                // TODO use a simpler vertex description when no UV's in use
-                var texcoord = vertex.vertex_uvs.Length > 0 ? shape.uv_points[vertex.vertex_uvs[0]] : new uv_point(0, 0);
-
-                return new VertexPositionNormalTexture()
-                {
-                    Position = new Vector3(position.X, position.Y, -position.Z),
-                    Normal = new Vector3(normal.X, normal.Y, -normal.Z),
-                    TextureCoordinate = new Vector2(texcoord.U, texcoord.V),
-                };
-            }
+          {
+          }
+
+          static VertexPositionNormalTexture[] CreateVertexData(sub_object sub_object, shape shape)
+          {
+              // TODO - deal with vertex sets that have various numbers of texture coordinates - ie 0, 1, 2 etc
+              return (from vertex vertex in sub_object.vertices
+                      select XNAVertexPositionNormalTextureFromMSTS(vertex, shape)).ToArray();
+          }
+
+          static VertexPositionNormalTexture XNAVertexPositionNormalTextureFromMSTS(vertex vertex, shape shape)
+          {
+              var position = shape.points[vertex.ipoint];
+              var normal = shape.normals[vertex.inormal];
+              // TODO use a simpler vertex description when no UV's in use
+              var texcoord = vertex.vertex_uvs.Length > 0 ? shape.uv_points[vertex.vertex_uvs[0]] : new uv_point(0, 0);
+
+              return new VertexPositionNormalTexture()
+              {
+                  Position = new Vector3(position.X, position.Y, -position.Z),
+                  Normal = new Vector3(normal.X, normal.Y, -normal.Z),
+                  TextureCoordinate = new Vector2(texcoord.U, texcoord.V),
+              };
+          }
 
 #if DEBUG_SHAPE_NORMALS
-            static VertexPositionColor[] CreateDebugNormalsVertexData(sub_object sub_object, shape shape)
-            {
-                var vertexData = new List<VertexPositionColor>();
-                foreach (vertex vertex in sub_object.vertices)
-                {
-                    var position = new Vector3(shape.points[vertex.ipoint].X, shape.points[vertex.ipoint].Y, -shape.points[vertex.ipoint].Z);
-                    var normal = new Vector3(shape.normals[vertex.inormal].X, shape.normals[vertex.inormal].Y, -shape.normals[vertex.inormal].Z);
-                    var right = Vector3.Cross(normal, Math.Abs(normal.Y) > 0.5 ? Vector3.Left : Vector3.Up);
-                    var up = Vector3.Cross(normal, right);
-                    right /= 50;
-                    up /= 50;
-                    vertexData.Add(new VertexPositionColor(position + right, Color.LightGreen));
-                    vertexData.Add(new VertexPositionColor(position + normal, Color.LightGreen));
-                    vertexData.Add(new VertexPositionColor(position + up, Color.LightGreen));
-                    vertexData.Add(new VertexPositionColor(position + up, Color.LightGreen));
-                    vertexData.Add(new VertexPositionColor(position + normal, Color.LightGreen));
-                    vertexData.Add(new VertexPositionColor(position - right, Color.LightGreen));
-                    vertexData.Add(new VertexPositionColor(position - right, Color.LightGreen));
-                    vertexData.Add(new VertexPositionColor(position + normal, Color.LightGreen));
-                    vertexData.Add(new VertexPositionColor(position - up, Color.LightGreen));
-                    vertexData.Add(new VertexPositionColor(position - up, Color.LightGreen));
-                    vertexData.Add(new VertexPositionColor(position + normal, Color.LightGreen));
-                    vertexData.Add(new VertexPositionColor(position + right, Color.LightGreen));
-                }
-                return vertexData.ToArray();
-            }
+          static VertexPositionColor[] CreateDebugNormalsVertexData(sub_object sub_object, shape shape)
+          {
+              var vertexData = new List<VertexPositionColor>();
+              foreach (vertex vertex in sub_object.vertices)
+              {
+                  var position = new Vector3(shape.points[vertex.ipoint].X, shape.points[vertex.ipoint].Y, -shape.points[vertex.ipoint].Z);
+                  var normal = new Vector3(shape.normals[vertex.inormal].X, shape.normals[vertex.inormal].Y, -shape.normals[vertex.inormal].Z);
+                  var right = Vector3.Cross(normal, Math.Abs(normal.Y) > 0.5 ? Vector3.Left : Vector3.Up);
+                  var up = Vector3.Cross(normal, right);
+                  right /= 50;
+                  up /= 50;
+                  vertexData.Add(new VertexPositionColor(position + right, Color.LightGreen));
+                  vertexData.Add(new VertexPositionColor(position + normal, Color.LightGreen));
+                  vertexData.Add(new VertexPositionColor(position + up, Color.LightGreen));
+                  vertexData.Add(new VertexPositionColor(position + up, Color.LightGreen));
+                  vertexData.Add(new VertexPositionColor(position + normal, Color.LightGreen));
+                  vertexData.Add(new VertexPositionColor(position - right, Color.LightGreen));
+                  vertexData.Add(new VertexPositionColor(position - right, Color.LightGreen));
+                  vertexData.Add(new VertexPositionColor(position + normal, Color.LightGreen));
+                  vertexData.Add(new VertexPositionColor(position - up, Color.LightGreen));
+                  vertexData.Add(new VertexPositionColor(position - up, Color.LightGreen));
+                  vertexData.Add(new VertexPositionColor(position + normal, Color.LightGreen));
+                  vertexData.Add(new VertexPositionColor(position + right, Color.LightGreen));
+              }
+              return vertexData.ToArray();
+          }
 #endif
-        }
-
-        static Matrix XNAMatrixFromMSTS(matrix MSTSMatrix)
-        {
-            var XNAMatrix = Matrix.Identity;
-
-            XNAMatrix.M11 = MSTSMatrix.AX;
-            XNAMatrix.M12 = MSTSMatrix.AY;
-            XNAMatrix.M13 = -MSTSMatrix.AZ;
-            XNAMatrix.M21 = MSTSMatrix.BX;
-            XNAMatrix.M22 = MSTSMatrix.BY;
-            XNAMatrix.M23 = -MSTSMatrix.BZ;
-            XNAMatrix.M31 = -MSTSMatrix.CX;
-            XNAMatrix.M32 = -MSTSMatrix.CY;
-            XNAMatrix.M33 = MSTSMatrix.CZ;
-            XNAMatrix.M41 = MSTSMatrix.DX;
-            XNAMatrix.M42 = MSTSMatrix.DY;
-            XNAMatrix.M43 = -MSTSMatrix.DZ;
-
-            return XNAMatrix;
-        }
-
-        public void PrepareFrame(RenderFrame frame, WorldPosition location, ShapeFlags flags)
-        {
-            PrepareFrame(frame, location, Matrices, null, flags);
-        }
-
-        public void PrepareFrame(RenderFrame frame, WorldPosition location, Matrix[] animatedXNAMatrices, ShapeFlags flags, bool[] matrixVisible = null)
-        {
-            PrepareFrame(frame, location, animatedXNAMatrices, null, flags, matrixVisible);
-        }
-
-        public void PrepareFrame(RenderFrame frame, WorldPosition location, Matrix[] animatedXNAMatrices, bool[] subObjVisible, ShapeFlags flags, bool[] matrixVisible = null)
-        {
-            var lodBias = ((float)Viewer.Settings.LODBias / 100 + 1);
-
-            // Locate relative to the camera
-            var dTileX = location.TileX - Viewer.Camera.TileX;
-            var dTileZ = location.TileZ - Viewer.Camera.TileZ;
-            var mstsLocation = location.Location;
-            mstsLocation.X += dTileX * 2048;
-            mstsLocation.Z += dTileZ * 2048;
-            var xnaDTileTranslation = location.XNAMatrix;
-            xnaDTileTranslation.M41 += dTileX * 2048;
-            xnaDTileTranslation.M43 -= dTileZ * 2048;
-
-            foreach (var lodControl in LodControls)
-            {
-                // Start with the furthest away distance, then look for a nearer one in range of the camera.
-                var displayDetailLevel = lodControl.DistanceLevels.Length - 1;
-
-                // If this LOD group is not in the FOV, skip the whole LOD group.
-                // TODO: This might imair some shadows.
-                if (!Viewer.Camera.InFov(mstsLocation, lodControl.DistanceLevels[displayDetailLevel].ViewSphereRadius))
-                    continue;
-
-                // We choose the distance level (LOD) to display first:
-                //   - LODBias = 100 means we always use the highest detail.
-                //   - LODBias < 100 means we operate as normal (using the highest detail in-range of the camera) but
-                //     scaling it by LODBias.
-                //
-                // However, for the viewing distance (and view sphere), we use a slightly different calculation:
-                //   - LODBias = 100 means we always use the *lowest* detail viewing distance.
-                //   - LODBias < 100 means we operate as normal (see above).
-                //
-                // The reason for this disparity is that LODBias = 100 is special, because it means "always use
-                // highest detail", but this by itself is not useful unless we keep using the normal (LODBias-scaled)
-                // viewing distance - right down to the lowest detail viewing distance. Otherwise, we'll scale the
-                // highest detail viewing distance up by 100% and then the object will just disappear!
-
-                if (Viewer.Settings.LODBias == 100)
-                    // Maximum detail!
-                    displayDetailLevel = 0;
-                else if (Viewer.Settings.LODBias > -100)
-                    // Not minimum detail, so find the correct level (with scaling by LODBias)
-                    while ((displayDetailLevel > 0) && Viewer.Camera.InRange(mstsLocation, lodControl.DistanceLevels[displayDetailLevel - 1].ViewSphereRadius, lodControl.DistanceLevels[displayDetailLevel - 1].ViewingDistance * lodBias))
-                        displayDetailLevel--;
-
-                var displayDetail = lodControl.DistanceLevels[displayDetailLevel];
-                var distanceDetail = Viewer.Settings.LODBias == 100
-                    ? lodControl.DistanceLevels[lodControl.DistanceLevels.Length - 1]
-                    : displayDetail;
-
-                // If set, extend the lowest LOD to the maximum viewing distance.
-                if (Viewer.Settings.LODViewingExtention && displayDetailLevel == lodControl.DistanceLevels.Length - 1)
-                    distanceDetail.ViewingDistance = float.MaxValue;
-
-                for (var i = 0; i < displayDetail.SubObjects.Length; i++)
-                {
-                    var subObject = displayDetail.SubObjects[i];
-
-                    // The 1st subobject (note that index 0 is the main object itself) is hidden during the day if HasNightSubObj is true.
-                    if ((subObjVisible != null && !subObjVisible[i]) || (i == 1 && HasNightSubObj && Viewer.MaterialManager.sunDirection.Y >= 0))
-                        continue;
-
-                    foreach (var shapePrimitive in subObject.ShapePrimitives)
-                    {
-                        var xnaMatrix = Matrix.Identity;
-                        var hi = shapePrimitive.HierarchyIndex;
-                        if (matrixVisible != null && !matrixVisible[hi]) continue;
-                        while (hi >= 0 && hi < shapePrimitive.Hierarchy.Length)
-                        {
-                            Matrix.Multiply(ref xnaMatrix, ref animatedXNAMatrices[hi], out xnaMatrix);
-                            hi = shapePrimitive.Hierarchy[hi];
-                        }
-                        Matrix.Multiply(ref xnaMatrix, ref xnaDTileTranslation, out xnaMatrix);
-
-                        // TODO make shadows depend on shape overrides
-
-                        var interior = (flags & ShapeFlags.Interior) != 0;
-                        frame.AddAutoPrimitive(mstsLocation, distanceDetail.ViewSphereRadius, distanceDetail.ViewingDistance * lodBias, shapePrimitive.Material, shapePrimitive, interior ? RenderPrimitiveGroup.Interior : RenderPrimitiveGroup.World, ref xnaMatrix, flags);
-                    }
-                }
-            }
-        }
-
-        public Matrix GetMatrixProduct(int iNode)
-        {
-            int[] h = LodControls[0].DistanceLevels[0].SubObjects[0].ShapePrimitives[0].Hierarchy;
-            Matrix matrix = Matrix.Identity;
-            while (iNode != -1)
-            {
-                matrix *= Matrices[iNode];
-                iNode = h[iNode];
-            }
-            return matrix;
-        }
-
-        public int GetParentMatrix(int iNode)
-        {
-            return LodControls[0].DistanceLevels[0].SubObjects[0].ShapePrimitives[0].Hierarchy[iNode];
-        }
-
-        [CallOnThread("Loader")]
-        internal void Mark()
-        {
-            Viewer.ShapeManager.Mark(this);
-            foreach (var lod in LodControls)
-                lod.Mark();
-        }
-    }
-
-    public class TrItemLabel
-    {
-        public readonly WorldPosition Location;
-        public readonly string ItemName;
-
-        /// <summary>
-        /// Construct and initialize the class.
-        /// This constructor is for the labels of track items in TDB and W Files such as sidings and platforms.
-        /// </summary>
-        public TrItemLabel(Viewer viewer, WorldPosition position, TrObject trObj)
-        {
-            Location = position;
-            var i = 0;
-            while (true)
-            {
-                var trID = trObj.getTrItemID(i);
-                if (trID < 0)
-                    break;
-                var trItem = viewer.Simulator.TDB.TrackDB.TrItemTable[trID];
-                if (trItem == null)
-                    continue;
-                ItemName = trItem.ItemName;
-                i++;
-            }
-        }
-    }
+      }
+
+      static Matrix XNAMatrixFromMSTS(matrix MSTSMatrix)
+      {
+          var XNAMatrix = Matrix.Identity;
+
+          XNAMatrix.M11 = MSTSMatrix.AX;
+          XNAMatrix.M12 = MSTSMatrix.AY;
+          XNAMatrix.M13 = -MSTSMatrix.AZ;
+          XNAMatrix.M21 = MSTSMatrix.BX;
+          XNAMatrix.M22 = MSTSMatrix.BY;
+          XNAMatrix.M23 = -MSTSMatrix.BZ;
+          XNAMatrix.M31 = -MSTSMatrix.CX;
+          XNAMatrix.M32 = -MSTSMatrix.CY;
+          XNAMatrix.M33 = MSTSMatrix.CZ;
+          XNAMatrix.M41 = MSTSMatrix.DX;
+          XNAMatrix.M42 = MSTSMatrix.DY;
+          XNAMatrix.M43 = -MSTSMatrix.DZ;
+
+          return XNAMatrix;
+      }
+
+      public void PrepareFrame(RenderFrame frame, WorldPosition location, ShapeFlags flags)
+      {
+          PrepareFrame(frame, location, Matrices, null, flags);
+      }
+
+      public void PrepareFrame(RenderFrame frame, WorldPosition location, Matrix[] animatedXNAMatrices, ShapeFlags flags, bool[] matrixVisible = null)
+      {
+          PrepareFrame(frame, location, animatedXNAMatrices, null, flags, matrixVisible);
+      }
+
+      public void PrepareFrame(RenderFrame frame, WorldPosition location, Matrix[] animatedXNAMatrices, bool[] subObjVisible, ShapeFlags flags, bool[] matrixVisible = null)
+      {
+          var lodBias = ((float)Viewer.Settings.LODBias / 100 + 1);
+
+          // Locate relative to the camera
+          var dTileX = location.TileX - Viewer.Camera.TileX;
+          var dTileZ = location.TileZ - Viewer.Camera.TileZ;
+          var mstsLocation = location.Location;
+          mstsLocation.X += dTileX * 2048;
+          mstsLocation.Z += dTileZ * 2048;
+          var xnaDTileTranslation = location.XNAMatrix;
+          xnaDTileTranslation.M41 += dTileX * 2048;
+          xnaDTileTranslation.M43 -= dTileZ * 2048;
+
+          foreach (var lodControl in LodControls)
+          {
+              // Start with the furthest away distance, then look for a nearer one in range of the camera.
+              var displayDetailLevel = lodControl.DistanceLevels.Length - 1;
+
+              // If this LOD group is not in the FOV, skip the whole LOD group.
+              // TODO: This might imair some shadows.
+              if (!Viewer.Camera.InFov(mstsLocation, lodControl.DistanceLevels[displayDetailLevel].ViewSphereRadius))
+                  continue;
+
+              // We choose the distance level (LOD) to display first:
+              //   - LODBias = 100 means we always use the highest detail.
+              //   - LODBias < 100 means we operate as normal (using the highest detail in-range of the camera) but
+              //     scaling it by LODBias.
+              //
+              // However, for the viewing distance (and view sphere), we use a slightly different calculation:
+              //   - LODBias = 100 means we always use the *lowest* detail viewing distance.
+              //   - LODBias < 100 means we operate as normal (see above).
+              //
+              // The reason for this disparity is that LODBias = 100 is special, because it means "always use
+              // highest detail", but this by itself is not useful unless we keep using the normal (LODBias-scaled)
+              // viewing distance - right down to the lowest detail viewing distance. Otherwise, we'll scale the
+              // highest detail viewing distance up by 100% and then the object will just disappear!
+
+              if (Viewer.Settings.LODBias == 100)
+                  // Maximum detail!
+                  displayDetailLevel = 0;
+              else if (Viewer.Settings.LODBias > -100)
+                  // Not minimum detail, so find the correct level (with scaling by LODBias)
+                  while ((displayDetailLevel > 0) && Viewer.Camera.InRange(mstsLocation, lodControl.DistanceLevels[displayDetailLevel - 1].ViewSphereRadius, lodControl.DistanceLevels[displayDetailLevel - 1].ViewingDistance * lodBias))
+                      displayDetailLevel--;
+
+              var displayDetail = lodControl.DistanceLevels[displayDetailLevel];
+              var distanceDetail = Viewer.Settings.LODBias == 100
+                  ? lodControl.DistanceLevels[lodControl.DistanceLevels.Length - 1]
+                  : displayDetail;
+
+              // If set, extend the lowest LOD to the maximum viewing distance.
+              if (Viewer.Settings.LODViewingExtention && displayDetailLevel == lodControl.DistanceLevels.Length - 1)
+                  distanceDetail.ViewingDistance = float.MaxValue;
+
+              for (var i = 0; i < displayDetail.SubObjects.Length; i++)
+              {
+                  var subObject = displayDetail.SubObjects[i];
+
+                  // The 1st subobject (note that index 0 is the main object itself) is hidden during the day if HasNightSubObj is true.
+                  if ((subObjVisible != null && !subObjVisible[i]) || (i == 1 && HasNightSubObj && Viewer.MaterialManager.sunDirection.Y >= 0))
+                      continue;
+
+                  foreach (var shapePrimitive in subObject.ShapePrimitives)
+                  {
+                      var xnaMatrix = Matrix.Identity;
+                      var hi = shapePrimitive.HierarchyIndex;
+                      if (matrixVisible != null && !matrixVisible[hi]) continue;
+                      while (hi >= 0 && hi < shapePrimitive.Hierarchy.Length)
+                      {
+                          Matrix.Multiply(ref xnaMatrix, ref animatedXNAMatrices[hi], out xnaMatrix);
+                          hi = shapePrimitive.Hierarchy[hi];
+                      }
+                      Matrix.Multiply(ref xnaMatrix, ref xnaDTileTranslation, out xnaMatrix);
+
+                      // TODO make shadows depend on shape overrides
+
+                      var interior = (flags & ShapeFlags.Interior) != 0;
+                      frame.AddAutoPrimitive(mstsLocation, distanceDetail.ViewSphereRadius, distanceDetail.ViewingDistance * lodBias, shapePrimitive.Material, shapePrimitive, interior ? RenderPrimitiveGroup.Interior : RenderPrimitiveGroup.World, ref xnaMatrix, flags);
+                  }
+              }
+          }
+      }
+
+      public Matrix GetMatrixProduct(int iNode)
+      {
+          int[] h = LodControls[0].DistanceLevels[0].SubObjects[0].ShapePrimitives[0].Hierarchy;
+          Matrix matrix = Matrix.Identity;
+          while (iNode != -1)
+          {
+              matrix *= Matrices[iNode];
+              iNode = h[iNode];
+          }
+          return matrix;
+      }
+
+      public int GetParentMatrix(int iNode)
+      {
+          return LodControls[0].DistanceLevels[0].SubObjects[0].ShapePrimitives[0].Hierarchy[iNode];
+      }
+
+      [CallOnThread("Loader")]
+      internal void Mark()
+      {
+          Viewer.ShapeManager.Mark(this);
+          foreach (var lod in LodControls)
+              lod.Mark();
+      }
+  }
+
+  public class TrItemLabel
+  {
+      public readonly WorldPosition Location;
+      public readonly string ItemName;
+
+      /// <summary>
+      /// Construct and initialize the class.
+      /// This constructor is for the labels of track items in TDB and W Files such as sidings and platforms.
+      /// </summary>
+      public TrItemLabel(Viewer viewer, WorldPosition position, TrObject trObj)
+      {
+          Location = position;
+          var i = 0;
+          while (true)
+          {
+              var trID = trObj.getTrItemID(i);
+              if (trID < 0)
+                  break;
+              var trItem = viewer.Simulator.TDB.TrackDB.TrItemTable[trID];
+              if (trItem == null)
+                  continue;
+              ItemName = trItem.ItemName;
+              i++;
+          }
+      }
+  }
 }
diff --git a/Source/RunActivity/Viewer3D/Trains.cs b/Source/RunActivity/Viewer3D/Trains.cs
index 5347bb2b9..c9583b920 100644
--- a/Source/RunActivity/Viewer3D/Trains.cs
+++ b/Source/RunActivity/Viewer3D/Trains.cs
@@ -130,7 +130,7 @@ public void LoadPrep()
             visibleCars.Add(Viewer.PlayerLocomotive);
             foreach (var train in Viewer.Simulator.Trains)
                 foreach (var car in train.Cars)
-                    if (ApproximateDistance(Viewer.Camera.CameraWorldLocation, car.WorldPosition.WorldLocation) < removeDistance && car != Viewer.PlayerLocomotive)
+                    if (WorldLocation.ApproximateDistance(Viewer.Camera.CameraWorldLocation, car.WorldPosition.WorldLocation) < removeDistance && car != Viewer.PlayerLocomotive)
                         visibleCars.Add(car);
             VisibleCars = visibleCars;
             PlayerCar = Viewer.Simulator.PlayerLocomotive;
@@ -161,14 +161,5 @@ TrainCarViewer LoadCar(TrainCar car)
             carViewer.lightDrawer = new LightViewer(Viewer, car);
             return carViewer;
         }
-
-        static float ApproximateDistance(WorldLocation a, WorldLocation b)
-        {
-            var dx = a.Location.X - b.Location.X;
-            var dz = a.Location.Z - b.Location.Z;
-            dx += (a.TileX - b.TileX) * 2048;
-            dz += (a.TileZ - b.TileZ) * 2048;
-            return Math.Abs(dx) + Math.Abs(dz);
-        }
     }
 }
diff --git a/Source/RunActivity/Viewer3D/World.cs b/Source/RunActivity/Viewer3D/World.cs
index f8b1de0d6..38617569f 100644
--- a/Source/RunActivity/Viewer3D/World.cs
+++ b/Source/RunActivity/Viewer3D/World.cs
@@ -20,6 +20,7 @@
 using Microsoft.Xna.Framework;
 using Orts.Common;
 using ORTS.Common;
+using Orts.Viewer3D.RollingStock.SubSystems;
 using System;
 using System.Collections.Generic;
 
@@ -36,6 +37,7 @@ public class World
         public readonly SceneryDrawer Scenery;
         public readonly TrainDrawer Trains;
         public readonly RoadCarViewer RoadCars;
+        public readonly ContainersViewer Containers;
         public readonly SoundSource GameSounds;
         public readonly WorldSounds Sounds;
 
@@ -75,6 +77,7 @@ public World(Viewer viewer, double gameTime)
             Scenery = new SceneryDrawer(viewer);
             Trains = new TrainDrawer(viewer);
             RoadCars = new RoadCarViewer(viewer);
+            Containers = new ContainersViewer(viewer);
             // Then sound.
             if (viewer.Settings.SoundDetailLevel > 0)
             {
@@ -94,6 +97,7 @@ public void Load()
             Scenery.Load();
             Trains.Load();
             RoadCars.Load();
+            Containers.Load();
             if (TileX != VisibleTileX || TileZ != VisibleTileZ)
             {
                 TileX = VisibleTileX;
@@ -111,6 +115,7 @@ public void Load()
                 Scenery.Mark();
                 Trains.Mark();
                 RoadCars.Mark();
+                Containers.Mark();
                 Viewer.Mark();
                 Viewer.ShapeManager.Sweep();
                 Viewer.MaterialManager.Sweep();
@@ -181,6 +186,7 @@ public void LoadPrep()
             Scenery.LoadPrep();
             Trains.LoadPrep();
             RoadCars.LoadPrep();
+            Containers.LoadPrep();
             VisibleTileX = Viewer.Camera.TileX;
             VisibleTileZ = Viewer.Camera.TileZ;
             PerformanceTune = Viewer.Settings.PerformanceTuner;
@@ -197,6 +203,7 @@ public void PrepareFrame(RenderFrame frame, ElapsedTime elapsedTime)
             Terrain.PrepareFrame(frame, elapsedTime);
             Scenery.PrepareFrame(frame, elapsedTime);
             Trains.PrepareFrame(frame, elapsedTime);
+            Containers.PrepareFrame(frame, elapsedTime);
             RoadCars.PrepareFrame(frame, elapsedTime);
         }
 
